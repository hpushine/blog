<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS字符串和Array方法]]></title>
    <url>%2Fblog%2F2018%2F05%2F30%2FJS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8CArray%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[String对象属性length属性length属性是字符串中的一个基本属性了，可以获取字符串长度，要注意的是js中的中文每个汉字也只代表一个字符。1234var str1 = &apos;abc&apos;;var str2 = &apos;中国&apos;;console.log(str1.length); //3console.log(str2.length); //2 prototype属性prototype属性用来给对象添加属性或方法，并且添加的方法或属性在所有的实例上共享。可以用来扩展js内置对象，如给字符串添加了一个去除两边空格的方法：123String.prototype.trim = function()&#123; return this.replace(/^\s*|\s*$/g, &apos;&apos;);&#125; 1234567891011121314函数式封装 function trim(str,type) &#123; // [type]类型 var type=type||"b"; if(type=="b")&#123; return str.replace(/^\s*|\s*$/g,""); // 去除两边的空白 &#125;else if(type=="l")&#123; return str.replace(/^\s*/g,""); // 去除左边空白 &#125;else if(type=="r")&#123; return str.replace(/\s*$/g,""); // 去除右边空白 &#125;else if(type=="a")&#123; return str.replace(/\s*/g,""); // 去除所有空白 &#125;&#125; String对象方法1. 获取类方法(1) charAt()charAt()方法可用来获取指定位置的字符串，参数为字符串索引值，从0开始到string.length - 1，若不在这个范围将返回一个空字符串123var str = &apos;abcde&apos;;console.log(str.charAt(2)); //返回cconsole.log(str.charAt(8)); //返回空字符串 (2) charCodeAt()charCodeAt()方法可返回指定位置的字符的Unicode编码。charCodeAt()方法与charAt()方法类似，都需要传入一个索引值作为参数，区别是前者返回指定位置的字符的编码，而后者返回的是字符子串12var str = &apos;abcde&apos;;console.log(str.charCodeAt(0)); //返回97 2. 查找类方法(1) indexOf()(数组中也有该方法)stringObject.indexOf(searchvalue,fromindex) indexOf()用来检索指定的字符串值在字符串中首次出现的位置。它可以接收两个参数，searchvalue表示要查找的子字符串，fromindex表示查找的开始位置，省略的话则从开始位置进行检索。1234var str = &apos;abcdeabcde&apos;;console.log(str.indexOf(&apos;a&apos;)); // 返回0console.log(str.indexOf(&apos;a&apos;, 3)); // 返回5console.log(str.indexOf(&apos;bc&apos;)); // 返回1 (2) lastIndexOf()(数组中也有该方法)stringObject.lastIndexOf(searchvalue,fromindex) lastIndexOf返回的是一个指定的子字符串值最后出现的位置，其检索顺序是从后向前。与indexOf()类似，这两个方法在搜索到第一个匹配的子字符串后就停止运行，所以如果想找到字符串中所有的子字符串出现的位置，可以循环调用。1234var str = &apos;abcdeabcde&apos;;console.log(str.lastIndexOf(&apos;a&apos;)); // 返回5console.log(str.lastIndexOf(&apos;a&apos;, 3)); // 返回0 从第索引3的位置往前检索console.log(str.lastIndexOf(&apos;bc&apos;)); // 返回6 (3) search()stringObject.search(substr)stringObject.search(regexp) search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。它会返回第一个匹配的子字符串的起始位置，如果没有匹配的，则返回-1。1234var str = &apos;abcDEF&apos;;console.log(str.search(&apos;c&apos;)); //返回2console.log(str.search(&apos;d&apos;)); //返回-1console.log(str.search(/d/i)); //返回3 (4) match()stringObject.match(substr)stringObject.match(regexp) match()方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 如果参数中传入的是子字符串或是没有进行全局匹配的正则表达式，那么match()方法会从开始位置执行一次匹配，如果没有匹配到结果，则返回null。否则则会返回一个数组，该数组的第0个元素存放的是匹配文本，除此之外，返回的数组还含有两个对象属性index和input，分别表示匹配文本的起始字符索引和stringObject 的引用(即原字符串)。1234var str = &apos;1a2b3c4d5e&apos;;console.log(str.match(&apos;h&apos;)); //返回nullconsole.log(str.match(&apos;b&apos;)); //返回[&quot;b&quot;, index: 3, input: &quot;1a2b3c4d5e&quot;]console.log(str.match(/b/)); //返回[&quot;b&quot;, index: 3, input: &quot;1a2b3c4d5e&quot;] 如果参数传入的是具有全局匹配的正则表达式，那么match()从开始位置进行多次匹配，直到最后。如果没有匹配到结果，则返回null。否则则会返回一个数组，数组中存放所有符合要求的子字符串，并且没有index和input属性。在字符串上调用这个方法本质上与调用RegExp的exec()方法相同。123var str = &apos;1a2b3c4d5e&apos;;console.log(str.match(/h/g)); //返回nullconsole.log(str.match(/\d/g)); //返回[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;] ES6新增includes()、startsWith()、endsWith()includes()：返回布尔值，表示是否找到了参数字符串startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部这三个方法的参数与indexOf()，lastIndexOf()一样1234var s = &apos;Hello world&apos;;s.startsWith(&apos;world&apos;,6); // trues.endsWith(&apos;Hello&apos;,5); // trues.includes(&apos;Hello&apos;,6); //false 注意：使用第2个参数n时，endsWith的行为与其他两个方法有所不同。它针对前面n个字符，而其他两个方法针对从第n个位置开始直到字符串结束的字符。 3. 截取类方法(1)substring()stringObject.substring(start,end) substring()是最常用到的字符串截取方法，它可以接收两个参数(参数不能为负值)，分别是要截取的开始位置和结束位置，它将返回一个新的字符串，其内容是从start处到end-1处的所有字符。若结束参数(end)省略，则表示从start位置一直截取到最后。1234var str = &apos;abcdefg&apos;;console.log(str.substring(1, 4)); //返回bcdconsole.log(str.substring(1)); //返回bcdefgconsole.log(str.substring(-1)); //返回abcdefg，传入负值时会视为0 (2) slice()(数组也有)stringObject.slice(start,end) slice()方法与substring()方法非常类似，它传入的两个参数也分别对应着开始位置和结束位置。而区别在于，slice()中的参数可以为负值，如果参数是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符。12345var str = &apos;abcdefg&apos;;console.log(str.slice(1, 4)); //返回bcdconsole.log(str.slice(-3, -1)); //返回efconsole.log(str.slice(1, -1)); //返回bcdefconsole.log(str.slice(-1, -3)); //返回空字符串，若传入的参数有问题，则返回空 (3) substr()stringObject.substr(start,length) substr()方法可在字符串中抽取从start下标开始的指定数目的字符。其返回值为一个字符串，包含从 stringObject的start（包括start所指的字符）处开始的length个字符。如果没有指定 length，那么返回的字符串包含从start到stringObject的结尾的字符。另外如果start为负数，则表示从字符串尾部开始算起。1234var str = &apos;abcdefg&apos;;console.log(str.substr(1, 3)) //返回bcdconsole.log(str.substr(2)) //返回cdefgconsole.log(str.substr(-2, 4)) //返回fg，目标长度较大的话，以实际截取的长度为准 4. 其他方法(1) replace()方法 stringObject.replace(regexp/substr,replacement) replace()方法用来进行字符串替换操作，它可以接收两个参数，前者为被替换的子字符串（可以是正则），后者为用来替换的文本。 如果第一个参数传入的是子字符串或是没有进行全局匹配的正则表达式，那么replace()方法将只进行一次替换（即替换最前面的），返回经过一次替换后的结果字符串。123var str = &apos;abcdeabcde&apos;;console.log(str.replace(&apos;a&apos;, &apos;A&apos;));console.log(str.replace(/a/, &apos;A&apos;)); 如果第一个参数传入的全局匹配的正则表达式，那么replace()将会对符合条件的子字符串进行多次替换，最后返回经过多次替换的结果字符串。123var str = &apos;abcdeabcdeABCDE&apos;;console.log(str.replace(/a/g, &apos;A&apos;)); //返回AbcdeAbcdeABCDEconsole.log(str.replace(/a/gi, &apos;$&apos;)); //返回$bcde$bcde$BCDE (2) split()方法 stringObject.split(separator,howmany) split()方法用于把一个字符串分割成字符串数组。第一个参数separator表示分割位置(参考符)，第二个参数howmany表示返回数组的允许最大长度(一般情况下不设置)。12345678var str = &apos;a|b|c|d|e&apos;;console.log(str.split(&apos;|&apos;)); //返回[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]console.log(str.split(&apos;|&apos;, 3)); //返回[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]console.log(str.split(&apos;&apos;)); //返回[&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;, &quot;|&quot;, &quot;d&quot;, &quot;|&quot;, &quot;e&quot;]也可以用正则来进行分割var str = &apos;a1b2c3d4e&apos;;console.log(str.split(/\d/)); //返回[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;] (3) toLowerCase()和toUpperCase()toLowerCase()方法可以把字符串中的大写字母转换为小写，toUpperCase()方法可以把字符串中的小写字母转换为大写123var str = &apos;JavaScript&apos;;console.log(str.toLowerCase()); //返回javascriptconsole.log(str.toUpperCase()); //返回JAVASCRIPT Array常用方法总结：pop,push,reverse,shift,sort,splice,unshift 会改变原数组join,concat,indexOf,lastIndexOf,slice,toString 不会改变原数组map,filter,some,every,reduce,forEach这些迭代方法不会改变原数组 几个注意点：shift,pop会返回那个被删除的元素splice 会返回被删除元素组成的数组，或者为空数组push 会返回新数组长度some 在有true的时候停止every 在有false的时候停止上述的迭代方法可以在最后追加一个参数thisArg，它是执行 callback 时的 this 值 参考链接：http://riny.net/2012/the-summary-of-javascript-string]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Javascript难点]]></title>
    <url>%2Fblog%2F2018%2F05%2F15%2FJavaScript%E9%9A%BE%E7%82%B9%2F</url>
    <content type="text"><![CDATA[JavaScript引擎是单线程运行的，浏览器无论在什么时候都有且只有一个线程在运行JavaScript程序，浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步。浏览器内核的实现至少有三个常驻线程：javascript引擎线程，界面渲染线程，浏览器事件触发线程，也有一些执行完就终止的线程，如Http请求线程，这些异步线程都会产生不同的异步事件，单线程的JavaScript引擎与另外那些线程进行互动通信，虽然每个浏览器内核实现细节不同，但这其中的调用原理都是大同小异。 原型与原型链说到原型，就得提一下构造函数，首先看下面一个简单的例子：1234567function Dog(name,age)&#123; this.name = name; this.age = age;&#125;let dog1 = new Dog("哈士奇",3);let dog2 = new Dog("泰迪",2); 首先创造空的对象，再让this指向这个对象，通过this.name进行赋值，最终返回this，这其实也是new 一个对象的过程。 其实： let obj = {} 是 let obj = new Object()的语法糖； let arr = [] 是 let arr = new Array()的语法糖； function Dog(){} 是 let Dog = new Fucntion()的语法糖。 在js中，所有对象都是Object的实例，并继承Object.prototype的属性和方法，但是有一些是隐性的。 看一下原型的规则： 1.所有的引用类型（包括数组，对象，函数）都具有对象特性；可自由扩展属性。123456var obj = &#123;&#125;;obj.attribute = "原型";var arr = [];arr.attribute = "作用域";function fn1 () &#123;&#125;fn1.attribute = "闭包"; 2.所有的引用类型（包括数组，对象，函数）都有隐性原型属性（proto）,值也是一个普通的对象。1console.log(obj.__proto__); 3.所有的函数，都有一个prototype属性，值也是一个普通的对象。1console.log(obj.prototype); 4.所有的引用类型的proto属性值都指向构造函数的prototype属性值。1console.log(obj.__proto__ === Object.prototype); // true 5.当试图获取对象属性时，如果对象本身没有这个属性，那就会去他的proto（prototype）中去寻找。 123456789101112function Dog(name)&#123; this.name = name; &#125; Dog.prototype.callName = function ()&#123; console.log(this.name,"wang wang"); &#125;let dog1 = new Dog("Three Mountain"); dog1.printName = function ()&#123; console.log(this.name);&#125;dog1.callName(); // Three Mountain wang wangdog1.printName(); // Three Mountain 原型链如下图：找一个属性，首先会在f.proto中去找，因为属性值为一个对象，那么就会去f.proto.proto去找，同理如果还没找到，就会一直向上去查找，直到结果为null为止，这个串起来的链即为原型链。 作用域及闭包说到作用域，肯定会想到是执行上下文。每个函数都有自己的excution context，和variable object。这些环境用于储存上下文中的变量，函数声明，参数等。只有函数才能制造作用域。PS：for if else 不能创造作用域1234567console.log(a) ; // undefinedvar a = 1;//可理解为var a;console.log(a); // undefineda = 1; 执行console.log时，a只是被声明出来，并没有赋值；所以结果当然是undefined。 this 本质上来说，在js里this是一个指向函数执行环境的指针，this永远指向最后调用它的对象，并且在执行时才能获取值，定义是无法确认它的值。箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。1234567891011121314var a = &#123; name : "A", fn : function （）&#123; console.log (this.name) &#125; &#125; a.fn() // this === a a 调用了fn() 所以此时this为aa.fn.call (&#123;name : "B"&#125;) // this === &#123;name : "B"&#125; 使用call(),将this的值指定为&#123;name:"B"&#125;var fn1 = a.fn fn1() // this === window 虽然指定fn1 = a.fn，但是调用是有window调用，所以 this 为window this有多种使用场景，下面会主要介绍4个使用场景： 1.作为构造函数执行123456function Student(name,age) &#123; this.name = name // this === s this.age = age // this === s //return this&#125;var s = new Student("hpu",22) 首先new 字段会创建一个空的对象，然后调用apply()函数，将this指向这个空对象。这样的话，函数内部的this就会被空对象代替。 2.作为普通函数执行1234function fn () &#123; console.log (this) // this === window&#125;fn () 3.作为对象属性执行1234567var obj = &#123; name : "A", printName : function () &#123; console.log (this.name) // this === obj &#125;&#125;obj.printName () 4.call()，apply()，bind() 三个函数可以修改this的指向，具体往下看：12345678910var name = "小明" , age = "17"var obj = &#123; name : "安妮", objAge : this.age, fun : function () &#123; console.log ( this.name + "今年" + this.age ) &#125; &#125; console.log(obj.objAge) // 17 obj.fun() // 安妮今年undefined 12345678910111213var name = &quot;小明&quot; , age = &quot;17&quot; var obj = &#123; name : &quot;安妮&quot;, objAge ：this.age, fun : function (like,dislike) &#123; console.log (this.name + &quot;今年&quot; + this.age ，&quot;喜欢吃&quot; + like + &quot;不喜欢吃&quot; + dislike) &#125; &#125; var a = &#123; name : &quot;Jay&quot;, age : 23 &#125; obj.fun.call(a,&quot;苹果&quot;,&quot;香蕉&quot;) // Jay今年23 喜欢吃苹果不喜欢吃香蕉 obj.fun.apply(a,[&quot;苹果&quot;,&quot;香蕉&quot;]) // Jay今年23 喜欢吃苹果不喜欢吃香蕉 obj.fun.bind(a,&quot;苹果&quot;,&quot;香蕉&quot;)() // Jay今年23 喜欢吃苹果不喜欢吃香蕉 首先call，apply，bind第一个参数都是this指向的对象，call和apply如果第一个参数指向null或undefined时，那么this会指向windows对象。 call，apply，bind的执行方式如上例所示。call，apply都是改变上下文中的this，并且是立即执行的。bind方法可以让对应的函数想什么时候调用就什么时候调用。 闭包 闭包的概念很抽象，看下面的例子理解什么叫闭包12345678910function a()&#123; var n = 0; this.fun = function () &#123; n++; console.log(n); &#125;;&#125;var c = new a();c.fun(); //1c.fun(); //2 闭包就是能够读取其他函数内部变量的函数。在js中只有函数内部的子函数才能读取局部变量。所以可以简单的理解为：定义在内部函数的函数。 用途主要有两个： 1）前面提到的，读取函数内部的变量。 2）让变量值始终保持在内存中。 异步和单线程先感受下异步12345console.log("start");setTimeout(function () &#123; console.log("medium");&#125;, 1000);console.log("end"); 使用异步后，打印的顺序为 start-&gt; end-&gt;medium，因为没有阻塞。 异步产生原因 首先因为js为单线程，也就是说CPU同一时间只能处理一个事务。得按顺序，一个一个处理。 如上例所示，第一步：执行第一行打印 “start”；第二步：执行setTimeout，将其中的函数分存起来，等待时间结束后执行；第三步：执行最后一行，打印“end”；第四步：处于空闲状态，查看暂存中，是否有可执行的函数；第五步：执行分存函数。 js引擎单线程 js的主要用途是与用户互动，以及操作DOM，这决定它只能是单线程。例：一个线程要添加DOM节点，一个线程要删减DOM节点，容易造成分歧。 为了更好使用多CPU，H5提供了web Worker 标准，允许js创建多线程，但是子线程受到主线程控制，而且不得操作DOM。 任务列队 单线程就意味着，所有的任务都要排队，前一个结束，才会执行后面的任务。如果列队是因为计算量大，CPU忙不过来，倒也算了。但是更多的时候，CPU是闲置的，因为IO设备处理得很慢，例如 ajax读取网络数据。js设计者便想到，主线程完全可以不管IO设备，将其挂起，然后执行后面的任务。等后面的任务结束掉，在反过头来处理挂起的任务。 梳理一下： 1）所有的同步任务都在主线程上执行，形成一个执行栈 2）除了主线程之外，还存在一个任务列队，只要一步任务有了运行结果，就在任务列队中植入一个时间 3）主线程完成所有任务，就会读取列队任务，并将其执行 4）重复上面三步 只要主线程空了，就会读取任务列队，这就是js的运行机制，也被称为 event loop（事件循环）。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>grammer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集群和负载均衡]]></title>
    <url>%2Fblog%2F2018%2F05%2F06%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[一个庞大的高访问量的业务系统，需要高性能、可靠的服务器框架支撑。高性能要求服务器在巨大压力下仍然高速运行，读写返回正确的业务信息，前端用户体验良好。可靠性要求服务器出现宕机、罢工等情况，可以及时恢复服务器正常工作状态，支持业务系统24小时健康运行。使用缓存、读写分离技术提高服务器访问资源速度，解决大访问量资源拥堵问题；使用负载均衡与高可用技术提高服务器响应速度以及服务器稳定性，解决服务器处理大用户量请求问题以及服务器宕机的及时恢复能力。同时，需要部署运维监控平台，监控服务器上服务程序与资源使用情况。 这样一个业务系统基础架构可以划分下面几个模块：负载均衡与代理、Web主站服务、APP接口服务、图片服务器、数据库与缓存服务。这里负载均衡和代理主要是两个作用：实现多台机器按照算法轮流工作，分担服务压力，当一台机器宕机或者罢工，其他机器也可以继续运行；代理隐藏服务内部真实结构，多台对外提供统一地址，运行相同业务系统，后文会详细介绍负载均衡。 主站框架是一个Web服务器（apache、tomcat、nginx等）集群，集群中全部机器运行相同业务系统。通过负载均衡代理与客户端通讯，每一次通讯只有一台机器为当前客户端服务。需要解决session共享问题，否则将会丢失用户的登录状态，在用户体验方面有逻辑错误。常见的共享session方法有数据库共享、cookie共享、内存共享。使用最多的是memcache共享方式，memcache把多个服务器的共享内存拼接成一块大的内存使用，保存用户的session信息。Tomcat服务集群可以简单配置memcache共享内存，PHP中也可以直接配置设置memcache共享内存。 Nginx负载解决session的方式：ip_hash、sticky。ip_hash根据IP保存响应服务器，在一张存储表单中，IP对应上次访问的服务器，以后来自于该IP的访问都使用这个这台服务器，解决session问题，存在局限性影响负载均衡的功能。Sticky使用cookie的方式解决session共享问题，其实是避开session共享。Sticky把cookie与服务器绑定，存储于客户端缓存当中，客户端再次访问时直接进入到cookie绑定的服务器，关闭客户端session也随之消失。 缓存服务可以提高服务的响应速度，处理及时性要求高的数据时，数据首先进入缓存，然后通过消息队列写入到数据库。从数据库查询出来的实时数据也可以保存在缓存中，在缓存中直接提供用户访问，执行用户操作数据请求，再把数据返回数据库。 Redis是一款出色的缓存服务器，内存级别的键值对数据库，支持丰富数据结构，数据库操作命令也是很齐全。最重要是Redis操作速度非常快，满足缓存服务器需求。Redis提供单机的分片集群，单机硬件性能要求比较高。Redis也可以进行分布式部署，搭建分布式缓存服务。 安全配置：隐藏常见系统服务信息、配置用户权限、开启防火墙、关闭无用系统服务、定期更新系统风险评估：进行渗透测试、漏洞扫描安全防御：配置IDS\IPS、进行源代码审计、DDOS防御、恶意代码检测 配置运维监控平台，实时监控服务器的健康状况。CPU、内存、磁盘、输入输出、网络性能等参数，配置报警规则，触发报警是立即调用API接口或者第三方回调，发送报警信息到邮箱、微信等。同时，自定监控数据项，检测Web服务、数据库服务、后台程序等运行状态，连续出现拒绝服务行为立刻报警，通知管理员。 负载均衡介绍负载均衡（Load Balance）是建立在现有网络结构之上，提供一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。就是分摊任务到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 负载均衡，核心就是网络流量分发，服务器负载均衡根据LB设备处理到的报文层次，分为四层服务器负载均衡（TCP，UDP）和七层负载均衡（HTTP，HTTPS等），四层处理到IP包的IP头，不解析报文四层以上载荷（L4 SLB），基本就是根据连接信息（TCP）或者本身的特征（源IP，目标IP）等做；七层处理到报文载荷部分，比如HTTP，RTSP，SIP报文头，有时也包括报文内容部分，可以用域名（HTTP头里的Host），URL，Cookie，Header这些信息来做。四层LB可以说是作为路由进行流量转发，七层LB常称作代理。 负载均衡根据所采用的设备对象（软硬件负载均衡），应用的OSI网络层次（网络层次上的负载均衡），及应用的地理结构（本地/全局负载均衡）等来分类。负载均衡现在比较新的做法是用dpdk这种内核bypass方案做的负载均衡，绕过了linux内核比较复杂的网络协议栈，因此性能会有明显的提升（轻松跑满万兆网卡）。 根据负载均衡所作用在 OSI 模型的位置不同，负载均衡可以大概分为以下几类： 二层负载均衡（mac） 根据OSI模型分的二层负载，一般是用虚拟mac地址方式，外部对虚拟MAC地址请求，负载均衡接收后分配后端实际的MAC地址响应。 三层负载均衡（ip） 一般采用虚拟IP地址方式，外部对虚拟的ip地址请求，负载均衡接收后分配后端实际的IP地址响应。 四层负载均衡（tcp） 在三层负载均衡的基础上，用ip+port接收请求，再转发到对应的机器。 七层负载均衡（http） 根据虚拟的url或IP，主机名接收请求，再转向相应的处理服务器。反向代理，就是通过代理来做（Nginx）。由于流量都会过LB，因此可以做到比较精细的流量分发（比如各种权重，七层的各种转发规则）。坏处就是代理本身可能成为瓶颈，以及过了一层代理造成网络延时的增加，而代理本身也会有一定成本，因此实现成本较高。 在实际应用中，比较常见的就是四层负载及七层负载。这里也重点说下这两种负载。 一、四层负载均衡（基于IP+端口的负载均衡）所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。 在三层负载均衡的基础上，通过发布三层的IP地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。 以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。 对应的负载均衡器称为四层交换机（L4 switch），主要分析IP层及TCP/UDP层，实现四层负载均衡。此种负载均衡器不理解应用协议（如HTTP/FTP/MySQL等等）要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。 实现四层负载均衡的软件有：F5：硬件负载均衡器，功能很好，但是成本很高。lvs：重量级的四层负载软件nginx：轻量级的四层负载软件，带缓存功能，正则表达式较灵活haproxy：模拟四层转发，较灵活 二、七层负载均衡（基于虚拟的URL或主机IP的负载均衡）所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。 在四层负载均衡的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。 以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。 对应的负载均衡器称为七层交换机（L7 switch），除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息，实现七层负载均衡。此种负载均衡器能理解应用协议。 实现七层负载均衡的软件有：haproxy：天生负载均衡技能，全面支持七层代理，会话保持，标记，路径转移；nginx：只在http协议和mail协议上功能比较好，性能与haproxy差不多；apache：功能较差Mysql proxy：功能尚可 四层和七层负载均衡的区别，举个例子形象的说明：四层负载均衡就像银行的自助排号机，每一个达到银行的客户根据排号机的顺序，选择对应的窗口接受服务；而七层负载均衡像银行大堂经理，先确认客户需要办理的业务，再安排排号。这样办理理财、存取款等业务的客户，会根据银行内部资源得到统一协调处理，加快客户业务办理流程。 特征 四层负载均衡 七层负载均衡 基于 基于IP+Port的 基于虚拟的URL或主机IP等 类似 路由器 代理服务器 握手次数 1次 2次 复杂度 低 高 性能 高，无需解析内容 中，需要算法识别 URL，Cookie 和 HTTP head 等信息 安全性 低，无法识别 DDoS等攻击 高， 可以防御SYN cookie以SYN flood等 额外 无 会话保持，图片压缩，防盗链等 总结：从上面的对比看来四层负载与七层负载最大的区别就是效率与功能的区别。四层负载架构设计比较简单，无需解析具体的消息内容，在网络吞吐量及处理能力上会相对比较高，而七层负载均衡的优势则体现在功能多，控制灵活强大。在具体业务架构设计时，使用七层负载或者四层负载还得根据具体的情况综合考虑。 以下介绍下四层七层负载均衡实现方式 一、http重定向当http代理（比如浏览器）向web服务器请求某个URL后，web服务器可以通过http响应头信息中的Location标记来返回一个新的URL。这意味着HTTP代理需要继续请求这个新的URL，完成自动跳转。 性能缺陷：1、吞吐率限制主站点服务器的吞吐率平均分配到了被转移的服务器。现假设使用RR（Round Robin）调度策略，子服务器的最大吞吐率为1000reqs/s，那么主服务器的吞吐率要达到3000reqs/s才能完全发挥三台子服务器的作用，那么如果有100台子服务器，那么主服务器的吞吐率可想而知得有大？相反，如果主服务的最大吞吐率为6000reqs/s，那么平均分配到子服务器的吞吐率为2000reqs/s，而现子服务器的最大吞吐率为1000reqs/s，因此就得增加子服务器的数量，增加到6个才能满足。 2、重定向访问深度不同有的重定向一个静态页面，有的重定向相比复杂的动态页面，那么实际服务器的负载差异是不可预料的，而主站服务器却一无所知。因此整站使用重定向方法做负载均衡不太好。 我们需要权衡转移请求的开销和处理实际请求的开销，前者相对于后者越小，那么重定向的意义就越大，例如下载。你可以去很多镜像下载网站试下，会发现基本下载都使用了Location做了重定向。 二、DNS负载均衡DNS负责提供域名解析服务，当访问某个站点时，实际上首先需要通过该站点域名的DNS服务器来获取域名指向的IP地址，在这一过程中，DNS服务器完成了域名到IP地址的映射，同样，这样映射也可以是一对多的，这时候，DNS服务器便充当了负载均衡调度器，它就像http重定向转换策略一样，将用户的请求分散到多台服务器上，但是它的实现机制完全不同。 相比http重定向，基于DNS的负载均衡完全节省了所谓的主站点，或者说DNS服务器已经充当了主站点的职能。但不同的是，作为调度器，DNS服务器本身的性能几乎不用担心。因为DNS记录可以被用户浏览器或者互联网接入服务商的各级DNS服务器缓存，只有当缓存过期后才会重新向域名的DNS服务器请求解析。也说是DNS不存在http的吞吐率限制，理论上可以无限增加实际服务器的数量。 特性:1、可以根据用户IP来进行智能解析。DNS服务器可以在所有可用的A记录中寻找离用记最近的一台服务器。 2、动态DNS：在每次IP地址变更时，及时更新DNS服务器。当然，因为缓存，一定的延迟不可避免。 不足：1、没有用户能直接看到DNS解析到了哪一台实际服务器，加服务器运维人员的调试带来了不便。 2、策略的局限性。例如你无法将HTTP请求的上下文引入到调度策略中，而在前面介绍的基于HTTP重定向的负载均衡系统中，调度器工作在HTTP层面，它可以充分理解HTTP请求后根据站点的应用逻辑来设计调度策略，比如根据请求不同的URL来进行合理的过滤和转移。 3、如果要根据实际服务器的实时负载差异来调整调度策略，这需要DNS服务器在每次解析操作时分析各服务器的健康状态，对于DNS服务器来说，这种自定义开发存在较高的门槛，更何况大多数站点只是使用第三方DNS服务。 4、DNS记录缓存，各级节点的DNS服务器不同程序的缓存会让你晕头转向。 5、基于以上几点，DNS服务器并不能很好地完成工作量均衡分配，最后，是否选择基于DNS的负载均衡方式完全取决于你的需要。 三、反向代理负载均衡这个肯定大家都有所接触，因为几乎所有主流的Web服务器都热衷于支持基于反向代理的负载均衡。它的核心工作就是转发HTTP请求。 相比前面的HTTP重定向和DNS解析，反向代理的调度器扮演的是用户和实际服务器中间人的角色： 1、任何对于实际服务器的HTTP请求都必须经过调度器 2、调度器必须等待实际服务器的HTTP响应，并将它反馈给用户（前两种方式不需要经过调度反馈，是实际服务器直接发送给用户） 特性：1、调度策略丰富。例如可以为不同的实际服务器设置不同的权重，以达到能者多劳的效果。 2、对反向代理服务器的并发处理能力要求高，因为它工作在HTTP层面。 3、反向代理服务器进行转发操作本身是需要一定开销的，比如创建线程、与后端服务器建立TCP连接、接收后端服务器返回的处理结果、分析HTTP头部信息、用户空间和内核空间的频繁切换等，虽然这部分时间并不长，但是当后端服务器处理请求的时间非常短时，转发的开销就显得尤为突出。例如请求静态文件，更适合使用前面介绍的基于DNS的负载均衡方式。 4、反向代理服务器可以监控后端服务器，比如系统负载、响应时间、是否可用、TCP连接数、流量等，从而根据这些数据调整负载均衡的策略。 5、反射代理服务器可以让用户在一次会话周期内的所有请求始终转发到一台特定的后端服务器（粘滞会话），这样的好处一是保持session的本地访问，二是防止后端服务器的动态内存缓存的资源浪费。 四、IP负载均衡(LVS-NAT)NAT服务器:它工作在传输层，它可以修改发送来的IP数据包，将数据包的目标地址修改为实际服务器地址。 数据的流向： 客户端 –&gt; Load Balancer –&gt; RS –&gt; Load Balancer –&gt; 客户端 从Linux2.4内核开始，其内置的Neftilter模块在内核中维护着一些数据包过滤表，这些表包含了用于控制数据包过滤的规则。可喜的是，Linux提供了iptables来对过滤表进行插入、修改和删除等操作。更加令人振奋的是，Linux2.6.x内核中内置了IPVS模块，它的工作性质类型于Netfilter模块，不过它更专注于实现IP负载均衡。 IPVS的管理工具是ipvsadm，它为提供了基于命令行的配置界面，可以通过它快速实现负载均衡系统。这就是大名鼎鼎的LVS(Linux Virtual Server，Linux虚拟服务器)。 1、打开调度器的数据包转发选项 echo 1 &gt; /proc/sys/net/ipv4/ip_forward 2、检查实际服务器是否已经将NAT服务器作为自己的默认网关，如果不是，如添加 route add default gw xx.xx.xx.xx 3、使用ipvsadm配置 ipvsadm -A -t 111.11.11.11:80 -s rr 添加一台虚拟服务器，-t 后面是服务器的外网ip和端口，-s rr是指采用简单轮询的RR调度策略（这属于静态调度策略，除此之外，LVS还提供了系列的动态调度策略，比如最小连接（LC）、带权重的最小连接（WLC），最短期望时间延迟（SED）等） ipvsadm -a -t 111.11.11.11:80 -r 10.10.120.210:8000 -m ipvsadm -a -t 111.11.11.11:80 -r 10.10.120.211:8000 -m 添加两台实际服务器（不需要有外网ip），-r后面是实际服务器的内网ip和端口，-m表示采用NAT方式来转发数据包 运行ipvsadm -L -n可以查看实际服务器的状态。这样就大功告成了。 实验证明使用基于NAT的负载均衡系统。作为调度器的NAT服务器可以将吞吐率提升到一个新的高度，几乎是反向代理服务器的两倍以上，这大多归功于在内核中进行请求转发的较低开销。但是一旦请求的内容过大时，不论是基于反向代理还是NAT，负载均衡的整体吞吐量都差距不大，这说明对于一开销较大的内容，使用简单的反向代理来搭建负载均衡系统是值考虑的。 这么强大的系统还是有它的瓶颈，那就是NAT服务器的网络带宽，包括内部网络和外部网络。当然可以配备千兆交换机或万兆交换机，甚至负载均衡硬件设备，除了这另一个简单有效的办法就是将基于NAT的集群和前面的DNS混合使用，比如５个100Mbps出口宽带的集群，然后通过DNS来将用户请求均衡地指向这些集群，同时，你还可以利用DNS智能解析实现地域就近访问。这样的配置对于大多数业务是足够了，但是对于提供下载或视频等服务的大规模站点，NAT服务器还是不够出色。 五、直接路由(LVS-DR)NAT是工作在网络分层模型的传输层（第四层），而直接路由是工作在数据链路层（第二层），貌似更屌些。它通过修改数据包的目标MAC地址（没有修改目标IP），将数据包转发到实际服务器上，不同的是，实际服务器的响应数据包将直接发送给客户羰，而不经过调度器。 数据的流向： 客户端 –&gt; Load Balancer –&gt; RS –&gt; 客户端 1、网络设置 这里假设一台负载均衡调度器，两台实际服务器，购买三个外网ip，一台机一个，三台机的默认网关需要相同，最后再设置同样的ip别名，这里假设别名为10.10.120.193。这样一来，将通过10.10.120.193这个IP别名来访问调度器，你可以将站点的域名指向这个IP别名。 2、将ip别名添加到回环接口lo上 这是为了让实际服务器不要去寻找其他拥有这个IP别名的服务器，在实际服务器中运行： 另外还要防止实际服务器响应来自网络中针对IP别名的ARP广播，为此还要执行： echo “1” &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore echo “2” &gt; /proc/sys/net/ipv4/conf/lo/arp_announce echo “1” &gt; /proc/sys/net/ipv4/conf/all/arp_ignore echo “1” &gt; /proc/sys/net/ipv4/conf/all/arp_announce 配置完了就可以使用ipvsadm配置LVS-DR集群了 ipvsadm -A -t 10.10.120.193:80 -s rr ipvsadm -a -t 10.10.120.193:80 -r 10.10.120.210:8000 -g ipvsadm -a -t 10.10.120.193:80 -r 10.10.120.211:8000 -g -g 就意味着使用直接路由的方式转发数据包 LVS-DR 相较于LVS-NAT的最大优势在于LVS-DR不受调度器宽带的限制，例如假设三台服务器在WAN交换机出口宽带都限制为10Mbps，只要对于连接调度器和两台实际服务器的LAN交换机没有限速，那么，使用LVS-DR理论上可以达到20Mbps的最大出口宽带，因为它的实际服务器的响应数据包可以不经过调度器而直接发往用户端啊，所以它与调度器的出口宽带没有关系，只能自身的有关系。而如果使用LVS-NAT，集群只能最大使用10Mbps的宽带。所以，越是响应数据包远远超过请求数据包的服务，就越应该降低调度器转移请求的开销，也就越能提高整体的扩展能力，最终也就越依赖于WAN出口宽带。 总的来说，LVS-DR适合搭建可扩展的负载均衡系统，不论是Web服务器还是文件服务器，以及视频服务器，它都拥有出色的性能。前提是你必须为实际器购买一系列的合法IP地址。 六、IP隧道(LVS-TUN)基于IP隧道的请求转发机制：将调度器收到的IP数据包封装在一个新的IP数据包中，转交给实际服务器，然后实际服务器的响应数据包可以直接到达用户端。目前Linux大多支持，可以用LVS来实现，称为LVS-TUN，与LVS-DR不同的是，实际服务器可以和调度器不在同一个WANt网段，调度器通过IP隧道技术来转发请求到实际服务器，所以实际服务器也必须拥有合法的IP地址。 总体来说，LVS-DR和LVS-TUN都适合响应和请求不对称的Web服务器，如何从它们中做出选择，取决于你的网络部署需要，因为LVS-TUN可以将实际服务器根据需要部署在不同的地域，并且根据就近访问的原则来转移请求，所以有类似这种需求的，就应该选择LVS-TUN。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git简要教程]]></title>
    <url>%2Fblog%2F2018%2F04%2F26%2Fgit%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[配置 GitGit的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 一、 创建与合并分支1、 从master分支创建dev分支并切换到dev分支123git checkout mastergit checkout -b dev 其中，git checkout -b dev 等价于:123git branch devgit checkout dev 查看本地当前的分支，分支前面带“*”表示当前分支，剩下的分支表示本地有的分支。1git branch 查看远程全部的分支，白色的表示本地有的，红色的表示本地没有，仅在远程存在。1git branch -a 2、修改代码、提交代码（当前的操作是在dev分支上进行）123git add a.htmlgit commit -m &quot;提交文件a.html&quot; 3、分支合并(将dev合并到master)123git checkout master git merge dev 4、合并完成后，删除dev分支.(删除dev分支时，注意我们当前所在的分支不能是dev分支)1git branch -d dev 5、删除后，查看分支(此时看不到dev分支了)1git branch 6、总结 ：工作中经常从master创建新的分支，具体操作如下12345678910111213master创建新分支：git checkout mastergit checkout -b issues1234git push origin issues1234git add .git commit -m &quot;***&quot;git push origin issues1234 注意：将本地分支branch1推到远端的branch2操作步骤：git push origin branch1:branch2 7、删除分支：123git branch -D issues1234 //本地强制删除分支issues1234git push origin :issues1234 //推到远程 二、 解决冲突1、发生冲突的文件12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 其中，git使用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记文件中自己和别人产生冲突的部分。 在&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======之间为自己的代码；=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间为别人的代码。 如果保留自己的代码，将别人的代码删掉即可。 2、冲突解决后提交1234567git statusgit add ***git commit -m &quot;fix conflict&quot;git push origin 分支名 三、Bug分支1、储藏更改:将当前更改的代码储藏起来，等以后恢复使用1git stash 2、恢复储藏的代码123456789git stash pop //恢复的同时把stash内容删掉或者git stash apply //恢复stash，但是stash内容并不删除git stash drop //在上面操作的基础上，以此来删除stash注： git stash list //查看全部的stash列表 3、将stash空间清空1git stash clear 4、git stash pop 和 git stash apply 区别123原来git stash pop stash@&#123;id&#125;命令会在执行后将对应的stash id 从stash list里删除而 git stash apply stash@&#123;id&#125; 命令则会继续保存stash id。 四、版本回退1、回退至上一个版本1git reset --hard HEAD 2、回退至指定版本1git reset --hard 版本号 3、查看以往版本号(本地的commit)1git reflog 4、查看各版本号及信息(所有的commit：本地commit + 其他同事的commit)1git log 五、撤销修改1、撤销修改1git checkout -- a.html 分两种情况分析：①： 还没有执行 git add 操作，执行上面的操作后，会恢复到和版本库中一模一样的版本状态。 ②： 执行了git add ，还没执行 git commit ,再执行上面的操作后，会恢复到git add 结束后的状态 注：一旦执行了git commit -m “*”，就不能再使用上面的命令回退。 2、撤销新建文件 比如新建一个aa.html页面，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：1git clean -f ../aa.html 3、撤销新建文件夹 比如新建一个文件夹”demo”，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：1git clean -df ./demo 六、对于已经push的版本，进行回退1、第一步：1git reset --hard 版本号 //本地回退到指定的版本 2、第二步：1git push -f origin dev //将远程的也回退到指定版本 七、本地同步远程删除的分支123git fetch origin -p //用来清除已经没有远程信息的分支这样git branch -a 就不会拉取远程已经删除的分支了 八、删除掉没有与远程分支对应的本地分支从gitlab上看不到的分支在本地可以通过git branch -a 查到，删掉没有与远程分支对应的本地分支：1git fetch -p 九、查看远程库的一些信息，及与本地分支的信息1git remote show origin Git命令清单增加删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支命令123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签命令1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 参考链接：https://segmentfault.com/a/1190000014461898 参考链接：http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html]]></content>
      <categories>
        <category>实践教程</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端H5缓存]]></title>
    <url>%2Fblog%2F2018%2F04%2F20%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[HTML5是新一代的HTML标准，加入很多新的特性。离线存储（亦称为缓存机制）是其中一个非常重要的特性。HTML5引入了离线存储，这意味着移动Web应用可进行缓存，并可在没有Internet连接时离线进行访问。HTML5应用程序缓存为应用带来三个优势：123离线浏览：用户可在应用离线时使用它们；速度：已缓存资源加载得更快；减少服务器负载：浏览器将只从服务器下载更新过或更改过的资源。 根据标准，到目前为止，H5共有6种缓存机制，有些是之前已有，有些是H5才新加入的。123456浏览器缓存机制Dom Storgage（Web Storage）存储机制Web SQL Database存储机制（不推荐）Application Cache（AppCache）机制Indexed Database （IndexedDB）File System API 下面分析各种缓存机制的原理、用法及特点；然后针对Android移动端Web性能加载优化的需求，看如何适当利用缓存机制来提高Web的加载性能。 1. 浏览器缓存机制浏览器缓存机制是指通过HTTP协议头里的Cache-Control（或Expires）和Last-Modified（或Etag）等字段来控制文件缓存的机制。这应该是Web中最早的缓存机制了，是在HTTP协议中实现的，有点不同于Dom Storage、AppCache等缓存机制，但本质上是一样的，可以理解为一个是协议层实现的，一个是应用层实现的。 Cache-Control和Last-Modified一般用在静态资源文件上，如JS、CSS和一些图像文件。通过设置资源文件缓存属性，对提高资源文件加载速度，节省流量很有意义，特别是移动网络环境。但问题是：缓存有效时长应该如何设置，如果太短，就起不到缓存的使用，设置的太长，在服务端资源文件有更新时，浏览器有缓存，则不能及时取到最新的文件。 对于移动端的缓存，任何一个网络请求的增加，加载消耗时间都是比较大的（尤其弱网环境下）。对于强缓存只要缓存不到期，是不会向服务器发送请求，但是如果是协商缓存的情况下，304的问题就比较大，它会造成无用的服务器请求，导致网络的延时。Last-Modified需要向服务器发起查询请求，才能知道资源文件有没有更新，虽然服务器可能返回304告诉没有更新，但也还有一个请求的过程。对于移动网络，这个请求可能是比较耗时的，有一种说法叫“消灭304”，指的就是优化掉304的请求。 通过抓包可以发现，带if-Modified-Since字段的请求，如果服务器回包304，回包会带有Cache-Control:max-age或Expires字段，文件的强缓存有效时间会更新，就是文件强缓存会重新有效。304回包后如果再请求，则又可以直接使用本地缓存文件了，不用再向服务器发送请求查询文件是否更新了，除非新的强缓存资源文件时间再次过期。 另外，Cache-Control与Last-Modified是浏览器内核的机制，一般都是标准的实现，不能更改或设置。以QQ浏览器的X5为例，Cache-Control与Last-Modified缓存不能禁用，缓存容量是12MB，不分Host，过期的缓存会最先被清除。如果都没过期，应该优先清最早的缓存或最快到期的或文件大小最大的，过期缓存也有可能还是有效的，清除缓存会导致资源文件的重新拉取。还有，浏览器，如X5，在使用缓存文件时，是没有对缓存文件内容进行校验的，这样缓存文件内容被修改的可能。 分析发现，浏览器的缓存机制还不是非常完美的缓存机制。完美的缓存机制应该是这样的： 缓存文件没更新，尽可能使用缓存，不用和服务器交互；缓存文件有更新时，第一时间能使用到新的文件；缓存的文件要保持完整性，不使用被修改过的缓存文件；缓存的容量大小要能设置或控制，缓存文件不能因为存储空间限制或过期被清除。 以X5为例，第1、2条不能同时满足，第3、4条都不能满足。 在实际应用中，为了解决Cache-Control缓存时长不好设置的问题，以及为了“消灭304”，采用的方式是： 1. 在要缓存的资源文件名中加上版本号或文件MD5值字串，如common.d5d02a02.js、common.v1.js，同时设置Cache-Control:max-age=31536000，也就是一年。在一年时间内，资源文件如果本地有缓存，就会使用缓存,这样就可以避免协商缓存的304的回包现象。2. 如果资源文件有修改，则更新文件内容，同时修改资源文件名，如common.v2.js，html页面也会引用新的资源文件名，实现静态资源非覆盖式更新。通过这种方式，实现了：缓存文件没有更新，则使用缓存；缓存文件有更新，则第一时间使用最新文件的目的。即上面说的第1、2条。第3、4条由于浏览器内部机制，目前还无法满足。 2. Dom Storage（Web Storage）存储机制DOM存储是一套在Web Applications 1.0规范中首次引入的与存储相关的特性的总称，现在已经分离出来，单独发展成为独立的W3C Web存储规范。DOM存储被设计为用来提供一个更大存储量、更安全、更便捷的存储方法，从而可以代替掉将一些不需要让服务器知道的信息存储到Cookies里的这种传统方法。这是对Dom Storage存储机制的官方表述。 Dom Storage是通过存储字符串的Key/Value对来提供的，并提供5MB（不同浏览器可能不同，分Host）的存储空间（Cookies才4KB)。另外Dom Storage存储的数据在本地，不像 Cookies，每次请求一次页面，Cookies 都会发送给服务器。 DOM Storage分为sessionStorage和localStorage。localStorage对象和sessionStorage对象使用方法基本相同，它们的区别在于作用的范围不同。sessionStorage用来存储与页面相关的数据，它在页面关闭后无法使用。而localStorage则持久存在，在页面关闭后也可以使用。 sessionStorage是个全局对象，它维护着在页面会话（page session）期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入（reload）或者被恢复（restores）时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。 当浏览器被意外刷新的时候，一些临时数据应当被保存和恢复。sessionStorage对象在处理这种情况的时候是最有用的，比如恢复我们在表单中已经填写的数据。1234567891011121314151617181920212223&lt;script type="text/javascript"&gt; // 当页面刷新时，从sessionStorage恢复之前输入的内容 window.onload = function()&#123; if (window.sessionStorage) &#123; var name = window.sessionStorage.getItem("name"); if (name != "" || name != null)&#123; document.getElementById("name").value = name; &#125; &#125; &#125;; // 将数据保存到sessionStorage对象中 function saveToStorage() &#123; if (window.sessionStorage) &#123; var name = document.getElementById("name").value; window.sessionStorage.setItem("name", name); window.location.href="session_storage.html"; &#125; &#125; &lt;/script&gt;&lt;form action="./session_storage.html"&gt; &lt;input type="text" name="name" id="name"/&gt; &lt;input type="button" value="Save" onclick="saveToStorage()"/&gt;&lt;/form&gt;&lt;br&gt; 把上面的代码复制到session_storage.html（也可以从附件中直接下载）页面中，用Google Chrome浏览器的不同Page或Window打开，在输入框中分别输入不同的文字，再点击“Save”，然后分别刷新。每个Page或Window显示都是当前Page输入的内容，互不影响。关闭Page，再重新打开，上一次输入保存的内容已经没有了。 Local Storage的接口、用法与Session Storage一样，唯一不同的是：Local Storage保存的数据是持久性的。当前Page关闭（Page Session结束后），保存的数据依然存在。重新打开Page，上次保存的数据可以获取到。另外，Local Storage是全局性的，同时打开两个Page会共享一份存数据，在一个Page中修改数据，另一个Page中是可以感知到的。123456789101112131415&lt;script&gt; // 通过localStorage直接引用key, 另一种写法，等价于： // localStorage.getItem(&quot;pageLoadCount&quot;); // localStorage.setItem(&quot;pageLoadCount&quot;, value); if (!localStorage.pageLoadCount) &#123; localStorage.pageLoadCount = 0; localStorage.pageLoadCount = parseInt(localStorage.pageLoadCount) + 1; document.getElementById(&apos;count&apos;).textContent = localStorage.pageLoadCount; &#125;&lt;/script&gt;&lt;p&gt; You have viewed this page &lt;span id=&quot;count&quot;&gt;an untold number of&lt;/span&gt; time(s)&lt;/p&gt;&lt;br&gt; 将上面代码复制到local_storage.html的页面中，用浏览器打开，pageLoadCount的值是1；关闭Page重新打开，pageLoadCount的值是2。这是因为第一次的值已经保存了。用两个Page同时打开local_storage.html，并分别交替刷新，发现两个Page是共享一个pageLoadCount的。 分析：Dom Storage给Web提供了一种更录活的数据存储方式，存储空间更大（相对Cookies），用法也比较简单，方便存储服务器或本地的一些临时数据。 从Dom Storage提供的接口来看，Dom Storage适合存储比较简单的数据，如果要存储结构化的数据，可能要借助JSON了，将要存储的对象转为JSON字串。不太适合存储比较复杂或存储空间要求比较大的数据，也不适合存储静态的文件等。 在Android内嵌Webview中，需要通过Webview设置接口启用Dom Storage。123WebView myWebView = (WebView) findViewById(R.id.webview);WebSettings webSettings = myWebView.getSettings();webSettings.setDomStorageEnabled(true);&lt;br&gt; 拿Android类比的话，Web的Dom Storage机制类似于Android的SharedPreference机制。 3. Web SQL Database存储机制HTML5也提供基于SQL的数据库存储机制，用于存储适合数据库的结构化数据。但根据官方的标准文档，这种存储机制不再推荐使用，将来也不再维护，而是推荐使用AppCache和IndexedDB，所以这里就不多做阐述了。 4. Application Cache机制Application Cache（简称AppCache）似乎是为支持Web App离线使用而开发的缓存机制。它的缓存机制类似于浏览器的缓存（Cache-Control和Last-Modified）机制，都是以文件为单位进行缓存，且文件有一定更新机制。但AppCache是对浏览器缓存机制的补充，不是替代。先拿W3C官方的一个例子，说下AppCache机制的用法与功能：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html manifest="demo_html.appcache"&gt;&lt;body&gt;&lt;script src="demo_time.js"&gt;&lt;/script&gt; &lt;p id="timePara"&gt;&lt;button onclick="getDateTime()"&gt;Get Date and Time&lt;/button&gt;&lt;/p&gt; &lt;p&gt;&lt;img src="img_logo.gif" width="336" height="69"&gt;&lt;/p&gt; &lt;p&gt; Try opening &lt;a href="tryhtml5_html_manifest.htm" target="_blank"&gt; this page&lt;/a&gt; , then go offline, and reload the page. The script and the image should still work. &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 上面HTML文档，引用外部一个JS文件和一个GIF图片文件，在其HTML头中通过manifest属性引用了一个appcache结尾的文件。 我们在Google Chrome浏览器中打开这个HTML链接，JS功能正常，图片也显示正常。禁用网络，关闭浏览器重新打开这个链接，发现JS工作正常，图片也显示正常。当然也有可能是浏览缓存起的作用，我们可以在文件的浏览器缓存过期后，禁用网络再试，发现HTML页面也是正常的。 通过Google Chrome浏览器自带的工具，我们可以查看已经缓存的AppCache（分Host）。 上面截图中的缓存，就是我们刚才打开HTML的页面AppCache。从截图中看，HTML页面及HTML引用的JS、GIF图像文件都被缓存了；另外HTML头中manifest属性引用的appcache文件也缓存了。 AppCache的原理有两个关键点：manifest属性和manifest文件。 HTML在头中通过manifest属性引用manifest文件。manifest文件，就是上面以appcache结尾的文件，是一个普通文件文件，列出了需要缓存的文件。123CACHE MANIFESTdemo.jsimg.gif 上面截图中的manifest文件，就HTML代码引用的manifest文件。文件比较简单，第一行是关键字，第二、三行就是要缓存的文件路径（相对路径）。这只是最简单的manifest文件，完整的还包括其他关键字与内容。引用manifest文件的HTML和manifest文件中列出的要缓存的文件最终都会被浏览器缓存。 完整的manifest文件，包括三个Section，如下：123456789CACHE MANIFEST# 2012-02-21 v1.0.0/theme.css/logo.gif/main.jsNETWORK:login.aspFALLBACK:/html/ /offline.html 总的来说，浏览器在首次加载HTML文件时，会解析manifest属性，并读取manifest文件，获取CACHE MANIFEST下要缓存的文件列表，再对文件缓存。 AppCache的缓存文件，与浏览器的缓存文件分开存储的，还是一份？应该是分开的。因为AppCache在本地也有5MB（分Host）的空间限制。 AppCache在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新manifest文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查manifest文件有没有修改（byte by byte)，发现有修改，就会重新获取manifest文件，对CACHE MANIFEST下文件列表检查更新。manifest文件与缓存文件的检查更新也遵守浏览器缓存机制。 如用用户手动清了AppCache缓存，下次加载时，浏览器会重新生成缓存，也可算是一种缓存的更新。另外，Web App也可用代码实现缓存更新。 分析：AppCache看起来是一种比较好的缓存方法，除了缓存静态资源文件外，也适合构建Web离线 App。在实际使用中有些需要注意的地方，有一些可以说是”坑“。 1. 要更新缓存的文件，需要更新包含它的manifest文件，那怕只加一个空格。常用的方法，是修改manifest文件注释中的版本号。如：# 2012-02-21 v1.0.0。 2.被缓存的文件，浏览器是先使用，再通过检查manifest文件是否有更新来更新缓存文件。这样缓存文件可能用的不是最新的版本。 3. 在更新缓存过程中，如果有一个文件更新失败，则整个更新会失败。 4. manifest和引用它的HTML要在相同Host。 5. manifest文件中的文件列表，如果是相对路径，则是相对manifest文件的相对路径。 6. manifest也有可能更新出错，导致缓存文件更新失败。 7. 没有缓存的资源在已经缓存的HTML中不能加载，即使有网络。例如：http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-network/。 8. manifest文件本身不能被缓存，且manifest文件的更新使用的是浏览器缓存机制。所以manifest文件的Cache-Control缓存时间不能设置太长。另外，根据官方文档，AppCache已经不推荐使用了，标准也不会再支持。现在主流的浏览器都是还支持AppCache的，以后就不太确定了。 在Android内嵌Webview中，需要通过Webview设置接口启用AppCache，同时还要设置缓存文件的存储路径，另外还可以设置缓存的空间大小。 5. Indexed DatabaseIndexedDB也是一种数据库的存储机制，但不同于已经不再支持的Web SQL Database。IndexedDB不是传统的关系数据库，可归为NoSQL数据库。IndexedDB又类似于Dom Storage的key-value的存储方式，但功能更强大，且存储空间更大。 IndexedDB存储数据是key-value的形式。Key是必需，且要唯一；Key可以自己定义，也可由系统自动生成。Value也是必需的，但Value非常灵活，可以是任何类型的对象。一般Value都是通过Key来存取的。 IndexedDB提供了一组API，可以进行数据存、取以及遍历。这些API都是异步的，操作的结果都是在回调中返回。 IndexedDB有个非常强大的功能，就是index（索引）。它可对Value对象中任何属性生成索引，然后可以基于索引进行Value对象的快速查询。 要生成索引或支持索引查询数据，需求在首次生成存储对象时，调用接口生成属性的索引。可以同时对对象的多个不同属性创建索引。如下面代码就对name和email两个属性都生成了索引。1234var objectStore = thisDB.createObjectStore(&quot;people&quot;,&#123; autoIncrement:true &#125;)//first arg is name of index, second is the path (col)objectStore.createIndex(&quot;name&quot;,&quot;name&quot;, &#123;unique:false&#125;)objectStore.createIndex(&quot;email&quot;,&quot;email&quot;, &#123;unique:true&#125;) 生成索引后，就可以基于索引进行数据的查询。Android在4.4开始加入对IndexedDB的支持，只需打开允许JS执行的开关就好了。 分析：IndexedDB是一种灵活且功能强大的数据存储机制，它集合了Dom Storage和Web SQL Database的优点，用于存储大块或复杂结构的数据，提供更大的存储空间，使用起来也比较简单。可以作为Web SQL Database的替代。不太适合静态文件的缓存。以key-value 的方式存取对象，可以是任何类型值或对象，包括二进制。可以对对象任何属性生成索引，方便查询。较大的存储空间，默认推荐250MB（分Host），比Dom Storage的5MB要大得多。通过数据库的事务（tranction）机制进行数据操作，保证数据一致性。异步的 API 调用，避免造成等待而影响体验。 6. File System APIFile System API是HTML5新加入的存储机制。它为Web App提供了一个虚拟的文件系统，就像Native App访问本地文件系统一样。由于安全性的考虑，这个虚拟文件系统有一定的限制。Web App在虚拟的文件系统中，可以进行文件（夹）的创建、读、写、删除、遍历等操作。 File System API也是一种可选的缓存机制，和前面的SQL Database、IndexedDB 和App Cache等一样。File System API有自己的一些特定的优势：123可以满足大块的二进制数据（large binary blobs）存储需求。可以通过预加载资源文件来提高性能。可以直接编辑文件。 浏览器给虚拟文件系统提供了两种类型的存储空间：临时的和持久性的。临时的存储空间是由浏览器自动分配的，但可能被浏览器回收；持久性的存储空间需要显示的申请，申请时浏览器会给用户一提示，需要用户进行确认。持久性的存储空间是Web App自己管理，浏览器不会回收，也不会清除内容。持久性的存储空间大小是通过配额来管理的，首次申请时会一个初始的配额，配额用完需要再次申请。 虚拟的文件系统是运行在沙盒中，不同Web App的虚拟文件系统是互相隔离的，虚拟文件系统与本地文件系统也是隔离的。 移动端Web加载性能（缓存）优化分析完HTML5提供的各种缓存机制，回到移动端（针对Android，可能也适用于iOS）的场景。现在Android App（包括手Q和WX）大多嵌入了Webview的组件（系统Webview或QQ浏览器的X5组件），通过内嵌Webview来加载一些HTML5的运营活动页面或资讯页。这样可充分发挥Web前端的优势：快速开发、发布，灵活上下线。但Webview也有一些不可忽视的问题，比较突出的就是加载相对较慢，会相对消耗较多流量。 通过对一些HTML5页面进行调试及抓包发现，每次加载一个HTML5页面，都会有较多的请求。除了HTML主URL自身的请求外，HTML外部引用的JS、CSS、字体文件、图片都是一个独立的HTTP请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化 Web的加载性能。 缓存机制 优势 适用场景 浏览器 HTTP协议层支持 静态文件缓存 Dom Storage 较大存储空间，简单 临时简单数据存储，Cookie扩展 Web SQL Database 存储复杂数据结构 不推荐，IndexDB替代 AppCache 构建离线App 不推荐，离线App，静态文件缓存 IndexDB 存储任何类型数据，索引 结构，关系复杂的数据结构 File System API 支持文件系统操作 数据适合以文件进行管理场景 结论：综合各种缓存机制比较，对于静态文件，如JS、CSS、字体、图片等，适合通过浏览器缓存机制来进行缓存，通过缓存文件可大幅提升Web的加载速度，且节省流量。但也有一些不足：缓存文件需要首次加载后才会产生；浏览器缓存的存储空间有限，缓存有被清除的可能；缓存的文件没有校验。要解决这些不足，可以参考手Q的离线包，它有效的解决了这些不足。 对于Web在本地或服务器获取的数据，可以通过Dom Storage和IndexedDB进行缓存。也在一定程度上减少和Server的交互，提高加载速度，同时节省流量。 @转载请注明出处原文链接：https://www.csdn.net/article/2015-12-16/2826489/1]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web缓存机制]]></title>
    <url>%2Fblog%2F2018%2F04%2F03%2FWeb%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。 web缓存的作用减少网络带宽消耗（当Web缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本）降低服务器压力（给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，减小服务器压力）减少网络延迟，加开页面打开速度 缓存机制是web开发的重要知识点，也是系统优化的重要方向。在前端开发中，缓存有利于加快网页的加载速度，同时缓存能够被反复利用，所以可以减少流量和带宽的开销。这里将系统的介绍在Web开发中的缓存方式，还会涉及到部分操作系统缓存知识。本文会重点介绍浏览器端的缓存机制也就是HTTP缓存，其机制是根据HTTP报文的缓存标识进行的。在分析缓存机制之前，先介绍下浏览器的HTTP报文。HTTP报文分为两种： HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)，如下图 HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体，如下图 注：通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。 Web开发中的不同缓存1. 数据库缓存 我们可能听说过memcached，它就是一种数据库层面的缓存方案。类似的还有Redis缓存，也是一种基于内存的数据库，它的功能更加强大，并且支持备份和数据持久化。数据库缓存是指，当web应用的关系比较复杂，数据库中的表很多的时候，如果频繁进行 数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。 2. CDN缓存（服务端缓存） CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能，可以归属为全局负载均衡或者说是四层负载均衡。通常情况下，浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，浏览器和服务器之间的缓存机制，在这种架构下同样适用。一般对于网站上的静态资源文件可以采用CDN分发，可以加快网站访问速度。 3. 代理服务器缓存（服务端缓存） 代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大，可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。也可以将其归为七层负载均衡，但需要两次TCP握手连接，然功能更多，如会话保持，图片压缩，防盗链等。 4. 浏览器缓存 每个浏览器都实现了 HTTP 缓存，我们通过浏览器使用HTTP协议与服务器交互的时候，浏览器就会根据一套与服务器约定的规则进行缓存工作。最新的HTML5协议新增了离线缓存属性，对缓存机制进一步的优化，可以达到，实现图片存在客户端，跨域共享客户端缓存，做到真正的离线访问WEB应用，实现客户端的数据库。 5. 应用层缓存 应用层缓存是指我们在代码层面上做的缓存。通过代码逻辑，把曾经请求过的数据或资源等，缓存起来，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率，再次需要数据时通过逻辑上的处理选择可用的缓存的数据。h5新增的storage就可以归属到应用层缓存。 操作系统缓存首先关于存储的概念有以下几种方式：cache：缓存为了让从DB/磁盘拿出来的东西放到缓存（放于内存）；磁盘文件：本地存储的视频，图片，计算机里面的文件；数据库：系统项目中的数据存储；内存：计算机中所有的程序运行都是在内存中，所以内存对计算机的性能影响很大。在操作系统缓存机制中，有buffer和cache两种方式，它们都是占用内存（buffer记录元数据，权限属性等，cache缓存文件）。I/O过程本身的延迟，以及高速设备与低速设备交互时的等待延迟，Buffer和Cache就是从这两个方向上产生的优化提高系统性能的方式。 buffer缓存是块设备的读写缓冲区，buffer是I/O缓存，用于内存和硬盘（或其他 I/O设备）之间的数据交换的速度而设计的。通常在写一个非常大的文件，文件会被分成一个个的小block块，往内存上写，然后再写入磁盘,这样的效率会很慢。这种情况下，内存就会攒足一次大的block块再写入磁盘，这样就不会有第一种情况里的延迟，这就是buffer。buffer的主要目的是进行流量整形，把突发的大数量较小规模读写整理成平稳的较大规模的I/O，以减少响应次数（比如从网上下载视频，不能下一点点数据就写入硬盘，而是达到一定量的数据一整块写，不然硬盘负荷太大）。 Cache缓存是高速缓存，用于cpu与内存之间的缓冲，是系统两端处理速度不匹配时的一种折衷策略。主要原因是cpu与memory，由于cpu快，memory跟不上，且有些值使用次数多，所以放入cache中，主要目的是使用内存来缓存可能被再次访问的数据，可以保持冗余的、被重复计算的、计算后的数据（buffer不行）。Cache是经常被使用在I/O请求上，来提高系统性能。如果cache的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO必会非常小。 Web中浏览器缓存浏览器端的缓存分为强缓存（Expires和Cache-Control—优先级高，直接使用本地缓存资源）和协商缓存（Last-Modified / If-Modified-Since和 Etag / If-None-Match—优先级高，先发送请求到服务器端确认资源更改来确认是否使用缓存）。 1. 强缓存在HTTP/1.0使用的是Expires字段，该字段表示缓存到期时间，即有效时间+当时服务器的时间，然后将这个时间设置在header中返回给服务器。如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。该时间是一个绝对时间，由于服务端和浏览器端时间不一致，或者用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，因此更推荐另一种强缓存方式。Expires字段如下：1Expires: Thu, 15 Mar 2018 09:09:09 GMT 在HTTP/1.1中，增加了一个字段Cache-Control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求，主要是利用该字段的max-age值来进行判断，它是一个相对值，资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则资源失效。1Cache-Control: max-age=9590000 Cache-Control除了max-age字段外，还有几个比较常用的字段设置值： no-cache：不用本地缓存，使用协商缓存，先发送请求到服务器根据响应确认资源是否被更改，如果之前的响应中存在ETag或者Last-Modified，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 注意：如果cache-control与expires同时存在的话，cache-control的优先级高于expires 2. 协商缓存协商缓存（Last-Modified或者Etag）的过程是先从缓存中获取对应的数据标识，然后向服务器发送请求，确认数据是否更新，如果更新，则返回新数据和新缓存。反之，则返回304状态码，告知客户端缓存未更新，可继续使用，这正好弥补了一些强缓存的缺陷，协商缓存主要应用于一些时常需要动态更新的资源文件。协商缓存在协议里的字段是Last-Modified或者Etag，这两个字段都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。 Last-Modified/If-Modified-Since具体过程： 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header浏览器收到304的响应后，就会从缓存中加载资源如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值 Etag/If-None-Match Etag字段值是由服务器生成的每个资源的唯一标识字符串（一般都是hash生成的），只要资源内容有变化这个值就会改变,其判断过程与Last-Modified类似，与它不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，响应头还会把这个ETag返回，即使这个ETag跟之前的没有变化。 Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，之所以在HTTP1.1中新增Etag主要为了解决几个Last-Modified的问题： 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；某些服务器不能精确的得到文件的最后修改时间。这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。 注意：Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。 用户浏览器行为对缓存的影响刷新网页 =&gt; 如果缓存没有失效，浏览器会直接使用缓存；反之，则向服务器请求数据手动刷新（F5） =&gt; 浏览器会认为缓存失效，在请求服务器时加上Cache-Control: max-age=0字段，然后询问服务器数据是否更新。强制刷新（Ctrl + F5） =&gt; 浏览器会直接忽略缓存，在请求服务器时加上Cache-Control: no-cache字段，然后重新向服务器拉取文件。更多用户行为可以用如下表格进行表示： 用户行为 Expires / Cache-Control Last-Modified / Etag 地址栏回车 有效 有效 页面链接跳转 有效 有效 新窗口 有效 有效 前进后退 有效 有效 F5刷新 无效 有效 Ctrl+F5刷新 无效 无效 移动端的缓存处理Cache-Control和Last-Modified一般用在静态资源文件上，如JS、CSS和一些图像文件。通过设置资源文件缓存属性，对提高资源文件加载速度，节省流量很有意义，特别是移动网络环境。但问题是：缓存有效时长应该如何设置，如果太短，就起不到缓存的使用，设置的太长，在服务端资源文件有更新时，浏览器有缓存，则不能及时取到最新的文件。 对于移动端的缓存，任何一个网络请求的增加，加载消耗时间都是比较大的（尤其弱网环境下）。对于强缓存只要缓存不到期，是不会向服务器发送请求，但是如果是协商缓存的情况下，304的问题就比较大，它会造成无用的服务器请求，导致网络的延时。Last-Modified需要向服务器发起查询请求，才能知道资源文件有没有更新，虽然服务器可能返回304告诉没有更新，但也还有一个请求的过程。对于移动网络，这个请求可能是比较耗时的，有一种说法叫“消灭304”，指的就是优化掉304的请求。 通过抓包可以发现，带if-Modified-Since字段的请求，如果服务器回包304，回包会带有Cache-Control:max-age或Expires字段，文件的强缓存有效时间会更新，就是文件强缓存会重新有效。304回包后如果再请求，则又可以直接使用本地缓存文件了，不用再向服务器发送请求查询文件是否更新了，除非新的强缓存资源文件时间再次过期。 另外，Cache-Control与Last-Modified是浏览器内核的机制，一般都是标准的实现，不能更改或设置。以QQ浏览器的X5为例，Cache-Control与Last-Modified缓存不能禁用，缓存容量是12MB，不分Host，过期的缓存会最先被清除。如果都没过期，应该优先清最早的缓存或最快到期的或文件大小最大的，过期缓存也有可能还是有效的，清除缓存会导致资源文件的重新拉取。还有，浏览器，如X5，在使用缓存文件时，是没有对缓存文件内容进行校验的，这样缓存文件内容被修改的可能。 分析发现，浏览器的缓存机制还不是非常完美的缓存机制。完美的缓存机制应该是这样的： 缓存文件没更新，尽可能使用缓存，不用和服务器交互；缓存文件有更新时，第一时间能使用到新的文件；缓存的文件要保持完整性，不使用被修改过的缓存文件；缓存的容量大小要能设置或控制，缓存文件不能因为存储空间限制或过期被清除。 以X5为例，第1、2条不能同时满足，第3、4条都不能满足。 在实际应用中，为了解决Cache-Control缓存时长不好设置的问题，以及为了“消灭304”，采用的方式是： 1. 在要缓存的资源文件名中加上版本号或文件MD5值字串，如common.d5d02a02.js、common.v1.js，同时设置Cache-Control:max-age=31536000，也就是一年。在一年时间内，资源文件如果本地有缓存，就会使用缓存,这样就可以避免协商缓存的304的回包现象。2. 如果资源文件有修改，则更新文件内容，同时修改资源文件名，如common.v2.js，html页面也会引用新的资源文件名，实现静态资源非覆盖式更新。通过这种方式，实现了：缓存文件没有更新，则使用缓存；缓存文件有更新，则第一时间使用最新文件的目的。即上面说的第1、2条。第3、4条由于浏览器内部机制，目前还无法满足。 浏览器缓存回忆浏览器端强缓存优于协商缓存进行，先判断强缓存资源是否过期，若强缓存（Expires和Cache-Control）生效则直接使用本地浏览器缓存，若失效则进行协商缓存（Last-Modified / If-Modified-Since和 Etag / If-None-Match）发送请求到服务端，协商缓存由服务器响应和本地进行对比验证决定资源是否有效，若协商缓存失效，那么代表该请求的缓存失效，择重新发送请求获取响应结果下载资源，再存入浏览器缓存中，生效则返回304状态码，继续使用缓存，整个浏览器缓存主要过程如下图： @转载请注明出处]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo迁移]]></title>
    <url>%2Fblog%2F2018%2F03%2F21%2Fhexo%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[操作步骤一、安装必要软件12安装 Git 客户端安装 node JS 二、在 github 官网添加新电脑产生的密钥三、源文件拷贝将原来电脑上个人博客目录下必要文件拷贝到新电脑上（比如D:/Blog目录下），注意无需拷贝全部，只拷如下几个文件：12345_config.ymlpackage.jsonscaffolds/source/themes/ 四、安装 hexo1在 cmd 下输入指令安装 hexo：npm install hexo-cli -g 五、进入 D:/Blog 目录（拷贝到新电脑的目录），安装相关模块1234npm installnpm install hexo-deployer-git --save // 文章部署到 git 的模块npm install hexo-generator-feed --save // 建立 RSS 订阅（选择安装）npm install hexo-generator-sitemap --save // 建立站点地图（选择安装） 六、部署发布文章123hexo clean // 清除缓存 网页正常情况下可以忽略此条命令hexo g // 生成静态网页hexo d // 开始部署 第二种方法具体的思路是：在生成的已经推到github上的hexo静态代码出建立一个分支，利用这个分支来管理自己hexo的源文件。如果能在刚刚配置hexo的时候就想好以后的迁移的问题就太好了，可以省掉很多麻烦。 具体的操作：克隆gitHub上面生成的静态文件到本地1git clone https://github.com/yourname/hexo-test.github.io.git 把克隆到本地的文件除了git的文件都删掉，找不到git的文件的话就到删了吧。不要用hexo init初始化。 将之前使用hexo写博客时候的整个目录（所有文件）搬过来。把该忽略的文件忽略了1touch .gitignore 创建一个叫hexo的分支1git checkout -b hexo 提交复制过来的文件到暂存区1git add --all 提交1git commit -m &quot;新建分支源文件&quot; 推送分支到github1git push --set-upstream origin hexo 到这里基本上就搞定了，以后再推就可以直接git push了，hexo的操作跟以前一样。 今后无论什么时候想要在其他电脑上面用hexo写博客，就直接把创建的分支克隆下来，npm install安装依赖之后就可以用了。 克隆分支的操作1git clone -b hexo https://github.com/yourname/hexo-test.github.io.git 因为上面创建的是一个名字叫hexo的分支，所以这里-b后面的是hexo，再把后面的gitHub的地址换成你自己的hexo博客的地址就可以了。 这样完了以后，每次写完博客发布之后不要忘了还要git push把源文件推到分支上。 原文链接：https://blog.csdn.net/lvonve/article/details/79587321原文链接：https://www.jianshu.com/p/beb8d611340a]]></content>
      <categories>
        <category>实践教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2Fblog%2F2018%2F01%2F13%2Fhexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
