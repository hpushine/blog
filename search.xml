<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>git简要教程</title>
      <link href="/blog/2018/04/23/git%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B/"/>
      <url>/blog/2018/04/23/git%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h3><p>Git的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure></p><h3 id="一、-创建与合并分支"><a href="#一、-创建与合并分支" class="headerlink" title="一、 创建与合并分支"></a>一、 创建与合并分支</h3><p>1、 从master分支创建dev分支并切换到dev分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure></p><p>其中，git checkout -b dev 等价于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br><span class="line"></span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure></p><p>查看本地当前的分支，分支前面带“*”表示当前分支，剩下的分支表示本地有的分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><p>查看远程全部的分支，白色的表示本地有的，红色的表示本地没有，仅在远程存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure></p><p>2、修改代码、提交代码（当前的操作是在dev分支上进行）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add a.html</span><br><span class="line"></span><br><span class="line">git commit -m &quot;提交文件a.html&quot;</span><br></pre></td></tr></table></figure></p><p>3、分支合并(将dev合并到master)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line"></span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure></p><p>4、合并完成后，删除dev分支.(删除dev分支时，注意我们当前所在的分支不能是dev分支)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure></p><p>5、删除后，查看分支(此时看不到dev分支了)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><p>6、总结 ：工作中经常从master创建新的分支，具体操作如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">master创建新分支：</span><br><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">git checkout -b  issues1234</span><br><span class="line"></span><br><span class="line">git push origin issues1234</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m &quot;***&quot;</span><br><span class="line"></span><br><span class="line">git push origin issues1234</span><br></pre></td></tr></table></figure></p><p>注意：将本地分支branch1推到远端的branch2操作步骤：git push origin branch1:branch2</p><p>7、删除分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -D   issues1234  //本地强制删除分支issues1234</span><br><span class="line"></span><br><span class="line">git push origin  :issues1234  //推到远程</span><br></pre></td></tr></table></figure></p><h3 id="二、-解决冲突"><a href="#二、-解决冲突" class="headerlink" title="二、 解决冲突"></a>二、 解决冲突</h3><p>1、发生冲突的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure></p><p>其中，git使用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记文件中自己和别人产生冲突的部分。</p><p>在&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======之间为自己的代码；<br>=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间为别人的代码。</p><p>如果保留自己的代码，将别人的代码删掉即可。</p><p>2、冲突解决后提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add ***</span><br><span class="line"></span><br><span class="line">git commit -m &quot;fix conflict&quot;</span><br><span class="line"></span><br><span class="line">git push origin 分支名</span><br></pre></td></tr></table></figure></p><h3 id="三、Bug分支"><a href="#三、Bug分支" class="headerlink" title="三、Bug分支"></a>三、Bug分支</h3><p>1、储藏更改:将当前更改的代码储藏起来，等以后恢复使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></p><p>2、恢复储藏的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git stash pop //恢复的同时把stash内容删掉</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">git stash apply  //恢复stash，但是stash内容并不删除</span><br><span class="line"></span><br><span class="line">git stash drop //在上面操作的基础上，以此来删除stash</span><br><span class="line"></span><br><span class="line">注： git stash list //查看全部的stash列表</span><br></pre></td></tr></table></figure></p><p>3、将stash空间清空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure></p><p>4、git stash pop 和 git stash apply 区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原来git stash pop stash@&#123;id&#125;命令会在执行后将对应的stash id 从stash list里删除</span><br><span class="line"></span><br><span class="line">而 git stash apply stash@&#123;id&#125; 命令则会继续保存stash id。</span><br></pre></td></tr></table></figure></p><h3 id="四、版本回退"><a href="#四、版本回退" class="headerlink" title="四、版本回退"></a>四、版本回退</h3><p>1、回退至上一个版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure></p><p>2、回退至指定版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard  版本号</span><br></pre></td></tr></table></figure></p><p>3、查看以往版本号(本地的commit)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></p><p>4、查看各版本号及信息(所有的commit：本地commit + 其他同事的commit)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></p><h3 id="五、撤销修改"><a href="#五、撤销修改" class="headerlink" title="五、撤销修改"></a>五、撤销修改</h3><p>1、撤销修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  checkout -- a.html</span><br></pre></td></tr></table></figure></p><p>分两种情况分析：<br>①： 还没有执行 git add 操作，执行上面的操作后，会恢复到和版本库中一模一样的版本状态。</p><p>②： 执行了git add ，还没执行 git commit ,再执行上面的操作后，会恢复到git add 结束后的状态</p><p>注：一旦执行了git commit -m “*”，就不能再使用上面的命令回退。</p><p>2、撤销新建文件</p><p>比如新建一个aa.html页面，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -f ../aa.html</span><br></pre></td></tr></table></figure></p><p>3、撤销新建文件夹</p><p>比如新建一个文件夹”demo”，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -df ./demo</span><br></pre></td></tr></table></figure></p><h3 id="六、对于已经push的版本，进行回退"><a href="#六、对于已经push的版本，进行回退" class="headerlink" title="六、对于已经push的版本，进行回退"></a>六、对于已经push的版本，进行回退</h3><p>1、第一步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号 //本地回退到指定的版本</span><br></pre></td></tr></table></figure></p><p>2、第二步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push  -f origin dev    //将远程的也回退到指定版本</span><br></pre></td></tr></table></figure></p><h3 id="七、本地同步远程删除的分支"><a href="#七、本地同步远程删除的分支" class="headerlink" title="七、本地同步远程删除的分支"></a>七、本地同步远程删除的分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin -p  //用来清除已经没有远程信息的分支</span><br><span class="line"></span><br><span class="line">这样git branch -a 就不会拉取远程已经删除的分支了</span><br></pre></td></tr></table></figure><h3 id="八、删除掉没有与远程分支对应的本地分支"><a href="#八、删除掉没有与远程分支对应的本地分支" class="headerlink" title="八、删除掉没有与远程分支对应的本地分支"></a>八、删除掉没有与远程分支对应的本地分支</h3><p>从gitlab上看不到的分支在本地可以通过git branch -a 查到，删掉没有与远程分支对应的本地分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch -p</span><br></pre></td></tr></table></figure></p><h3 id="九、查看远程库的一些信息，及与本地分支的信息"><a href="#九、查看远程库的一些信息，及与本地分支的信息" class="headerlink" title="九、查看远程库的一些信息，及与本地分支的信息"></a>九、查看远程库的一些信息，及与本地分支的信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin</span><br></pre></td></tr></table></figure><h3 id="Git命令清单"><a href="#Git命令清单" class="headerlink" title="Git命令清单"></a>Git命令清单</h3><h3 id="增加删除文件"><a href="#增加删除文件" class="headerlink" title="增加删除文件"></a>增加删除文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h3 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h3 id="标签命令"><a href="#标签命令" class="headerlink" title="标签命令"></a>标签命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><p> 参考链接：<a href="https://segmentfault.com/a/1190000014461898" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014461898</a><br> 参考链接：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>移动端H5缓存</title>
      <link href="/blog/2018/04/20/%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E7%BC%93%E5%AD%98/"/>
      <url>/blog/2018/04/20/%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<p>HTML5是新一代的HTML标准，加入很多新的特性。离线存储（亦称为缓存机制）是其中一个非常重要的特性。HTML5引入了离线存储，这意味着移动Web应用可进行缓存，并可在没有Internet连接时离线进行访问。<br>HTML5应用程序缓存为应用带来三个优势：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">离线浏览：用户可在应用离线时使用它们；</span><br><span class="line">速度：已缓存资源加载得更快；</span><br><span class="line">减少服务器负载：浏览器将只从服务器下载更新过或更改过的资源。</span><br></pre></td></tr></table></figure></p><p>根据标准，到目前为止，H5共有6种缓存机制，有些是之前已有，有些是H5才新加入的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">浏览器缓存机制</span><br><span class="line">Dom Storgage（Web Storage）存储机制</span><br><span class="line">Web SQL Database存储机制（不推荐）</span><br><span class="line">Application Cache（AppCache）机制</span><br><span class="line">Indexed Database （IndexedDB）</span><br><span class="line">File System API</span><br></pre></td></tr></table></figure></p><p>下面分析各种缓存机制的原理、用法及特点；然后针对Android移动端Web性能加载优化的需求，看如何适当利用缓存机制来提高Web的加载性能。</p><h3 id="1-浏览器缓存机制"><a href="#1-浏览器缓存机制" class="headerlink" title="1. 浏览器缓存机制"></a>1. 浏览器缓存机制</h3><p>浏览器缓存机制是指通过HTTP协议头里的Cache-Control（或Expires）和Last-Modified（或Etag）等字段来控制文件缓存的机制。这应该是Web中最早的缓存机制了，是在HTTP协议中实现的，有点不同于Dom Storage、AppCache等缓存机制，但本质上是一样的，可以理解为一个是协议层实现的，一个是应用层实现的。</p><p>Cache-Control和Last-Modified一般用在静态资源文件上，如JS、CSS和一些图像文件。通过设置资源文件缓存属性，对提高资源文件加载速度，节省流量很有意义，特别是移动网络环境。但问题是：缓存有效时长应该如何设置，如果太短，就起不到缓存的使用，设置的太长，在服务端资源文件有更新时，浏览器有缓存，则不能及时取到最新的文件。</p><p>对于移动端的缓存，任何一个网络请求的增加，加载消耗时间都是比较大的（尤其弱网环境下）。对于强缓存只要缓存不到期，是不会向服务器发送请求，但是如果是协商缓存的情况下，304的问题就比较大，它会造成无用的服务器请求，导致网络的延时。Last-Modified需要向服务器发起查询请求，才能知道资源文件有没有更新，虽然服务器可能返回304告诉没有更新，但也还有一个请求的过程。对于移动网络，这个请求可能是比较耗时的，有一种说法叫“消灭304”，指的就是优化掉304的请求。</p><p>通过抓包可以发现，带if-Modified-Since字段的请求，如果服务器回包304，回包会带有Cache-Control:max-age或Expires字段，文件的强缓存有效时间会更新，就是文件强缓存会重新有效。304回包后如果再请求，则又可以直接使用本地缓存文件了，不用再向服务器发送请求查询文件是否更新了，除非新的强缓存资源文件时间再次过期。</p><p>另外，Cache-Control与Last-Modified是浏览器内核的机制，一般都是标准的实现，不能更改或设置。以QQ浏览器的X5为例，Cache-Control与Last-Modified缓存不能禁用，缓存容量是12MB，不分Host，过期的缓存会最先被清除。如果都没过期，应该优先清最早的缓存或最快到期的或文件大小最大的，过期缓存也有可能还是有效的，清除缓存会导致资源文件的重新拉取。还有，浏览器，如X5，在使用缓存文件时，是没有对缓存文件内容进行校验的，这样缓存文件内容被修改的可能。</p><p>分析发现，浏览器的缓存机制还不是非常完美的缓存机制。完美的缓存机制应该是这样的：</p><blockquote>缓存文件没更新，尽可能使用缓存，不用和服务器交互；<br>缓存文件有更新时，第一时间能使用到新的文件；<br>缓存的文件要保持完整性，不使用被修改过的缓存文件；<br>缓存的容量大小要能设置或控制，缓存文件不能因为存储空间限制或过期被清除。 以X5为例，第1、2条不能同时满足，第3、4条都不能满足。</blockquote><p>在实际应用中，为了解决Cache-Control缓存时长不好设置的问题，以及为了“消灭304”，采用的方式是：</p><blockquote>1. 在要缓存的资源文件名中加上版本号或文件MD5值字串，如common.d5d02a02.js、common.v1.js，同时设置Cache-Control:max-age=31536000，也就是一年。在一年时间内，资源文件如果本地有缓存，就会使用缓存,这样就可以避免协商缓存的304的回包现象。<br>2. 如果资源文件有修改，则更新文件内容，同时修改资源文件名，如common.v2.js，html页面也会引用新的资源文件名，实现静态资源非覆盖式更新。<br><br>通过这种方式，实现了：缓存文件没有更新，则使用缓存；缓存文件有更新，则第一时间使用最新文件的目的。即上面说的第1、2条。第3、4条由于浏览器内部机制，目前还无法满足。</blockquote><h3 id="2-Dom-Storage（Web-Storage）存储机制"><a href="#2-Dom-Storage（Web-Storage）存储机制" class="headerlink" title="2. Dom Storage（Web Storage）存储机制"></a>2. Dom Storage（Web Storage）存储机制</h3><p>DOM存储是一套在Web Applications 1.0规范中首次引入的与存储相关的特性的总称，现在已经分离出来，单独发展成为独立的W3C Web存储规范。DOM存储被设计为用来提供一个更大存储量、更安全、更便捷的存储方法，从而可以代替掉将一些不需要让服务器知道的信息存储到Cookies里的这种传统方法。这是对Dom Storage存储机制的官方表述。</p><p>Dom Storage是通过存储字符串的Key/Value对来提供的，并提供5MB（不同浏览器可能不同，分Host）的存储空间（Cookies才4KB)。另外Dom Storage存储的数据在本地，不像 Cookies，每次请求一次页面，Cookies 都会发送给服务器。</p><p>DOM Storage分为sessionStorage和localStorage。localStorage对象和sessionStorage对象使用方法基本相同，它们的区别在于作用的范围不同。sessionStorage用来存储与页面相关的数据，它在页面关闭后无法使用。而localStorage则持久存在，在页面关闭后也可以使用。</p><p>sessionStorage是个全局对象，它维护着在页面会话（page session）期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入（reload）或者被恢复（restores）时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。</p><p>当浏览器被意外刷新的时候，一些临时数据应当被保存和恢复。sessionStorage对象在处理这种情况的时候是最有用的，比如恢复我们在表单中已经填写的数据。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"> // 当页面刷新时，从sessionStorage恢复之前输入的内容</span><br><span class="line"> window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> (window.sessionStorage) &#123;</span><br><span class="line">        var name = window.sessionStorage.getItem(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="string">""</span> || name != null)&#123;</span><br><span class="line">            document.getElementById(<span class="string">"name"</span>).value = name;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> // 将数据保存到sessionStorage对象中</span><br><span class="line"> <span class="keyword">function</span> <span class="function"><span class="title">saveToStorage</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (window.sessionStorage) &#123;</span><br><span class="line">        var name = document.getElementById(<span class="string">"name"</span>).value;</span><br><span class="line">        window.sessionStorage.setItem(<span class="string">"name"</span>, name);</span><br><span class="line">        window.location.href=<span class="string">"session_storage.html"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">&lt;form action=<span class="string">"./session_storage.html"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span> id=<span class="string">"name"</span>/&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"Save"</span> onclick=<span class="string">"saveToStorage()"</span>/&gt;</span><br><span class="line">&lt;/form&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure></p><p>把上面的代码复制到session_storage.html（也可以从附件中直接下载）页面中，用Google Chrome浏览器的不同Page或Window打开，在输入框中分别输入不同的文字，再点击“Save”，然后分别刷新。每个Page或Window显示都是当前Page输入的内容，互不影响。关闭Page，再重新打开，上一次输入保存的内容已经没有了。</p><p>Local Storage的接口、用法与Session Storage一样，唯一不同的是：Local Storage保存的数据是持久性的。当前Page关闭（Page Session结束后），保存的数据依然存在。重新打开Page，上次保存的数据可以获取到。另外，Local Storage是全局性的，同时打开两个Page会共享一份存数据，在一个Page中修改数据，另一个Page中是可以感知到的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 通过localStorage直接引用key, 另一种写法，等价于：</span><br><span class="line">  // localStorage.getItem(&quot;pageLoadCount&quot;);</span><br><span class="line">  // localStorage.setItem(&quot;pageLoadCount&quot;, value);</span><br><span class="line">  if (!localStorage.pageLoadCount) &#123;</span><br><span class="line">     localStorage.pageLoadCount = 0;</span><br><span class="line">     localStorage.pageLoadCount = parseInt(localStorage.pageLoadCount) + 1;</span><br><span class="line">     document.getElementById(&apos;count&apos;).textContent = localStorage.pageLoadCount;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    You have viewed this page</span><br><span class="line">    &lt;span id=&quot;count&quot;&gt;an untold number of&lt;/span&gt;</span><br><span class="line">    time(s)</span><br><span class="line">&lt;/p&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure></p><p>将上面代码复制到local_storage.html的页面中，用浏览器打开，pageLoadCount的值是1；关闭Page重新打开，pageLoadCount的值是2。这是因为第一次的值已经保存了。用两个Page同时打开local_storage.html，并分别交替刷新，发现两个Page是共享一个pageLoadCount的。</p><p>分析：Dom Storage给Web提供了一种更录活的数据存储方式，存储空间更大（相对Cookies），用法也比较简单，方便存储服务器或本地的一些临时数据。</p><p>从Dom Storage提供的接口来看，Dom Storage适合存储比较简单的数据，如果要存储结构化的数据，可能要借助JSON了，将要存储的对象转为JSON字串。不太适合存储比较复杂或存储空间要求比较大的数据，也不适合存储静态的文件等。</p><p>在Android内嵌Webview中，需要通过Webview设置接口启用Dom Storage。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">WebSettings webSettings = myWebView.getSettings();</span><br><span class="line">webSettings.setDomStorageEnabled(true);&lt;br&gt;</span><br></pre></td></tr></table></figure></p><p>拿Android类比的话，Web的Dom Storage机制类似于Android的SharedPreference机制。</p><h3 id="3-Web-SQL-Database存储机制"><a href="#3-Web-SQL-Database存储机制" class="headerlink" title="3. Web SQL Database存储机制"></a>3. Web SQL Database存储机制</h3><p>HTML5也提供基于SQL的数据库存储机制，用于存储适合数据库的结构化数据。但根据官方的标准文档，这种存储机制不再推荐使用，将来也不再维护，而是推荐使用AppCache和IndexedDB，所以这里就不多做阐述了。</p><h3 id="4-Application-Cache机制"><a href="#4-Application-Cache机制" class="headerlink" title="4. Application Cache机制"></a>4. Application Cache机制</h3><p>Application Cache（简称AppCache）似乎是为支持Web App离线使用而开发的缓存机制。它的缓存机制类似于浏览器的缓存（Cache-Control和Last-Modified）机制，都是以文件为单位进行缓存，且文件有一定更新机制。但AppCache是对浏览器缓存机制的补充，不是替代。先拿W3C官方的一个例子，说下AppCache机制的用法与功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html manifest=<span class="string">"demo_html.appcache"</span>&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=<span class="string">"demo_time.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;p id=<span class="string">"timePara"</span>&gt;&lt;button onclick=<span class="string">"getDateTime()"</span>&gt;Get Date and Time&lt;/button&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;img src=<span class="string">"img_logo.gif"</span> width=<span class="string">"336"</span> height=<span class="string">"69"</span>&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        Try opening </span><br><span class="line">        &lt;a href=<span class="string">"tryhtml5_html_manifest.htm"</span> target=<span class="string">"_blank"</span>&gt;</span><br><span class="line">        this page&lt;/a&gt;</span><br><span class="line">        , <span class="keyword">then</span> go offline, and reload the page. </span><br><span class="line">        The script and the image should still work.</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>上面HTML文档，引用外部一个JS文件和一个GIF图片文件，在其HTML头中通过manifest属性引用了一个appcache结尾的文件。</p><p>我们在Google Chrome浏览器中打开这个HTML链接，JS功能正常，图片也显示正常。禁用网络，关闭浏览器重新打开这个链接，发现JS工作正常，图片也显示正常。当然也有可能是浏览缓存起的作用，我们可以在文件的浏览器缓存过期后，禁用网络再试，发现HTML页面也是正常的。</p><p>通过Google Chrome浏览器自带的工具，我们可以查看已经缓存的AppCache（分Host）。<br><img src="http://jingchao.xyz/blog/images/appcache.jpg" alt=""></p><p>上面截图中的缓存，就是我们刚才打开HTML的页面AppCache。从截图中看，HTML页面及HTML引用的JS、GIF图像文件都被缓存了；另外HTML头中manifest属性引用的appcache文件也缓存了。</p><p>AppCache的原理有两个关键点：manifest属性和manifest文件。</p><p>HTML在头中通过manifest属性引用manifest文件。manifest文件，就是上面以appcache结尾的文件，是一个普通文件文件，列出了需要缓存的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">demo.js</span><br><span class="line">img.gif</span><br></pre></td></tr></table></figure></p><p>上面截图中的manifest文件，就HTML代码引用的manifest文件。文件比较简单，第一行是关键字，第二、三行就是要缓存的文件路径（相对路径）。这只是最简单的manifest文件，完整的还包括其他关键字与内容。引用manifest文件的HTML和manifest文件中列出的要缓存的文件最终都会被浏览器缓存。</p><p>完整的manifest文件，包括三个Section，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 2012-02-21 v1.0.0</span><br><span class="line">/theme.css</span><br><span class="line">/logo.gif</span><br><span class="line">/main.js</span><br><span class="line">NETWORK:</span><br><span class="line">login.asp</span><br><span class="line">FALLBACK:</span><br><span class="line">/html/ /offline.html</span><br></pre></td></tr></table></figure></p><p>总的来说，浏览器在首次加载HTML文件时，会解析manifest属性，并读取manifest文件，获取CACHE MANIFEST下要缓存的文件列表，再对文件缓存。</p><p>AppCache的缓存文件，与浏览器的缓存文件分开存储的，还是一份？应该是分开的。因为AppCache在本地也有5MB（分Host）的空间限制。</p><p>AppCache在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新manifest文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查manifest文件有没有修改（byte by byte)，发现有修改，就会重新获取manifest文件，对CACHE MANIFEST下文件列表检查更新。manifest文件与缓存文件的检查更新也遵守浏览器缓存机制。</p><p>如用用户手动清了AppCache缓存，下次加载时，浏览器会重新生成缓存，也可算是一种缓存的更新。另外，Web App也可用代码实现缓存更新。</p><blockquote><br>分析：AppCache看起来是一种比较好的缓存方法，除了缓存静态资源文件外，也适合构建Web离线 App。在实际使用中有些需要注意的地方，有一些可以说是”坑“。<br>    1. 要更新缓存的文件，需要更新包含它的manifest文件，那怕只加一个空格。常用的方法，是修改manifest文件注释中的版本号。如：# 2012-02-21 v1.0.0。<br>    2.被缓存的文件，浏览器是先使用，再通过检查manifest文件是否有更新来更新缓存文件。这样缓存文件可能用的不是最新的版本。<br>    3. 在更新缓存过程中，如果有一个文件更新失败，则整个更新会失败。<br>    4. manifest和引用它的HTML要在相同Host。<br>    5. manifest文件中的文件列表，如果是相对路径，则是相对manifest文件的相对路径。<br>    6. manifest也有可能更新出错，导致缓存文件更新失败。<br>    7. 没有缓存的资源在已经缓存的HTML中不能加载，即使有网络。例如：<a href="http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-network/。" target="_blank" rel="noopener">http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-network/。</a><br>    8. manifest文件本身不能被缓存，且manifest文件的更新使用的是浏览器缓存机制。所以manifest文件的Cache-Control缓存时间不能设置太长。<br>另外，根据官方文档，AppCache已经不推荐使用了，标准也不会再支持。现在主流的浏览器都是还支持AppCache的，以后就不太确定了。</blockquote><p>在Android内嵌Webview中，需要通过Webview设置接口启用AppCache，同时还要设置缓存文件的存储路径，另外还可以设置缓存的空间大小。</p><h3 id="5-Indexed-Database"><a href="#5-Indexed-Database" class="headerlink" title="5. Indexed Database"></a>5. Indexed Database</h3><p>IndexedDB也是一种数据库的存储机制，但不同于已经不再支持的Web SQL Database。IndexedDB不是传统的关系数据库，可归为NoSQL数据库。IndexedDB又类似于Dom Storage的key-value的存储方式，但功能更强大，且存储空间更大。</p><p>IndexedDB存储数据是key-value的形式。Key是必需，且要唯一；Key可以自己定义，也可由系统自动生成。Value也是必需的，但Value非常灵活，可以是任何类型的对象。一般Value都是通过Key来存取的。</p><p>IndexedDB提供了一组API，可以进行数据存、取以及遍历。这些API都是异步的，操作的结果都是在回调中返回。</p><p>IndexedDB有个非常强大的功能，就是index（索引）。它可对Value对象中任何属性生成索引，然后可以基于索引进行Value对象的快速查询。</p><p>要生成索引或支持索引查询数据，需求在首次生成存储对象时，调用接口生成属性的索引。可以同时对对象的多个不同属性创建索引。如下面代码就对name和email两个属性都生成了索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var objectStore = thisDB.createObjectStore(&quot;people&quot;,&#123; autoIncrement:true &#125;)</span><br><span class="line">//first arg is name of index, second is the path (col)</span><br><span class="line">objectStore.createIndex(&quot;name&quot;,&quot;name&quot;, &#123;unique:false&#125;)</span><br><span class="line">objectStore.createIndex(&quot;email&quot;,&quot;email&quot;, &#123;unique:true&#125;)</span><br></pre></td></tr></table></figure></p><p>生成索引后，就可以基于索引进行数据的查询。Android在4.4开始加入对IndexedDB的支持，只需打开允许JS执行的开关就好了。</p><blockquote>分析：IndexedDB是一种灵活且功能强大的数据存储机制，它集合了Dom Storage和Web SQL Database的优点，用于存储大块或复杂结构的数据，提供更大的存储空间，使用起来也比较简单。可以作为Web SQL Database的替代。不太适合静态文件的缓存。<br>以key-value 的方式存取对象，可以是任何类型值或对象，包括二进制。<br>可以对对象任何属性生成索引，方便查询。<br>较大的存储空间，默认推荐250MB（分Host），比Dom Storage的5MB要大得多。<br>通过数据库的事务（tranction）机制进行数据操作，保证数据一致性。<br>异步的 API 调用，避免造成等待而影响体验。</blockquote><h3 id="6-File-System-API"><a href="#6-File-System-API" class="headerlink" title="6. File System API"></a>6. File System API</h3><p>File System API是HTML5新加入的存储机制。它为Web App提供了一个虚拟的文件系统，就像Native App访问本地文件系统一样。由于安全性的考虑，这个虚拟文件系统有一定的限制。Web App在虚拟的文件系统中，可以进行文件（夹）的创建、读、写、删除、遍历等操作。</p><p>File System API也是一种可选的缓存机制，和前面的SQL Database、IndexedDB 和App Cache等一样。File System API有自己的一些特定的优势：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以满足大块的二进制数据（large binary blobs）存储需求。</span><br><span class="line">可以通过预加载资源文件来提高性能。</span><br><span class="line">可以直接编辑文件。</span><br></pre></td></tr></table></figure></p><p>浏览器给虚拟文件系统提供了两种类型的存储空间：临时的和持久性的。临时的存储空间是由浏览器自动分配的，但可能被浏览器回收；持久性的存储空间需要显示的申请，申请时浏览器会给用户一提示，需要用户进行确认。持久性的存储空间是Web App自己管理，浏览器不会回收，也不会清除内容。持久性的存储空间大小是通过配额来管理的，首次申请时会一个初始的配额，配额用完需要再次申请。</p><p>虚拟的文件系统是运行在沙盒中，不同Web App的虚拟文件系统是互相隔离的，虚拟文件系统与本地文件系统也是隔离的。</p><h2 id="移动端Web加载性能（缓存）优化"><a href="#移动端Web加载性能（缓存）优化" class="headerlink" title="移动端Web加载性能（缓存）优化"></a>移动端Web加载性能（缓存）优化</h2><p>分析完HTML5提供的各种缓存机制，回到移动端（针对Android，可能也适用于iOS）的场景。现在Android App（包括手Q和WX）大多嵌入了Webview的组件（系统Webview或QQ浏览器的X5组件），通过内嵌Webview来加载一些HTML5的运营活动页面或资讯页。这样可充分发挥Web前端的优势：快速开发、发布，灵活上下线。但Webview也有一些不可忽视的问题，比较突出的就是加载相对较慢，会相对消耗较多流量。</p><p>通过对一些HTML5页面进行调试及抓包发现，每次加载一个HTML5页面，都会有较多的请求。除了HTML主URL自身的请求外，HTML外部引用的JS、CSS、字体文件、图片都是一个独立的HTTP请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化 Web的加载性能。</p><table><thead><tr><th>缓存机制</th><th style="text-align:center">优势</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td>浏览器</td><td style="text-align:center">HTTP协议层支持</td><td style="text-align:center">静态文件缓存</td></tr><tr><td>Dom Storage</td><td style="text-align:center">较大存储空间，简单</td><td style="text-align:center">临时简单数据存储，Cookie扩展 </td></tr><tr><td>Web SQL Database</td><td style="text-align:center">存储复杂数据结构</td><td style="text-align:center">不推荐，IndexDB替代</td></tr><tr><td>AppCache</td><td style="text-align:center">构建离线App</td><td style="text-align:center">不推荐，离线App，静态文件缓存 </td></tr><tr><td>IndexDB</td><td style="text-align:center">存储任何类型数据，索引</td><td style="text-align:center">结构，关系复杂的数据结构  </td></tr><tr><td>File System API</td><td style="text-align:center">支持文件系统操作</td><td style="text-align:center">数据适合以文件进行管理场景</td></tr></tbody></table><p>结论：综合各种缓存机制比较，对于静态文件，如JS、CSS、字体、图片等，适合通过浏览器缓存机制来进行缓存，通过缓存文件可大幅提升Web的加载速度，且节省流量。但也有一些不足：缓存文件需要首次加载后才会产生；浏览器缓存的存储空间有限，缓存有被清除的可能；缓存的文件没有校验。要解决这些不足，可以参考手Q的离线包，它有效的解决了这些不足。</p><p>对于Web在本地或服务器获取的数据，可以通过Dom Storage和IndexedDB进行缓存。也在一定程度上减少和Server的交互，提高加载速度，同时节省流量。</p><p><strong>@转载请注明出处</strong><br>原文链接：<a href="https://www.csdn.net/article/2015-12-16/2826489/1" target="_blank" rel="noopener">https://www.csdn.net/article/2015-12-16/2826489/1</a></p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web缓存机制</title>
      <link href="/blog/2018/04/03/Web%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/blog/2018/04/03/Web%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>缓存机制是web开发的重要知识点，也是系统优化的重要方向。在前端开发中，缓存有利于加快网页的加载速度，同时缓存能够被反复利用，所以可以减少流量和带宽的开销。这里将系统的介绍在Web开发中的缓存方式，还会涉及到部分操作系统缓存知识。本文会重点介绍浏览器端的缓存机制也就是HTTP缓存，其机制是根据HTTP报文的缓存标识进行的。在分析缓存机制之前，先介绍下浏览器的HTTP报文。HTTP报文分为两种：</p><ul><li><strong>HTTP请求(Request)报文</strong>，报文格式为：<strong>请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)</strong>，如下图</li></ul><p><img src="http://jingchao.xyz/blog/images/Request.jpg" alt=""><br><img src="http://jingchao.xyz/blog/images/Request-header.jpg" alt=""></p><ul><li><strong>HTTP响应(Response)报文</strong>，报文格式为：<strong>状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体</strong>，如下图</li></ul><p><img src="http://jingchao.xyz/blog/images/Response-header.jpg" alt=""></p><p>注：<strong>通用信息头</strong>指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；<strong>实体头</strong>则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。</p><h3 id="Web开发中的不同缓存"><a href="#Web开发中的不同缓存" class="headerlink" title="Web开发中的不同缓存"></a>Web开发中的不同缓存</h3><h4 id="1-数据库缓存"><a href="#1-数据库缓存" class="headerlink" title="1. 数据库缓存"></a>1. 数据库缓存</h4><p>   我们可能听说过memcached，它就是一种数据库层面的缓存方案。类似的还有Redis缓存，也是一种基于内存的数据库，它的功能更加强大，并且支持备份和数据持久化。数据库缓存是指，当web应用的关系比较复杂，数据库中的表很多的时候，如果频繁进行 数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。</p><h4 id="2-CDN缓存"><a href="#2-CDN缓存" class="headerlink" title="2. CDN缓存"></a>2. CDN缓存</h4><p>  CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。通常情况下，浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，浏览器和服务器之间的缓存机制，在这种架构下同样适用。一般对于网站上的静态资源文件可以采用CDN分发，可以加快网站访问速度。</p><h4 id="3-代理服务器缓存"><a href="#3-代理服务器缓存" class="headerlink" title="3. 代理服务器缓存"></a>3. 代理服务器缓存</h4><p>   代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。   </p><h4 id="4-浏览器缓存"><a href="#4-浏览器缓存" class="headerlink" title="4. 浏览器缓存"></a>4. 浏览器缓存</h4><p>   每个浏览器都实现了 HTTP 缓存，我们通过浏览器使用HTTP协议与服务器交互的时候，浏览器就会根据一套与服务器约定的规则进行缓存工作。最新的HTML5协议新增了离线缓存属性，对缓存机制进一步的优化，可以达到，实现图片存在客户端，跨域共享客户端缓存，做到真正的离线访问WEB应用，实现客户端的数据库。</p><h4 id="5-应用层缓存"><a href="#5-应用层缓存" class="headerlink" title="5. 应用层缓存"></a>5. 应用层缓存</h4><p>   应用层缓存是指我们在代码层面上做的缓存。通过代码逻辑，把曾经请求过的数据或资源等，缓存起来，再次需要数据时通过逻辑上的处理选择可用的缓存的数据。h5新增的storage和数据库缓存，都可以归属到应用层缓存。</p><h3 id="操作系统缓存"><a href="#操作系统缓存" class="headerlink" title="操作系统缓存"></a>操作系统缓存</h3><p>首先关于存储的概念有以下几种方式：<br><strong>cache</strong>：缓存为了让从DB/磁盘拿出来的东西放到缓存（放于内存）；<br><strong>磁盘文件</strong>：本地存储的视频，图片，计算机里面的文件；<br><strong>数据库</strong>：系统项目中的数据存储；<br><strong>内存</strong>：计算机中所有的程序运行都是在内存中，所以内存对计算机的性能影响很大。<br>在操作系统缓存机制中，有buffer和cache两种方式，它们都是占用内存（buffer记录元数据，权限属性等，cache缓存文件）。I/O过程本身的延迟，以及高速设备与低速设备交互时的等待延迟，Buffer和Cache就是从这两个方向上产生的优化提高系统性能的方式。</p><p><strong>buffer缓存</strong>是块设备的读写缓冲区，buffer是I/O缓存，用于内存和硬盘（或其他 I/O设备）之间的数据交换的速度而设计的。通常在写一个非常大的文件，文件会被分成一个个的小block块，往内存上写，然后再写入磁盘,这样的效率会很慢。这种情况下，内存就会攒足一次大的block块再写入磁盘，这样就不会有第一种情况里的延迟，这就是buffer。buffer的主要目的是进行流量整形，把突发的大数量较小规模读写整理成平稳的较大规模的I/O，以<strong>减少响应次数</strong>（比如从网上下载视频，不能下一点点数据就写入硬盘，而是达到一定量的数据一整块写，不然硬盘负荷太大）。</p><p><strong>Cache缓存</strong>是高速缓存，用于cpu与内存之间的缓冲，是系统两端处理速度不匹配时的一种折衷策略。主要原因是cpu与memory，由于cpu快，memory跟不上，且有些值使用次数多，所以放入cache中，主要目的是使用内存来缓存可能被再次访问的数据，可以保持冗余的、被重复计算的、计算后的数据（buffer不行）。Cache是经常被使用在I/O请求上，来提高系统性能。如果cache的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO必会非常小。</p><h3 id="Web中浏览器缓存"><a href="#Web中浏览器缓存" class="headerlink" title="Web中浏览器缓存"></a>Web中浏览器缓存</h3><p>浏览器端的缓存分为强缓存（Expires和<strong>Cache-Control</strong>—优先级高，直接使用本地缓存资源）和协商缓存（Last-Modified / If-Modified-Since和 <strong>Etag / If-None-Match</strong>—优先级高，先发送请求到服务器端确认资源更改来确认是否使用缓存）。</p><h3 id="1-强缓存"><a href="#1-强缓存" class="headerlink" title="1. 强缓存"></a>1. 强缓存</h3><p>在HTTP/1.0使用的是Expires字段，该字段表示缓存到期时间，即有效时间+当时服务器的时间，然后将这个时间设置在header中返回给服务器。如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。该时间是一个绝对时间，由于服务端和浏览器端时间不一致，或者用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，因此更推荐另一种强缓存方式。Expires字段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Thu, 15 Mar 2018 09:09:09 GMT</span><br></pre></td></tr></table></figure></p><p>在HTTP/1.1中，增加了一个字段Cache-Control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求，主要是利用该字段的<strong>max-age</strong>值来进行判断，它是一个相对值，资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则资源失效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=9590000</span><br></pre></td></tr></table></figure></p><p>Cache-Control除了max-age字段外，还有几个比较常用的字段设置值：</p><blockquote><strong>no-cache</strong>：不用本地缓存，使用协商缓存，先发送请求到服务器根据响应确认资源是否被更改，如果之前的响应中存在ETag或者Last-Modified，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。<br><br><strong>no-store</strong>：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。<br><br><strong>public</strong>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。<br><br><strong>private</strong>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</blockquote><p><strong>注意</strong>：如果cache-control与expires同时存在的话，cache-control的优先级高于expires</p><h3 id="2-协商缓存"><a href="#2-协商缓存" class="headerlink" title="2. 协商缓存"></a>2. 协商缓存</h3><p>协商缓存（Last-Modified或者Etag）的过程是先从缓存中获取对应的数据标识，然后向服务器发送请求，确认数据是否更新，如果更新，则返回新数据和新缓存。反之，则返回304状态码，告知客户端缓存未更新，可继续使用，这正好弥补了一些强缓存的缺陷，协商缓存主要应用于一些时常需要动态更新的资源文件。协商缓存在协议里的字段是Last-Modified或者Etag，这两个字段都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。</p><p>Last-Modified/If-Modified-Since具体过程：</p><blockquote>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间<br><br>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值<br><br>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header<br><br>浏览器收到304的响应后，就会从缓存中加载资源<br><br>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值</blockquote><p>Etag/If-None-Match</p><p>Etag字段值是由服务器生成的每个资源的唯一标识字符串（一般都是hash生成的），只要资源内容有变化这个值就会改变,其判断过程与Last-Modified类似，与它不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，响应头还会把这个ETag返回，即使这个ETag跟之前的没有变化。</p><p>Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，之所以在HTTP1.1中新增Etag主要为了解决几个Last-Modified的问题：</p><blockquote>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；<br><br>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；<br><br>某些服务器不能精确的得到文件的最后修改时间。<br><br>这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。</blockquote><p><strong>注意</strong>：Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p><h4 id="用户浏览器行为对缓存的影响"><a href="#用户浏览器行为对缓存的影响" class="headerlink" title="用户浏览器行为对缓存的影响"></a>用户浏览器行为对缓存的影响</h4><p>刷新网页 =&gt; 如果缓存没有失效，浏览器会直接使用缓存；反之，则向服务器请求数据<br>手动刷新（F5） =&gt; 浏览器会认为缓存失效，在请求服务器时加上Cache-Control: max-age=0字段，然后询问服务器数据是否更新。<br>强制刷新（Ctrl + F5） =&gt; 浏览器会直接忽略缓存，在请求服务器时加上Cache-Control: no-cache字段，然后重新向服务器拉取文件。<br>更多用户行为可以用如下表格进行表示：</p><table><thead><tr><th>用户行为</th><th style="text-align:center">Expires / Cache-Control</th><th style="text-align:center">Last-Modified / Etag</th></tr></thead><tbody><tr><td>地址栏回车</td><td style="text-align:center">有效</td><td style="text-align:center">有效 </td></tr><tr><td>页面链接跳转</td><td style="text-align:center">有效</td><td style="text-align:center">有效 </td></tr><tr><td>新窗口</td><td style="text-align:center">有效</td><td style="text-align:center">有效</td></tr><tr><td>前进后退</td><td style="text-align:center">有效</td><td style="text-align:center">有效 </td></tr><tr><td>F5刷新</td><td style="text-align:center">无效</td><td style="text-align:center">有效  </td></tr><tr><td>Ctrl+F5刷新</td><td style="text-align:center">无效</td><td style="text-align:center">无效</td></tr></tbody></table><h4 id="移动端的缓存处理"><a href="#移动端的缓存处理" class="headerlink" title="移动端的缓存处理"></a>移动端的缓存处理</h4><p>Cache-Control和Last-Modified一般用在静态资源文件上，如JS、CSS和一些图像文件。通过设置资源文件缓存属性，对提高资源文件加载速度，节省流量很有意义，特别是移动网络环境。但问题是：缓存有效时长应该如何设置，如果太短，就起不到缓存的使用，设置的太长，在服务端资源文件有更新时，浏览器有缓存，则不能及时取到最新的文件。</p><p>对于移动端的缓存，任何一个网络请求的增加，加载消耗时间都是比较大的（尤其弱网环境下）。对于强缓存只要缓存不到期，是不会向服务器发送请求，但是如果是协商缓存的情况下，304的问题就比较大，它会造成无用的服务器请求，导致网络的延时。Last-Modified需要向服务器发起查询请求，才能知道资源文件有没有更新，虽然服务器可能返回304告诉没有更新，但也还有一个请求的过程。对于移动网络，这个请求可能是比较耗时的，有一种说法叫“消灭304”，指的就是优化掉304的请求。</p><p>通过抓包可以发现，带if-Modified-Since字段的请求，如果服务器回包304，回包会带有Cache-Control:max-age或Expires字段，文件的强缓存有效时间会更新，就是文件强缓存会重新有效。304回包后如果再请求，则又可以直接使用本地缓存文件了，不用再向服务器发送请求查询文件是否更新了，除非新的强缓存资源文件时间再次过期。</p><p>另外，Cache-Control与Last-Modified是浏览器内核的机制，一般都是标准的实现，不能更改或设置。以QQ浏览器的X5为例，Cache-Control与Last-Modified缓存不能禁用，缓存容量是12MB，不分Host，过期的缓存会最先被清除。如果都没过期，应该优先清最早的缓存或最快到期的或文件大小最大的，过期缓存也有可能还是有效的，清除缓存会导致资源文件的重新拉取。还有，浏览器，如X5，在使用缓存文件时，是没有对缓存文件内容进行校验的，这样缓存文件内容被修改的可能。</p><p>分析发现，浏览器的缓存机制还不是非常完美的缓存机制。完美的缓存机制应该是这样的：</p><blockquote>缓存文件没更新，尽可能使用缓存，不用和服务器交互；<br>缓存文件有更新时，第一时间能使用到新的文件；<br>缓存的文件要保持完整性，不使用被修改过的缓存文件；<br>缓存的容量大小要能设置或控制，缓存文件不能因为存储空间限制或过期被清除。 以X5为例，第1、2条不能同时满足，第3、4条都不能满足。</blockquote><p>在实际应用中，为了解决Cache-Control缓存时长不好设置的问题，以及为了“消灭304”，采用的方式是：</p><blockquote>1. 在要缓存的资源文件名中加上版本号或文件MD5值字串，如common.d5d02a02.js、common.v1.js，同时设置Cache-Control:max-age=31536000，也就是一年。在一年时间内，资源文件如果本地有缓存，就会使用缓存,这样就可以避免协商缓存的304的回包现象。<br>2. 如果资源文件有修改，则更新文件内容，同时修改资源文件名，如common.v2.js，html页面也会引用新的资源文件名，实现静态资源非覆盖式更新。<br><br>通过这种方式，实现了：缓存文件没有更新，则使用缓存；缓存文件有更新，则第一时间使用最新文件的目的。即上面说的第1、2条。第3、4条由于浏览器内部机制，目前还无法满足。</blockquote><h4 id="浏览器缓存回忆"><a href="#浏览器缓存回忆" class="headerlink" title="浏览器缓存回忆"></a>浏览器缓存回忆</h4><p>浏览器端强缓存优于协商缓存进行，先判断强缓存资源是否过期，若强缓存（Expires和<strong>Cache-Control</strong>）生效则直接使用本地浏览器缓存，若失效则进行协商缓存（Last-Modified / If-Modified-Since和 <strong>Etag</strong> / If-None-Match）发送请求到服务端，协商缓存由服务器响应和本地进行对比验证决定资源是否有效，若协商缓存失效，那么代表该请求的缓存失效，择重新发送请求获取响应结果下载资源，再存入浏览器缓存中，生效则返回304状态码，继续使用缓存，整个浏览器缓存主要过程如下图：</p><p><img src="http://jingchao.xyz/blog/images/all.jpg" alt=""></p><p><strong>@转载请注明出处</strong></p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo迁移</title>
      <link href="/blog/2018/03/21/hexo%E8%BF%81%E7%A7%BB/"/>
      <url>/blog/2018/03/21/hexo%E8%BF%81%E7%A7%BB/</url>
      <content type="html"><![CDATA[<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="一、安装必要软件"><a href="#一、安装必要软件" class="headerlink" title="一、安装必要软件"></a>一、安装必要软件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装 Git 客户端</span><br><span class="line">安装 node JS</span><br></pre></td></tr></table></figure><h3 id="二、在-github-官网添加新电脑产生的密钥"><a href="#二、在-github-官网添加新电脑产生的密钥" class="headerlink" title="二、在 github 官网添加新电脑产生的密钥"></a>二、在 github 官网添加新电脑产生的密钥</h3><h3 id="三、源文件拷贝"><a href="#三、源文件拷贝" class="headerlink" title="三、源文件拷贝"></a>三、源文件拷贝</h3><p>将原来电脑上个人博客目录下必要文件拷贝到新电脑上（比如D:/Blog目录下），注意无需拷贝全部，只拷如下几个文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">package.json</span><br><span class="line">scaffolds/</span><br><span class="line"><span class="built_in">source</span>/</span><br><span class="line">themes/</span><br></pre></td></tr></table></figure></p><h3 id="四、安装-hexo"><a href="#四、安装-hexo" class="headerlink" title="四、安装 hexo"></a>四、安装 hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 cmd 下输入指令安装 hexo：npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="五、进入-D-Blog-目录（拷贝到新电脑的目录），安装相关模块"><a href="#五、进入-D-Blog-目录（拷贝到新电脑的目录），安装相关模块" class="headerlink" title="五、进入 D:/Blog 目录（拷贝到新电脑的目录），安装相关模块"></a>五、进入 D:/Blog 目录（拷贝到新电脑的目录），安装相关模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save  // 文章部署到 git 的模块</span><br><span class="line">npm install hexo-generator-feed --save  // 建立 RSS 订阅（选择安装）</span><br><span class="line">npm install hexo-generator-sitemap --save // 建立站点地图（选择安装）</span><br></pre></td></tr></table></figure><h3 id="六、部署发布文章"><a href="#六、部署发布文章" class="headerlink" title="六、部署发布文章"></a>六、部署发布文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   // 清除缓存 网页正常情况下可以忽略此条命令</span><br><span class="line">hexo g       // 生成静态网页</span><br><span class="line">hexo d       // 开始部署</span><br></pre></td></tr></table></figure><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>具体的思路是：在生成的已经推到github上的hexo静态代码出建立一个分支，利用这个分支来管理自己hexo的源文件。如果能在刚刚配置hexo的时候就想好以后的迁移的问题就太好了，可以省掉很多麻烦。</p><p>具体的操作：<br>克隆gitHub上面生成的静态文件到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/yourname/hexo-test.github.io.git</span><br></pre></td></tr></table></figure></p><p>把克隆到本地的文件除了git的文件都删掉，找不到git的文件的话就到删了吧。不要用hexo init初始化。</p><p>将之前使用hexo写博客时候的整个目录（所有文件）搬过来。把该忽略的文件忽略了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure></p><p>创建一个叫hexo的分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hexo</span><br></pre></td></tr></table></figure></p><p>提交复制过来的文件到暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br></pre></td></tr></table></figure></p><p>提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;新建分支源文件&quot;</span><br></pre></td></tr></table></figure></p><p>推送分支到github<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin hexo</span><br></pre></td></tr></table></figure></p><p>到这里基本上就搞定了，以后再推就可以直接git push了，hexo的操作跟以前一样。</p><p>今后无论什么时候想要在其他电脑上面用hexo写博客，就直接把创建的分支克隆下来，npm install安装依赖之后就可以用了。</p><p>克隆分支的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b hexo https://github.com/yourname/hexo-test.github.io.git</span><br></pre></td></tr></table></figure></p><p>因为上面创建的是一个名字叫hexo的分支，所以这里-b后面的是hexo，再把后面的gitHub的地址换成你自己的hexo博客的地址就可以了。</p><p>这样完了以后，每次写完博客发布之后不要忘了还要git push把源文件推到分支上。</p><p>原文链接：<a href="https://blog.csdn.net/lvonve/article/details/79587321" target="_blank" rel="noopener">https://blog.csdn.net/lvonve/article/details/79587321</a><br>原文链接：<a href="https://www.jianshu.com/p/beb8d611340a" target="_blank" rel="noopener">https://www.jianshu.com/p/beb8d611340a</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hexo</title>
      <link href="/blog/2018/03/12/hexo/"/>
      <url>/blog/2018/03/12/hexo/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
