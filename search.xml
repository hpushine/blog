<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>JavaScript难点</title>
      <link href="/blog/2018/05/15/JavaScript%E9%9A%BE%E7%82%B9/"/>
      <url>/blog/2018/05/15/JavaScript%E9%9A%BE%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>JavaScript引擎是单线程运行的，浏览器无论在什么时候都有且只有一个线程在运行JavaScript程序，浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步。浏览器内核的实现至少有三个常驻线程：javascript引擎线程，界面渲染线程，浏览器事件触发线程，也有一些执行完就终止的线程，如Http请求线程，这些异步线程都会产生不同的异步事件，单线程的JavaScript引擎与另外那些线程进行互动通信，虽然每个浏览器内核实现细节不同，但这其中的调用原理都是大同小异。</p><h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><p>说到原型，就得提一下构造函数，首先看下面一个简单的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Dog(name,age)&#123;   </span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> dog1 = new Dog(<span class="string">"哈士奇"</span>,3);</span><br><span class="line"><span class="built_in">let</span> dog2 = new Dog(<span class="string">"泰迪"</span>,2);</span><br></pre></td></tr></table></figure></p><p>首先创造空的对象，再让this指向这个对象，通过this.name进行赋值，最终返回this，这其实也是new 一个对象的过程。</p><p>其实： let obj = {} 是 let obj = new Object()的语法糖； let arr = [] 是 let arr = new Array()的语法糖； function Dog(){} 是 let Dog = new Fucntion()的语法糖。</p><p>在js中，所有对象都是Object的实例，并继承Object.prototype的属性和方法，但是有一些是隐性的。</p><p><strong>看一下原型的规则：</strong></p><p>1.所有的引用类型（包括数组，对象，函数）都具有对象特性；可自由扩展属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.attribute = <span class="string">"原型"</span>;</span><br><span class="line">var arr = [];</span><br><span class="line">arr.attribute = <span class="string">"作用域"</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn1</span></span> () &#123;&#125;</span><br><span class="line">fn1.attribute = <span class="string">"闭包"</span>;</span><br></pre></td></tr></table></figure></p><p>2.所有的引用类型（包括数组，对象，函数）都有隐性原型属性（<strong>proto</strong>）,值也是一个普通的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(obj.__proto__);</span><br></pre></td></tr></table></figure></p><p>3.所有的函数，都有一个prototype属性，值也是一个普通的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(obj.prototype);</span><br></pre></td></tr></table></figure></p><p>4.所有的引用类型的<strong>proto</strong>属性值都指向构造函数的prototype属性值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(obj.__proto__ === Object.prototype); // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>5.当试图获取对象属性时，如果对象本身没有这个属性，那就会去他的<strong>proto</strong>（prototype）中去寻找。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Dog(name)&#123; </span><br><span class="line">   this.name = name; </span><br><span class="line">&#125; </span><br><span class="line">Dog.prototype.callName = <span class="function"><span class="title">function</span></span> ()&#123; </span><br><span class="line">   console.log(this.name,<span class="string">"wang wang"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> dog1 = new Dog(<span class="string">"Three Mountain"</span>); </span><br><span class="line">dog1.printName = <span class="function"><span class="title">function</span></span> ()&#123; </span><br><span class="line">   console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">dog1.callName();  // Three Mountain wang wang</span><br><span class="line">dog1.printName(); // Three Mountain</span><br></pre></td></tr></table></figure><p>原型链如下图：<br>找一个属性，首先会在f.<strong>proto</strong>中去找，因为属性值为一个对象，那么就会去f.<strong>proto</strong>.<strong>proto</strong>去找，同理如果还没找到，就会一直向上去查找，直到结果为null为止，这个串起来的链即为原型链。<br><img src="http://jingchao.xyz/blog/images/proto.jpg" alt=""></p><h3 id="作用域及闭包"><a href="#作用域及闭包" class="headerlink" title="作用域及闭包"></a>作用域及闭包</h3><p>说到作用域，肯定会想到是执行上下文。每个函数都有自己的excution context，和variable object。这些环境用于储存上下文中的变量，函数声明，参数等。只有函数才能制造作用域。<br><strong>PS：for  if  else 不能创造作用域</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(a) ; // undefined</span><br><span class="line">var a = 1;</span><br><span class="line"></span><br><span class="line">//可理解为</span><br><span class="line">var a;</span><br><span class="line">console.log(a);  // undefined</span><br><span class="line">a = 1;</span><br></pre></td></tr></table></figure></p><p>执行console.log时，a只是被声明出来，并没有赋值；所以结果当然是undefined。</p><p><strong>this</strong></p><p>本质上来说，在js里this是一个指向函数执行环境的指针，this永远指向最后调用它的对象，并且在执行时才能获取值，定义是无法确认它的值。箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123; </span><br><span class="line">    name : <span class="string">"A"</span>, </span><br><span class="line">    fn : <span class="keyword">function</span> （）&#123;</span><br><span class="line">        console.log (this.name) </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">a.fn() // this === a </span><br><span class="line">a 调用了fn() 所以此时this为a</span><br><span class="line"></span><br><span class="line">a.fn.call (&#123;name : <span class="string">"B"</span>&#125;) // this === &#123;name : <span class="string">"B"</span>&#125; </span><br><span class="line">使用call(),将this的值指定为&#123;name:<span class="string">"B"</span>&#125;</span><br><span class="line"></span><br><span class="line">var fn1 = a.fn </span><br><span class="line">fn1() // this === window</span><br></pre></td></tr></table></figure></p><p>虽然指定fn1 = a.fn，但是调用是有window调用，所以 this 为window</p><p>this有多种使用场景，下面会主要介绍4个使用场景：</p><p><strong>1.作为构造函数执行</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>  Student(name,age) &#123;</span><br><span class="line">    this.name = name           // this === s</span><br><span class="line">    this.age = age             // this === s</span><br><span class="line">    //<span class="built_in">return</span>  this</span><br><span class="line">&#125;</span><br><span class="line">var s = new Student(<span class="string">"hpu"</span>,22)</span><br></pre></td></tr></table></figure></p><p>首先new 字段会创建一个空的对象，然后调用apply()函数，将this指向这个空对象。这样的话，函数内部的this就会被空对象代替。</p><p><strong>2.作为普通函数执行</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>  <span class="function"><span class="title">fn</span></span> () &#123;</span><br><span class="line">    console.log (this)       // this === window</span><br><span class="line">&#125;</span><br><span class="line">fn ()</span><br></pre></td></tr></table></figure></p><p><strong>3.作为对象属性执行</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name : <span class="string">"A"</span>,</span><br><span class="line">    printName : <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log (this.name)  // this === obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.printName ()</span><br></pre></td></tr></table></figure></p><p><strong>4.call()，apply()，bind()</strong></p><p>三个函数可以修改this的指向，具体往下看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = <span class="string">"小明"</span> , age = <span class="string">"17"</span></span><br><span class="line">var obj = &#123; </span><br><span class="line">    name : <span class="string">"安妮"</span>, </span><br><span class="line">    objAge : this.age, </span><br><span class="line">    fun : <span class="function"><span class="title">function</span></span> () &#123; </span><br><span class="line">            console.log ( this.name + <span class="string">"今年"</span> + this.age ) </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line">console.log(obj.objAge) // 17 </span><br><span class="line">obj.fun() // 安妮今年undefined</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;小明&quot; , age = &quot;17&quot; </span><br><span class="line">var obj = &#123; </span><br><span class="line">    name : &quot;安妮&quot;, </span><br><span class="line">    objAge ：this.age, </span><br><span class="line">    fun : function (like,dislike) &#123; </span><br><span class="line">              console.log (this.name + &quot;今年&quot; + this.age ，&quot;喜欢吃&quot; </span><br><span class="line">              + like + &quot;不喜欢吃&quot; + dislike) </span><br><span class="line">           &#125; </span><br><span class="line">    &#125; </span><br><span class="line">var a = &#123; name : &quot;Jay&quot;, age : 23 &#125; </span><br><span class="line">obj.fun.call(a,&quot;苹果&quot;,&quot;香蕉&quot;) // Jay今年23 喜欢吃苹果不喜欢吃香蕉 </span><br><span class="line">obj.fun.apply(a,[&quot;苹果&quot;,&quot;香蕉&quot;]) // Jay今年23 喜欢吃苹果不喜欢吃香蕉 </span><br><span class="line">obj.fun.bind(a,&quot;苹果&quot;,&quot;香蕉&quot;)() // Jay今年23 喜欢吃苹果不喜欢吃香蕉</span><br></pre></td></tr></table></figure><p>首先call，apply，bind第一个参数都是this指向的对象，call和apply如果第一个参数指向null或undefined时，那么this会指向windows对象。</p><p>call，apply，bind的执行方式如上例所示。call，apply都是改变上下文中的this，并且是立即执行的。bind方法可以让对应的函数想什么时候调用就什么时候调用。</p><p><strong>闭包</strong></p><p>闭包的概念很抽象，看下面的例子理解什么叫闭包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">a</span></span>()&#123;</span><br><span class="line">  var n = 0;</span><br><span class="line">  this.fun = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    n++; </span><br><span class="line">    console.log(n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var c = new a();</span><br><span class="line">c.fun();  //1</span><br><span class="line">c.fun();  //2</span><br></pre></td></tr></table></figure></p><p>闭包就是能够读取其他函数内部变量的函数。在js中只有函数内部的子函数才能读取局部变量。所以可以简单的理解为：定义在内部函数的函数。</p><p>用途主要有两个：</p><p>1）前面提到的，读取函数内部的变量。</p><p>2）让变量值始终保持在内存中。</p><h3 id="异步和单线程"><a href="#异步和单线程" class="headerlink" title="异步和单线程"></a>异步和单线程</h3><p>先感受下异步<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">"start"</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">"medium"</span>);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">console.log(<span class="string">"end"</span>);</span><br></pre></td></tr></table></figure></p><p>使用异步后，打印的顺序为 start-&gt; end-&gt;medium，因为没有阻塞。</p><p><strong>异步产生原因</strong></p><p>首先因为js为单线程，也就是说CPU同一时间只能处理一个事务。得按顺序，一个一个处理。</p><p>如上例所示，第一步：执行第一行打印 “start”；第二步：执行setTimeout，将其中的函数分存起来，等待时间结束后执行；第三步：执行最后一行，打印“end”；第四步：处于空闲状态，查看暂存中，是否有可执行的函数；第五步：执行分存函数。</p><p><strong>js引擎单线程</strong></p><p>js的主要用途是与用户互动，以及操作DOM，这决定它只能是单线程。例：一个线程要添加DOM节点，一个线程要删减DOM节点，容易造成分歧。</p><p>为了更好使用多CPU，H5提供了web Worker 标准，允许js创建多线程，但是子线程受到主线程控制，而且不得操作DOM。</p><p>任务列队</p><p>单线程就意味着，所有的任务都要排队，前一个结束，才会执行后面的任务。如果列队是因为计算量大，CPU忙不过来，倒也算了。但是更多的时候，CPU是闲置的，因为IO设备处理得很慢，例如 ajax读取网络数据。js设计者便想到，主线程完全可以不管IO设备，将其挂起，然后执行后面的任务。等后面的任务结束掉，在反过头来处理挂起的任务。</p><p>梳理一下：</p><p>1）所有的同步任务都在主线程上执行，形成一个执行栈</p><p>2）除了主线程之外，还存在一个任务列队，只要一步任务有了运行结果，就在任务列队中植入一个时间</p><p>3）主线程完成所有任务，就会读取列队任务，并将其执行</p><p>4）重复上面三步</p><p>只要主线程空了，就会读取任务列队，这就是js的运行机制，也被称为 event loop（事件循环）。</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grammer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>集群和负载均衡</title>
      <link href="/blog/2018/05/06/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/blog/2018/05/06/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      <content type="html"><![CDATA[<p>负载均衡（Load Balance）是建立在现有网络结构之上，提供一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。就是分摊任务到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p><p>负载均衡，核心就是网络流量分发，服务器负载均衡根据LB设备处理到的报文层次，分为四层服务器负载均衡（TCP，UDP）和七层负载均衡（HTTP，HTTPS等），四层处理到IP包的IP头，不解析报文四层以上载荷（L4 SLB），基本就是根据连接信息（TCP）或者本身的特征（源IP，目标IP）等做；七层处理到报文载荷部分，比如HTTP，RTSP，SIP报文头，有时也包括报文内容部分，可以用域名（HTTP头里的Host），URL，Cookie，Header这些信息来做。四层LB可以说是流量转发，七层LB常称作代理。</p><p>从实现上看，基本可以分软负载均衡和反向代理：<br>软负载均衡不会经过中间代理，网络转发，性能会较好，但是一般不好做精细的流量控制，有的方案还有延时问题。实现有DNS实现，iptables实现的方案。负载均衡的实现有Haproxy，LVS等。现在比较新的做法是用dpdk这种内核bypass方案做的负载均衡，由于绕过了linux内核比较复杂的网络协议栈，因此性能会有明显的提升（轻松跑满万兆网卡）。 </p><p>反向代理，就是通过代理来做（Nginx）。由于流量都会过LB，因此可以做到比较精细的流量分发（比如各种权重，七层的各种转发规则）。坏处就是代理本身可能成为瓶颈，以及过了一层代理造成网络延时的增加，而代理本身也会有一定成本，因此实现成本较高。</p><p>以下简单介绍几种负载均衡的方式</p><h3 id="一、http重定向"><a href="#一、http重定向" class="headerlink" title="一、http重定向"></a>一、http重定向</h3><p>当http代理（比如浏览器）向web服务器请求某个URL后，web服务器可以通过http响应头信息中的Location标记来返回一个新的URL。这意味着HTTP代理需要继续请求这个新的URL，完成自动跳转。</p><p>性能缺陷：</p><p>1、吞吐率限制</p><p>主站点服务器的吞吐率平均分配到了被转移的服务器。现假设使用RR（Round Robin）调度策略，子服务器的最大吞吐率为1000reqs/s，那么主服务器的吞吐率要达到3000reqs/s才能完全发挥三台子服务器的作用，那么如果有100台子服务器，那么主服务器的吞吐率可想而知得有大？相反，如果主服务的最大吞吐率为6000reqs/s，那么平均分配到子服务器的吞吐率为2000reqs/s，而现子服务器的最大吞吐率为1000reqs/s，因此就得增加子服务器的数量，增加到6个才能满足。</p><p>2、重定向访问深度不同</p><p>有的重定向一个静态页面，有的重定向相比复杂的动态页面，那么实际服务器的负载差异是不可预料的，而主站服务器却一无所知。因此整站使用重定向方法做负载均衡不太好。</p><p>我们需要权衡转移请求的开销和处理实际请求的开销，前者相对于后者越小，那么重定向的意义就越大，例如下载。你可以去很多镜像下载网站试下，会发现基本下载都使用了Location做了重定向。</p><h3 id="二、DNS负载均衡"><a href="#二、DNS负载均衡" class="headerlink" title="二、DNS负载均衡"></a>二、DNS负载均衡</h3><p>DNS负责提供域名解析服务，当访问某个站点时，实际上首先需要通过该站点域名的DNS服务器来获取域名指向的IP地址，在这一过程中，DNS服务器完成了域名到IP地址的映射，同样，这样映射也可以是一对多的，这时候，DNS服务器便充当了负载均衡调度器，它就像http重定向转换策略一样，将用户的请求分散到多台服务器上，但是它的实现机制完全不同。</p><p>相比http重定向，基于DNS的负载均衡完全节省了所谓的主站点，或者说DNS服务器已经充当了主站点的职能。但不同的是，作为调度器，DNS服务器本身的性能几乎不用担心。因为DNS记录可以被用户浏览器或者互联网接入服务商的各级DNS服务器缓存，只有当缓存过期后才会重新向域名的DNS服务器请求解析。也说是DNS不存在http的吞吐率限制，理论上可以无限增加实际服务器的数量。</p><p>特性:</p><p>1、可以根据用户IP来进行智能解析。DNS服务器可以在所有可用的A记录中寻找离用记最近的一台服务器。</p><p>2、动态DNS：在每次IP地址变更时，及时更新DNS服务器。当然，因为缓存，一定的延迟不可避免。</p><p>不足：</p><p>1、没有用户能直接看到DNS解析到了哪一台实际服务器，加服务器运维人员的调试带来了不便。</p><p>2、策略的局限性。例如你无法将HTTP请求的上下文引入到调度策略中，而在前面介绍的基于HTTP重定向的负载均衡系统中，调度器工作在HTTP层面，它可以充分理解HTTP请求后根据站点的应用逻辑来设计调度策略，比如根据请求不同的URL来进行合理的过滤和转移。</p><p>3、如果要根据实际服务器的实时负载差异来调整调度策略，这需要DNS服务器在每次解析操作时分析各服务器的健康状态，对于DNS服务器来说，这种自定义开发存在较高的门槛，更何况大多数站点只是使用第三方DNS服务。</p><p>4、DNS记录缓存，各级节点的DNS服务器不同程序的缓存会让你晕头转向。</p><p>5、基于以上几点，DNS服务器并不能很好地完成工作量均衡分配，最后，是否选择基于DNS的负载均衡方式完全取决于你的需要。</p><h3 id="三、反向代理负载均衡"><a href="#三、反向代理负载均衡" class="headerlink" title="三、反向代理负载均衡"></a>三、反向代理负载均衡</h3><p>这个肯定大家都有所接触，因为几乎所有主流的Web服务器都热衷于支持基于反向代理的负载均衡。它的核心工作就是转发HTTP请求。</p><p>相比前面的HTTP重定向和DNS解析，反向代理的调度器扮演的是用户和实际服务器中间人的角色：</p><p>1、任何对于实际服务器的HTTP请求都必须经过调度器</p><p>2、调度器必须等待实际服务器的HTTP响应，并将它反馈给用户（前两种方式不需要经过调度反馈，是实际服务器直接发送给用户）</p><p>特性：</p><p>1、调度策略丰富。例如可以为不同的实际服务器设置不同的权重，以达到能者多劳的效果。</p><p>2、对反向代理服务器的并发处理能力要求高，因为它工作在HTTP层面。</p><p>3、反向代理服务器进行转发操作本身是需要一定开销的，比如创建线程、与后端服务器建立TCP连接、接收后端服务器返回的处理结果、分析HTTP头部信息、用户空间和内核空间的频繁切换等，虽然这部分时间并不长，但是当后端服务器处理请求的时间非常短时，转发的开销就显得尤为突出。例如请求静态文件，更适合使用前面介绍的基于DNS的负载均衡方式。</p><p>4、反向代理服务器可以监控后端服务器，比如系统负载、响应时间、是否可用、TCP连接数、流量等，从而根据这些数据调整负载均衡的策略。</p><p>5、反射代理服务器可以让用户在一次会话周期内的所有请求始终转发到一台特定的后端服务器（粘滞会话），这样的好处一是保持session的本地访问，二是防止后端服务器的动态内存缓存的资源浪费。</p><h3 id="四、IP负载均衡-LVS-NAT"><a href="#四、IP负载均衡-LVS-NAT" class="headerlink" title="四、IP负载均衡(LVS-NAT)"></a>四、IP负载均衡(LVS-NAT)</h3><p>NAT服务器:它工作在传输层，它可以修改发送来的IP数据包，将数据包的目标地址修改为实际服务器地址。</p><p>数据的流向：</p><p>客户端 –&gt; Load Balancer –&gt; RS –&gt; Load Balancer –&gt; 客户端</p><p><img src="http://jingchao.xyz/blog/images/nat.webp" alt=""></p><p>从Linux2.4内核开始，其内置的Neftilter模块在内核中维护着一些数据包过滤表，这些表包含了用于控制数据包过滤的规则。可喜的是，Linux提供了iptables来对过滤表进行插入、修改和删除等操作。更加令人振奋的是，Linux2.6.x内核中内置了IPVS模块，它的工作性质类型于Netfilter模块，不过它更专注于实现IP负载均衡。</p><p>IPVS的管理工具是ipvsadm，它为提供了基于命令行的配置界面，可以通过它快速实现负载均衡系统。这就是大名鼎鼎的LVS(Linux Virtual Server，Linux虚拟服务器)。</p><p>1、打开调度器的数据包转发选项</p><p>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</p><p>2、检查实际服务器是否已经将NAT服务器作为自己的默认网关，如果不是，如添加</p><p>route add default gw xx.xx.xx.xx</p><p>3、使用ipvsadm配置</p><p>ipvsadm -A -t 111.11.11.11:80 -s rr</p><p>添加一台虚拟服务器，-t 后面是服务器的外网ip和端口，-s rr是指采用简单轮询的RR调度策略（这属于静态调度策略，除此之外，LVS还提供了系列的动态调度策略，比如最小连接（LC）、带权重的最小连接（WLC），最短期望时间延迟（SED）等）</p><p>ipvsadm -a -t 111.11.11.11:80 -r 10.10.120.210:8000 -m</p><p>ipvsadm -a -t 111.11.11.11:80 -r 10.10.120.211:8000 -m</p><p>添加两台实际服务器（不需要有外网ip），-r后面是实际服务器的内网ip和端口，-m表示采用NAT方式来转发数据包</p><p>运行ipvsadm -L -n可以查看实际服务器的状态。这样就大功告成了。</p><p>实验证明使用基于NAT的负载均衡系统。作为调度器的NAT服务器可以将吞吐率提升到一个新的高度，几乎是反向代理服务器的两倍以上，这大多归功于在内核中进行请求转发的较低开销。但是一旦请求的内容过大时，不论是基于反向代理还是NAT，负载均衡的整体吞吐量都差距不大，这说明对于一开销较大的内容，使用简单的反向代理来搭建负载均衡系统是值考虑的。</p><p>这么强大的系统还是有它的瓶颈，那就是NAT服务器的网络带宽，包括内部网络和外部网络。当然可以配备千兆交换机或万兆交换机，甚至负载均衡硬件设备，除了这另一个简单有效的办法就是将基于NAT的集群和前面的DNS混合使用，比如５个100Mbps出口宽带的集群，然后通过DNS来将用户请求均衡地指向这些集群，同时，你还可以利用DNS智能解析实现地域就近访问。这样的配置对于大多数业务是足够了，但是对于提供下载或视频等服务的大规模站点，NAT服务器还是不够出色。</p><h3 id="五、直接路由-LVS-DR"><a href="#五、直接路由-LVS-DR" class="headerlink" title="五、直接路由(LVS-DR)"></a>五、直接路由(LVS-DR)</h3><p>NAT是工作在网络分层模型的传输层（第四层），而直接路由是工作在数据链路层（第二层），貌似更屌些。它通过修改数据包的目标MAC地址（没有修改目标IP），将数据包转发到实际服务器上，不同的是，实际服务器的响应数据包将直接发送给客户羰，而不经过调度器。</p><p>数据的流向：</p><p>客户端 –&gt; Load Balancer –&gt; RS –&gt; 客户端</p><p><img src="http://jingchao.xyz/blog/images/dr.webp" alt=""></p><p>1、网络设置</p><p>这里假设一台负载均衡调度器，两台实际服务器，购买三个外网ip，一台机一个，三台机的默认网关需要相同，最后再设置同样的ip别名，这里假设别名为10.10.120.193。这样一来，将通过10.10.120.193这个IP别名来访问调度器，你可以将站点的域名指向这个IP别名。</p><p>2、将ip别名添加到回环接口lo上</p><p>这是为了让实际服务器不要去寻找其他拥有这个IP别名的服务器，在实际服务器中运行：</p><p>另外还要防止实际服务器响应来自网络中针对IP别名的ARP广播，为此还要执行：</p><p>echo “1” &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore</p><p>echo “2” &gt; /proc/sys/net/ipv4/conf/lo/arp_announce</p><p>echo “1” &gt; /proc/sys/net/ipv4/conf/all/arp_ignore</p><p>echo “1” &gt; /proc/sys/net/ipv4/conf/all/arp_announce</p><p>配置完了就可以使用ipvsadm配置LVS-DR集群了</p><p>ipvsadm -A -t 10.10.120.193:80 -s rr</p><p>ipvsadm -a -t 10.10.120.193:80 -r 10.10.120.210:8000 -g</p><p>ipvsadm -a -t 10.10.120.193:80 -r 10.10.120.211:8000 -g</p><p>-g 就意味着使用直接路由的方式转发数据包</p><p>LVS-DR 相较于LVS-NAT的最大优势在于LVS-DR不受调度器宽带的限制，例如假设三台服务器在WAN交换机出口宽带都限制为10Mbps，只要对于连接调度器和两台实际服务器的LAN交换机没有限速，那么，使用LVS-DR理论上可以达到20Mbps的最大出口宽带，因为它的实际服务器的响应数据包可以不经过调度器而直接发往用户端啊，所以它与调度器的出口宽带没有关系，只能自身的有关系。而如果使用LVS-NAT，集群只能最大使用10Mbps的宽带。所以，越是响应数据包远远超过请求数据包的服务，就越应该降低调度器转移请求的开销，也就越能提高整体的扩展能力，最终也就越依赖于WAN出口宽带。</p><p>总的来说，LVS-DR适合搭建可扩展的负载均衡系统，不论是Web服务器还是文件服务器，以及视频服务器，它都拥有出色的性能。前提是你必须为实际器购买一系列的合法IP地址。</p><h3 id="六、IP隧道-LVS-TUN"><a href="#六、IP隧道-LVS-TUN" class="headerlink" title="六、IP隧道(LVS-TUN)"></a>六、IP隧道(LVS-TUN)</h3><p>基于IP隧道的请求转发机制：将调度器收到的IP数据包封装在一个新的IP数据包中，转交给实际服务器，然后实际服务器的响应数据包可以直接到达用户端。目前Linux大多支持，可以用LVS来实现，称为LVS-TUN，与LVS-DR不同的是，实际服务器可以和调度器不在同一个WANt网段，调度器通过IP隧道技术来转发请求到实际服务器，所以实际服务器也必须拥有合法的IP地址。</p><p>总体来说，LVS-DR和LVS-TUN都适合响应和请求不对称的Web服务器，如何从它们中做出选择，取决于你的网络部署需要，因为LVS-TUN可以将实际服务器根据需要部署在不同的地域，并且根据就近访问的原则来转移请求，所以有类似这种需求的，就应该选择LVS-TUN。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>git简要教程</title>
      <link href="/blog/2018/04/26/git%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B/"/>
      <url>/blog/2018/04/26/git%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h3><p>Git的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure></p><h3 id="一、-创建与合并分支"><a href="#一、-创建与合并分支" class="headerlink" title="一、 创建与合并分支"></a>一、 创建与合并分支</h3><p>1、 从master分支创建dev分支并切换到dev分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure></p><p>其中，git checkout -b dev 等价于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br><span class="line"></span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure></p><p>查看本地当前的分支，分支前面带“*”表示当前分支，剩下的分支表示本地有的分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><p>查看远程全部的分支，白色的表示本地有的，红色的表示本地没有，仅在远程存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure></p><p>2、修改代码、提交代码（当前的操作是在dev分支上进行）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add a.html</span><br><span class="line"></span><br><span class="line">git commit -m &quot;提交文件a.html&quot;</span><br></pre></td></tr></table></figure></p><p>3、分支合并(将dev合并到master)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line"></span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure></p><p>4、合并完成后，删除dev分支.(删除dev分支时，注意我们当前所在的分支不能是dev分支)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure></p><p>5、删除后，查看分支(此时看不到dev分支了)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><p>6、总结 ：工作中经常从master创建新的分支，具体操作如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">master创建新分支：</span><br><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">git checkout -b  issues1234</span><br><span class="line"></span><br><span class="line">git push origin issues1234</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m &quot;***&quot;</span><br><span class="line"></span><br><span class="line">git push origin issues1234</span><br></pre></td></tr></table></figure></p><p>注意：将本地分支branch1推到远端的branch2操作步骤：git push origin branch1:branch2</p><p>7、删除分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -D   issues1234  //本地强制删除分支issues1234</span><br><span class="line"></span><br><span class="line">git push origin  :issues1234  //推到远程</span><br></pre></td></tr></table></figure></p><h3 id="二、-解决冲突"><a href="#二、-解决冲突" class="headerlink" title="二、 解决冲突"></a>二、 解决冲突</h3><p>1、发生冲突的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure></p><p>其中，git使用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记文件中自己和别人产生冲突的部分。</p><p>在&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======之间为自己的代码；<br>=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间为别人的代码。</p><p>如果保留自己的代码，将别人的代码删掉即可。</p><p>2、冲突解决后提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add ***</span><br><span class="line"></span><br><span class="line">git commit -m &quot;fix conflict&quot;</span><br><span class="line"></span><br><span class="line">git push origin 分支名</span><br></pre></td></tr></table></figure></p><h3 id="三、Bug分支"><a href="#三、Bug分支" class="headerlink" title="三、Bug分支"></a>三、Bug分支</h3><p>1、储藏更改:将当前更改的代码储藏起来，等以后恢复使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></p><p>2、恢复储藏的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git stash pop //恢复的同时把stash内容删掉</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">git stash apply  //恢复stash，但是stash内容并不删除</span><br><span class="line"></span><br><span class="line">git stash drop //在上面操作的基础上，以此来删除stash</span><br><span class="line"></span><br><span class="line">注： git stash list //查看全部的stash列表</span><br></pre></td></tr></table></figure></p><p>3、将stash空间清空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure></p><p>4、git stash pop 和 git stash apply 区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原来git stash pop stash@&#123;id&#125;命令会在执行后将对应的stash id 从stash list里删除</span><br><span class="line"></span><br><span class="line">而 git stash apply stash@&#123;id&#125; 命令则会继续保存stash id。</span><br></pre></td></tr></table></figure></p><h3 id="四、版本回退"><a href="#四、版本回退" class="headerlink" title="四、版本回退"></a>四、版本回退</h3><p>1、回退至上一个版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure></p><p>2、回退至指定版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard  版本号</span><br></pre></td></tr></table></figure></p><p>3、查看以往版本号(本地的commit)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></p><p>4、查看各版本号及信息(所有的commit：本地commit + 其他同事的commit)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></p><h3 id="五、撤销修改"><a href="#五、撤销修改" class="headerlink" title="五、撤销修改"></a>五、撤销修改</h3><p>1、撤销修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  checkout -- a.html</span><br></pre></td></tr></table></figure></p><p>分两种情况分析：<br>①： 还没有执行 git add 操作，执行上面的操作后，会恢复到和版本库中一模一样的版本状态。</p><p>②： 执行了git add ，还没执行 git commit ,再执行上面的操作后，会恢复到git add 结束后的状态</p><p>注：一旦执行了git commit -m “*”，就不能再使用上面的命令回退。</p><p>2、撤销新建文件</p><p>比如新建一个aa.html页面，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -f ../aa.html</span><br></pre></td></tr></table></figure></p><p>3、撤销新建文件夹</p><p>比如新建一个文件夹”demo”，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -df ./demo</span><br></pre></td></tr></table></figure></p><h3 id="六、对于已经push的版本，进行回退"><a href="#六、对于已经push的版本，进行回退" class="headerlink" title="六、对于已经push的版本，进行回退"></a>六、对于已经push的版本，进行回退</h3><p>1、第一步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号 //本地回退到指定的版本</span><br></pre></td></tr></table></figure></p><p>2、第二步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push  -f origin dev    //将远程的也回退到指定版本</span><br></pre></td></tr></table></figure></p><h3 id="七、本地同步远程删除的分支"><a href="#七、本地同步远程删除的分支" class="headerlink" title="七、本地同步远程删除的分支"></a>七、本地同步远程删除的分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin -p  //用来清除已经没有远程信息的分支</span><br><span class="line"></span><br><span class="line">这样git branch -a 就不会拉取远程已经删除的分支了</span><br></pre></td></tr></table></figure><h3 id="八、删除掉没有与远程分支对应的本地分支"><a href="#八、删除掉没有与远程分支对应的本地分支" class="headerlink" title="八、删除掉没有与远程分支对应的本地分支"></a>八、删除掉没有与远程分支对应的本地分支</h3><p>从gitlab上看不到的分支在本地可以通过git branch -a 查到，删掉没有与远程分支对应的本地分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch -p</span><br></pre></td></tr></table></figure></p><h3 id="九、查看远程库的一些信息，及与本地分支的信息"><a href="#九、查看远程库的一些信息，及与本地分支的信息" class="headerlink" title="九、查看远程库的一些信息，及与本地分支的信息"></a>九、查看远程库的一些信息，及与本地分支的信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin</span><br></pre></td></tr></table></figure><h3 id="Git命令清单"><a href="#Git命令清单" class="headerlink" title="Git命令清单"></a>Git命令清单</h3><h3 id="增加删除文件"><a href="#增加删除文件" class="headerlink" title="增加删除文件"></a>增加删除文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h3 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h3 id="标签命令"><a href="#标签命令" class="headerlink" title="标签命令"></a>标签命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><p> 参考链接：<a href="https://segmentfault.com/a/1190000014461898" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014461898</a><br> 参考链接：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>移动端H5缓存</title>
      <link href="/blog/2018/04/20/%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E7%BC%93%E5%AD%98/"/>
      <url>/blog/2018/04/20/%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<p>HTML5是新一代的HTML标准，加入很多新的特性。离线存储（亦称为缓存机制）是其中一个非常重要的特性。HTML5引入了离线存储，这意味着移动Web应用可进行缓存，并可在没有Internet连接时离线进行访问。<br>HTML5应用程序缓存为应用带来三个优势：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">离线浏览：用户可在应用离线时使用它们；</span><br><span class="line">速度：已缓存资源加载得更快；</span><br><span class="line">减少服务器负载：浏览器将只从服务器下载更新过或更改过的资源。</span><br></pre></td></tr></table></figure></p><p>根据标准，到目前为止，H5共有6种缓存机制，有些是之前已有，有些是H5才新加入的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">浏览器缓存机制</span><br><span class="line">Dom Storgage（Web Storage）存储机制</span><br><span class="line">Web SQL Database存储机制（不推荐）</span><br><span class="line">Application Cache（AppCache）机制</span><br><span class="line">Indexed Database （IndexedDB）</span><br><span class="line">File System API</span><br></pre></td></tr></table></figure></p><p>下面分析各种缓存机制的原理、用法及特点；然后针对Android移动端Web性能加载优化的需求，看如何适当利用缓存机制来提高Web的加载性能。</p><h3 id="1-浏览器缓存机制"><a href="#1-浏览器缓存机制" class="headerlink" title="1. 浏览器缓存机制"></a>1. 浏览器缓存机制</h3><p>浏览器缓存机制是指通过HTTP协议头里的Cache-Control（或Expires）和Last-Modified（或Etag）等字段来控制文件缓存的机制。这应该是Web中最早的缓存机制了，是在HTTP协议中实现的，有点不同于Dom Storage、AppCache等缓存机制，但本质上是一样的，可以理解为一个是协议层实现的，一个是应用层实现的。</p><p>Cache-Control和Last-Modified一般用在静态资源文件上，如JS、CSS和一些图像文件。通过设置资源文件缓存属性，对提高资源文件加载速度，节省流量很有意义，特别是移动网络环境。但问题是：缓存有效时长应该如何设置，如果太短，就起不到缓存的使用，设置的太长，在服务端资源文件有更新时，浏览器有缓存，则不能及时取到最新的文件。</p><p>对于移动端的缓存，任何一个网络请求的增加，加载消耗时间都是比较大的（尤其弱网环境下）。对于强缓存只要缓存不到期，是不会向服务器发送请求，但是如果是协商缓存的情况下，304的问题就比较大，它会造成无用的服务器请求，导致网络的延时。Last-Modified需要向服务器发起查询请求，才能知道资源文件有没有更新，虽然服务器可能返回304告诉没有更新，但也还有一个请求的过程。对于移动网络，这个请求可能是比较耗时的，有一种说法叫“消灭304”，指的就是优化掉304的请求。</p><p>通过抓包可以发现，带if-Modified-Since字段的请求，如果服务器回包304，回包会带有Cache-Control:max-age或Expires字段，文件的强缓存有效时间会更新，就是文件强缓存会重新有效。304回包后如果再请求，则又可以直接使用本地缓存文件了，不用再向服务器发送请求查询文件是否更新了，除非新的强缓存资源文件时间再次过期。</p><p>另外，Cache-Control与Last-Modified是浏览器内核的机制，一般都是标准的实现，不能更改或设置。以QQ浏览器的X5为例，Cache-Control与Last-Modified缓存不能禁用，缓存容量是12MB，不分Host，过期的缓存会最先被清除。如果都没过期，应该优先清最早的缓存或最快到期的或文件大小最大的，过期缓存也有可能还是有效的，清除缓存会导致资源文件的重新拉取。还有，浏览器，如X5，在使用缓存文件时，是没有对缓存文件内容进行校验的，这样缓存文件内容被修改的可能。</p><p>分析发现，浏览器的缓存机制还不是非常完美的缓存机制。完美的缓存机制应该是这样的：</p><blockquote>缓存文件没更新，尽可能使用缓存，不用和服务器交互；<br>缓存文件有更新时，第一时间能使用到新的文件；<br>缓存的文件要保持完整性，不使用被修改过的缓存文件；<br>缓存的容量大小要能设置或控制，缓存文件不能因为存储空间限制或过期被清除。 以X5为例，第1、2条不能同时满足，第3、4条都不能满足。</blockquote><p>在实际应用中，为了解决Cache-Control缓存时长不好设置的问题，以及为了“消灭304”，采用的方式是：</p><blockquote>1. 在要缓存的资源文件名中加上版本号或文件MD5值字串，如common.d5d02a02.js、common.v1.js，同时设置Cache-Control:max-age=31536000，也就是一年。在一年时间内，资源文件如果本地有缓存，就会使用缓存,这样就可以避免协商缓存的304的回包现象。<br>2. 如果资源文件有修改，则更新文件内容，同时修改资源文件名，如common.v2.js，html页面也会引用新的资源文件名，实现静态资源非覆盖式更新。<br><br>通过这种方式，实现了：缓存文件没有更新，则使用缓存；缓存文件有更新，则第一时间使用最新文件的目的。即上面说的第1、2条。第3、4条由于浏览器内部机制，目前还无法满足。</blockquote><h3 id="2-Dom-Storage（Web-Storage）存储机制"><a href="#2-Dom-Storage（Web-Storage）存储机制" class="headerlink" title="2. Dom Storage（Web Storage）存储机制"></a>2. Dom Storage（Web Storage）存储机制</h3><p>DOM存储是一套在Web Applications 1.0规范中首次引入的与存储相关的特性的总称，现在已经分离出来，单独发展成为独立的W3C Web存储规范。DOM存储被设计为用来提供一个更大存储量、更安全、更便捷的存储方法，从而可以代替掉将一些不需要让服务器知道的信息存储到Cookies里的这种传统方法。这是对Dom Storage存储机制的官方表述。</p><p>Dom Storage是通过存储字符串的Key/Value对来提供的，并提供5MB（不同浏览器可能不同，分Host）的存储空间（Cookies才4KB)。另外Dom Storage存储的数据在本地，不像 Cookies，每次请求一次页面，Cookies 都会发送给服务器。</p><p>DOM Storage分为sessionStorage和localStorage。localStorage对象和sessionStorage对象使用方法基本相同，它们的区别在于作用的范围不同。sessionStorage用来存储与页面相关的数据，它在页面关闭后无法使用。而localStorage则持久存在，在页面关闭后也可以使用。</p><p>sessionStorage是个全局对象，它维护着在页面会话（page session）期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入（reload）或者被恢复（restores）时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。</p><p>当浏览器被意外刷新的时候，一些临时数据应当被保存和恢复。sessionStorage对象在处理这种情况的时候是最有用的，比如恢复我们在表单中已经填写的数据。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"> // 当页面刷新时，从sessionStorage恢复之前输入的内容</span><br><span class="line"> window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> (window.sessionStorage) &#123;</span><br><span class="line">        var name = window.sessionStorage.getItem(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="string">""</span> || name != null)&#123;</span><br><span class="line">            document.getElementById(<span class="string">"name"</span>).value = name;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> // 将数据保存到sessionStorage对象中</span><br><span class="line"> <span class="keyword">function</span> <span class="function"><span class="title">saveToStorage</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (window.sessionStorage) &#123;</span><br><span class="line">        var name = document.getElementById(<span class="string">"name"</span>).value;</span><br><span class="line">        window.sessionStorage.setItem(<span class="string">"name"</span>, name);</span><br><span class="line">        window.location.href=<span class="string">"session_storage.html"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">&lt;form action=<span class="string">"./session_storage.html"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span> id=<span class="string">"name"</span>/&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"Save"</span> onclick=<span class="string">"saveToStorage()"</span>/&gt;</span><br><span class="line">&lt;/form&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure></p><p>把上面的代码复制到session_storage.html（也可以从附件中直接下载）页面中，用Google Chrome浏览器的不同Page或Window打开，在输入框中分别输入不同的文字，再点击“Save”，然后分别刷新。每个Page或Window显示都是当前Page输入的内容，互不影响。关闭Page，再重新打开，上一次输入保存的内容已经没有了。</p><p>Local Storage的接口、用法与Session Storage一样，唯一不同的是：Local Storage保存的数据是持久性的。当前Page关闭（Page Session结束后），保存的数据依然存在。重新打开Page，上次保存的数据可以获取到。另外，Local Storage是全局性的，同时打开两个Page会共享一份存数据，在一个Page中修改数据，另一个Page中是可以感知到的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 通过localStorage直接引用key, 另一种写法，等价于：</span><br><span class="line">  // localStorage.getItem(&quot;pageLoadCount&quot;);</span><br><span class="line">  // localStorage.setItem(&quot;pageLoadCount&quot;, value);</span><br><span class="line">  if (!localStorage.pageLoadCount) &#123;</span><br><span class="line">     localStorage.pageLoadCount = 0;</span><br><span class="line">     localStorage.pageLoadCount = parseInt(localStorage.pageLoadCount) + 1;</span><br><span class="line">     document.getElementById(&apos;count&apos;).textContent = localStorage.pageLoadCount;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    You have viewed this page</span><br><span class="line">    &lt;span id=&quot;count&quot;&gt;an untold number of&lt;/span&gt;</span><br><span class="line">    time(s)</span><br><span class="line">&lt;/p&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure></p><p>将上面代码复制到local_storage.html的页面中，用浏览器打开，pageLoadCount的值是1；关闭Page重新打开，pageLoadCount的值是2。这是因为第一次的值已经保存了。用两个Page同时打开local_storage.html，并分别交替刷新，发现两个Page是共享一个pageLoadCount的。</p><p>分析：Dom Storage给Web提供了一种更录活的数据存储方式，存储空间更大（相对Cookies），用法也比较简单，方便存储服务器或本地的一些临时数据。</p><p>从Dom Storage提供的接口来看，Dom Storage适合存储比较简单的数据，如果要存储结构化的数据，可能要借助JSON了，将要存储的对象转为JSON字串。不太适合存储比较复杂或存储空间要求比较大的数据，也不适合存储静态的文件等。</p><p>在Android内嵌Webview中，需要通过Webview设置接口启用Dom Storage。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">WebSettings webSettings = myWebView.getSettings();</span><br><span class="line">webSettings.setDomStorageEnabled(true);&lt;br&gt;</span><br></pre></td></tr></table></figure></p><p>拿Android类比的话，Web的Dom Storage机制类似于Android的SharedPreference机制。</p><h3 id="3-Web-SQL-Database存储机制"><a href="#3-Web-SQL-Database存储机制" class="headerlink" title="3. Web SQL Database存储机制"></a>3. Web SQL Database存储机制</h3><p>HTML5也提供基于SQL的数据库存储机制，用于存储适合数据库的结构化数据。但根据官方的标准文档，这种存储机制不再推荐使用，将来也不再维护，而是推荐使用AppCache和IndexedDB，所以这里就不多做阐述了。</p><h3 id="4-Application-Cache机制"><a href="#4-Application-Cache机制" class="headerlink" title="4. Application Cache机制"></a>4. Application Cache机制</h3><p>Application Cache（简称AppCache）似乎是为支持Web App离线使用而开发的缓存机制。它的缓存机制类似于浏览器的缓存（Cache-Control和Last-Modified）机制，都是以文件为单位进行缓存，且文件有一定更新机制。但AppCache是对浏览器缓存机制的补充，不是替代。先拿W3C官方的一个例子，说下AppCache机制的用法与功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html manifest=<span class="string">"demo_html.appcache"</span>&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=<span class="string">"demo_time.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;p id=<span class="string">"timePara"</span>&gt;&lt;button onclick=<span class="string">"getDateTime()"</span>&gt;Get Date and Time&lt;/button&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;img src=<span class="string">"img_logo.gif"</span> width=<span class="string">"336"</span> height=<span class="string">"69"</span>&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        Try opening </span><br><span class="line">        &lt;a href=<span class="string">"tryhtml5_html_manifest.htm"</span> target=<span class="string">"_blank"</span>&gt;</span><br><span class="line">        this page&lt;/a&gt;</span><br><span class="line">        , <span class="keyword">then</span> go offline, and reload the page. </span><br><span class="line">        The script and the image should still work.</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>上面HTML文档，引用外部一个JS文件和一个GIF图片文件，在其HTML头中通过manifest属性引用了一个appcache结尾的文件。</p><p>我们在Google Chrome浏览器中打开这个HTML链接，JS功能正常，图片也显示正常。禁用网络，关闭浏览器重新打开这个链接，发现JS工作正常，图片也显示正常。当然也有可能是浏览缓存起的作用，我们可以在文件的浏览器缓存过期后，禁用网络再试，发现HTML页面也是正常的。</p><p>通过Google Chrome浏览器自带的工具，我们可以查看已经缓存的AppCache（分Host）。<br><img src="http://jingchao.xyz/blog/images/appcache.jpg" alt=""></p><p>上面截图中的缓存，就是我们刚才打开HTML的页面AppCache。从截图中看，HTML页面及HTML引用的JS、GIF图像文件都被缓存了；另外HTML头中manifest属性引用的appcache文件也缓存了。</p><p>AppCache的原理有两个关键点：manifest属性和manifest文件。</p><p>HTML在头中通过manifest属性引用manifest文件。manifest文件，就是上面以appcache结尾的文件，是一个普通文件文件，列出了需要缓存的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">demo.js</span><br><span class="line">img.gif</span><br></pre></td></tr></table></figure></p><p>上面截图中的manifest文件，就HTML代码引用的manifest文件。文件比较简单，第一行是关键字，第二、三行就是要缓存的文件路径（相对路径）。这只是最简单的manifest文件，完整的还包括其他关键字与内容。引用manifest文件的HTML和manifest文件中列出的要缓存的文件最终都会被浏览器缓存。</p><p>完整的manifest文件，包括三个Section，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 2012-02-21 v1.0.0</span><br><span class="line">/theme.css</span><br><span class="line">/logo.gif</span><br><span class="line">/main.js</span><br><span class="line">NETWORK:</span><br><span class="line">login.asp</span><br><span class="line">FALLBACK:</span><br><span class="line">/html/ /offline.html</span><br></pre></td></tr></table></figure></p><p>总的来说，浏览器在首次加载HTML文件时，会解析manifest属性，并读取manifest文件，获取CACHE MANIFEST下要缓存的文件列表，再对文件缓存。</p><p>AppCache的缓存文件，与浏览器的缓存文件分开存储的，还是一份？应该是分开的。因为AppCache在本地也有5MB（分Host）的空间限制。</p><p>AppCache在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新manifest文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查manifest文件有没有修改（byte by byte)，发现有修改，就会重新获取manifest文件，对CACHE MANIFEST下文件列表检查更新。manifest文件与缓存文件的检查更新也遵守浏览器缓存机制。</p><p>如用用户手动清了AppCache缓存，下次加载时，浏览器会重新生成缓存，也可算是一种缓存的更新。另外，Web App也可用代码实现缓存更新。</p><blockquote><br>分析：AppCache看起来是一种比较好的缓存方法，除了缓存静态资源文件外，也适合构建Web离线 App。在实际使用中有些需要注意的地方，有一些可以说是”坑“。<br>    1. 要更新缓存的文件，需要更新包含它的manifest文件，那怕只加一个空格。常用的方法，是修改manifest文件注释中的版本号。如：# 2012-02-21 v1.0.0。<br>    2.被缓存的文件，浏览器是先使用，再通过检查manifest文件是否有更新来更新缓存文件。这样缓存文件可能用的不是最新的版本。<br>    3. 在更新缓存过程中，如果有一个文件更新失败，则整个更新会失败。<br>    4. manifest和引用它的HTML要在相同Host。<br>    5. manifest文件中的文件列表，如果是相对路径，则是相对manifest文件的相对路径。<br>    6. manifest也有可能更新出错，导致缓存文件更新失败。<br>    7. 没有缓存的资源在已经缓存的HTML中不能加载，即使有网络。例如：<a href="http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-network/。" target="_blank" rel="noopener">http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-network/。</a><br>    8. manifest文件本身不能被缓存，且manifest文件的更新使用的是浏览器缓存机制。所以manifest文件的Cache-Control缓存时间不能设置太长。<br>另外，根据官方文档，AppCache已经不推荐使用了，标准也不会再支持。现在主流的浏览器都是还支持AppCache的，以后就不太确定了。</blockquote><p>在Android内嵌Webview中，需要通过Webview设置接口启用AppCache，同时还要设置缓存文件的存储路径，另外还可以设置缓存的空间大小。</p><h3 id="5-Indexed-Database"><a href="#5-Indexed-Database" class="headerlink" title="5. Indexed Database"></a>5. Indexed Database</h3><p>IndexedDB也是一种数据库的存储机制，但不同于已经不再支持的Web SQL Database。IndexedDB不是传统的关系数据库，可归为NoSQL数据库。IndexedDB又类似于Dom Storage的key-value的存储方式，但功能更强大，且存储空间更大。</p><p>IndexedDB存储数据是key-value的形式。Key是必需，且要唯一；Key可以自己定义，也可由系统自动生成。Value也是必需的，但Value非常灵活，可以是任何类型的对象。一般Value都是通过Key来存取的。</p><p>IndexedDB提供了一组API，可以进行数据存、取以及遍历。这些API都是异步的，操作的结果都是在回调中返回。</p><p>IndexedDB有个非常强大的功能，就是index（索引）。它可对Value对象中任何属性生成索引，然后可以基于索引进行Value对象的快速查询。</p><p>要生成索引或支持索引查询数据，需求在首次生成存储对象时，调用接口生成属性的索引。可以同时对对象的多个不同属性创建索引。如下面代码就对name和email两个属性都生成了索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var objectStore = thisDB.createObjectStore(&quot;people&quot;,&#123; autoIncrement:true &#125;)</span><br><span class="line">//first arg is name of index, second is the path (col)</span><br><span class="line">objectStore.createIndex(&quot;name&quot;,&quot;name&quot;, &#123;unique:false&#125;)</span><br><span class="line">objectStore.createIndex(&quot;email&quot;,&quot;email&quot;, &#123;unique:true&#125;)</span><br></pre></td></tr></table></figure></p><p>生成索引后，就可以基于索引进行数据的查询。Android在4.4开始加入对IndexedDB的支持，只需打开允许JS执行的开关就好了。</p><blockquote>分析：IndexedDB是一种灵活且功能强大的数据存储机制，它集合了Dom Storage和Web SQL Database的优点，用于存储大块或复杂结构的数据，提供更大的存储空间，使用起来也比较简单。可以作为Web SQL Database的替代。不太适合静态文件的缓存。<br>以key-value 的方式存取对象，可以是任何类型值或对象，包括二进制。<br>可以对对象任何属性生成索引，方便查询。<br>较大的存储空间，默认推荐250MB（分Host），比Dom Storage的5MB要大得多。<br>通过数据库的事务（tranction）机制进行数据操作，保证数据一致性。<br>异步的 API 调用，避免造成等待而影响体验。</blockquote><h3 id="6-File-System-API"><a href="#6-File-System-API" class="headerlink" title="6. File System API"></a>6. File System API</h3><p>File System API是HTML5新加入的存储机制。它为Web App提供了一个虚拟的文件系统，就像Native App访问本地文件系统一样。由于安全性的考虑，这个虚拟文件系统有一定的限制。Web App在虚拟的文件系统中，可以进行文件（夹）的创建、读、写、删除、遍历等操作。</p><p>File System API也是一种可选的缓存机制，和前面的SQL Database、IndexedDB 和App Cache等一样。File System API有自己的一些特定的优势：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以满足大块的二进制数据（large binary blobs）存储需求。</span><br><span class="line">可以通过预加载资源文件来提高性能。</span><br><span class="line">可以直接编辑文件。</span><br></pre></td></tr></table></figure></p><p>浏览器给虚拟文件系统提供了两种类型的存储空间：临时的和持久性的。临时的存储空间是由浏览器自动分配的，但可能被浏览器回收；持久性的存储空间需要显示的申请，申请时浏览器会给用户一提示，需要用户进行确认。持久性的存储空间是Web App自己管理，浏览器不会回收，也不会清除内容。持久性的存储空间大小是通过配额来管理的，首次申请时会一个初始的配额，配额用完需要再次申请。</p><p>虚拟的文件系统是运行在沙盒中，不同Web App的虚拟文件系统是互相隔离的，虚拟文件系统与本地文件系统也是隔离的。</p><h2 id="移动端Web加载性能（缓存）优化"><a href="#移动端Web加载性能（缓存）优化" class="headerlink" title="移动端Web加载性能（缓存）优化"></a>移动端Web加载性能（缓存）优化</h2><p>分析完HTML5提供的各种缓存机制，回到移动端（针对Android，可能也适用于iOS）的场景。现在Android App（包括手Q和WX）大多嵌入了Webview的组件（系统Webview或QQ浏览器的X5组件），通过内嵌Webview来加载一些HTML5的运营活动页面或资讯页。这样可充分发挥Web前端的优势：快速开发、发布，灵活上下线。但Webview也有一些不可忽视的问题，比较突出的就是加载相对较慢，会相对消耗较多流量。</p><p>通过对一些HTML5页面进行调试及抓包发现，每次加载一个HTML5页面，都会有较多的请求。除了HTML主URL自身的请求外，HTML外部引用的JS、CSS、字体文件、图片都是一个独立的HTTP请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化 Web的加载性能。</p><table><thead><tr><th>缓存机制</th><th style="text-align:center">优势</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td>浏览器</td><td style="text-align:center">HTTP协议层支持</td><td style="text-align:center">静态文件缓存</td></tr><tr><td>Dom Storage</td><td style="text-align:center">较大存储空间，简单</td><td style="text-align:center">临时简单数据存储，Cookie扩展 </td></tr><tr><td>Web SQL Database</td><td style="text-align:center">存储复杂数据结构</td><td style="text-align:center">不推荐，IndexDB替代</td></tr><tr><td>AppCache</td><td style="text-align:center">构建离线App</td><td style="text-align:center">不推荐，离线App，静态文件缓存 </td></tr><tr><td>IndexDB</td><td style="text-align:center">存储任何类型数据，索引</td><td style="text-align:center">结构，关系复杂的数据结构  </td></tr><tr><td>File System API</td><td style="text-align:center">支持文件系统操作</td><td style="text-align:center">数据适合以文件进行管理场景</td></tr></tbody></table><p>结论：综合各种缓存机制比较，对于静态文件，如JS、CSS、字体、图片等，适合通过浏览器缓存机制来进行缓存，通过缓存文件可大幅提升Web的加载速度，且节省流量。但也有一些不足：缓存文件需要首次加载后才会产生；浏览器缓存的存储空间有限，缓存有被清除的可能；缓存的文件没有校验。要解决这些不足，可以参考手Q的离线包，它有效的解决了这些不足。</p><p>对于Web在本地或服务器获取的数据，可以通过Dom Storage和IndexedDB进行缓存。也在一定程度上减少和Server的交互，提高加载速度，同时节省流量。</p><p><strong>@转载请注明出处</strong><br>原文链接：<a href="https://www.csdn.net/article/2015-12-16/2826489/1" target="_blank" rel="noopener">https://www.csdn.net/article/2015-12-16/2826489/1</a></p>]]></content>
      
      <categories>
          
          <category> cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web缓存机制</title>
      <link href="/blog/2018/04/03/Web%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/blog/2018/04/03/Web%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。</p><p><strong>web缓存的作用</strong><br>减少网络带宽消耗（当Web缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。）<br>降低服务器压力（给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。）<br>减少网络延迟，加开页面打开速度。</p><p>缓存机制是web开发的重要知识点，也是系统优化的重要方向。在前端开发中，缓存有利于加快网页的加载速度，同时缓存能够被反复利用，所以可以减少流量和带宽的开销。这里将系统的介绍在Web开发中的缓存方式，还会涉及到部分操作系统缓存知识。本文会重点介绍浏览器端的缓存机制也就是HTTP缓存，其机制是根据HTTP报文的缓存标识进行的。在分析缓存机制之前，先介绍下浏览器的HTTP报文。HTTP报文分为两种：</p><ul><li><strong>HTTP请求(Request)报文</strong>，报文格式为：<strong>请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)</strong>，如下图</li></ul><p><img src="http://jingchao.xyz/blog/images/Request.jpg" alt=""><br><img src="http://jingchao.xyz/blog/images/Request-header.jpg" alt=""></p><ul><li><strong>HTTP响应(Response)报文</strong>，报文格式为：<strong>状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体</strong>，如下图</li></ul><p><img src="http://jingchao.xyz/blog/images/Response-header.jpg" alt=""></p><p>注：<strong>通用信息头</strong>指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；<strong>实体头</strong>则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。</p><h3 id="Web开发中的不同缓存"><a href="#Web开发中的不同缓存" class="headerlink" title="Web开发中的不同缓存"></a>Web开发中的不同缓存</h3><h4 id="1-数据库缓存"><a href="#1-数据库缓存" class="headerlink" title="1. 数据库缓存"></a>1. 数据库缓存</h4><p>   我们可能听说过memcached，它就是一种数据库层面的缓存方案。类似的还有Redis缓存，也是一种基于内存的数据库，它的功能更加强大，并且支持备份和数据持久化。数据库缓存是指，当web应用的关系比较复杂，数据库中的表很多的时候，如果频繁进行 数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。</p><h4 id="2-CDN缓存（服务端缓存）"><a href="#2-CDN缓存（服务端缓存）" class="headerlink" title="2. CDN缓存（服务端缓存）"></a>2. CDN缓存（服务端缓存）</h4><p>  CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能，可以归属为全局负载均衡或者说是四层<a href="http://jingchao.xyz/blog/2018/05/06/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%80%E8%BF%B0">负载均衡</a>。通常情况下，浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，浏览器和服务器之间的缓存机制，在这种架构下同样适用。一般对于网站上的静态资源文件可以采用CDN分发，可以加快网站访问速度。</p><h4 id="3-代理服务器缓存（服务端缓存）"><a href="#3-代理服务器缓存（服务端缓存）" class="headerlink" title="3. 代理服务器缓存（服务端缓存）"></a>3. 代理服务器缓存（服务端缓存）</h4><p>   代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大，可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。也可以将其归为七层负载均衡，但需要两次TCP握手连接，然功能更多，如会话保持，图片压缩，防盗链等。   </p><h4 id="4-浏览器缓存"><a href="#4-浏览器缓存" class="headerlink" title="4. 浏览器缓存"></a>4. 浏览器缓存</h4><p>   每个浏览器都实现了 HTTP 缓存，我们通过浏览器使用HTTP协议与服务器交互的时候，浏览器就会根据一套与服务器约定的规则进行缓存工作。最新的HTML5协议新增了离线缓存属性，对缓存机制进一步的优化，可以达到，实现图片存在客户端，跨域共享客户端缓存，做到真正的离线访问WEB应用，实现客户端的数据库。</p><h4 id="5-应用层缓存"><a href="#5-应用层缓存" class="headerlink" title="5. 应用层缓存"></a>5. 应用层缓存</h4><p>   应用层缓存是指我们在代码层面上做的缓存。通过代码逻辑，把曾经请求过的数据或资源等，缓存起来，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率，再次需要数据时通过逻辑上的处理选择可用的缓存的数据。h5新增的storage就可以归属到应用层缓存。</p><h3 id="操作系统缓存"><a href="#操作系统缓存" class="headerlink" title="操作系统缓存"></a>操作系统缓存</h3><p>首先关于存储的概念有以下几种方式：<br><strong>cache</strong>：缓存为了让从DB/磁盘拿出来的东西放到缓存（放于内存）；<br><strong>磁盘文件</strong>：本地存储的视频，图片，计算机里面的文件；<br><strong>数据库</strong>：系统项目中的数据存储；<br><strong>内存</strong>：计算机中所有的程序运行都是在内存中，所以内存对计算机的性能影响很大。<br>在操作系统缓存机制中，有buffer和cache两种方式，它们都是占用内存（buffer记录元数据，权限属性等，cache缓存文件）。I/O过程本身的延迟，以及高速设备与低速设备交互时的等待延迟，Buffer和Cache就是从这两个方向上产生的优化提高系统性能的方式。</p><p><strong>buffer缓存</strong>是块设备的读写缓冲区，buffer是I/O缓存，用于内存和硬盘（或其他 I/O设备）之间的数据交换的速度而设计的。通常在写一个非常大的文件，文件会被分成一个个的小block块，往内存上写，然后再写入磁盘,这样的效率会很慢。这种情况下，内存就会攒足一次大的block块再写入磁盘，这样就不会有第一种情况里的延迟，这就是buffer。buffer的主要目的是进行流量整形，把突发的大数量较小规模读写整理成平稳的较大规模的I/O，以<strong>减少响应次数</strong>（比如从网上下载视频，不能下一点点数据就写入硬盘，而是达到一定量的数据一整块写，不然硬盘负荷太大）。</p><p><strong>Cache缓存</strong>是高速缓存，用于cpu与内存之间的缓冲，是系统两端处理速度不匹配时的一种折衷策略。主要原因是cpu与memory，由于cpu快，memory跟不上，且有些值使用次数多，所以放入cache中，主要目的是使用内存来缓存可能被再次访问的数据，可以保持冗余的、被重复计算的、计算后的数据（buffer不行）。Cache是经常被使用在I/O请求上，来提高系统性能。如果cache的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO必会非常小。</p><h3 id="Web中浏览器缓存"><a href="#Web中浏览器缓存" class="headerlink" title="Web中浏览器缓存"></a>Web中浏览器缓存</h3><p>浏览器端的缓存分为强缓存（Expires和<strong>Cache-Control</strong>—优先级高，直接使用本地缓存资源）和协商缓存（Last-Modified / If-Modified-Since和 <strong>Etag / If-None-Match</strong>—优先级高，先发送请求到服务器端确认资源更改来确认是否使用缓存）。</p><h3 id="1-强缓存"><a href="#1-强缓存" class="headerlink" title="1. 强缓存"></a>1. 强缓存</h3><p>在HTTP/1.0使用的是Expires字段，该字段表示缓存到期时间，即有效时间+当时服务器的时间，然后将这个时间设置在header中返回给服务器。如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。该时间是一个绝对时间，由于服务端和浏览器端时间不一致，或者用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，因此更推荐另一种强缓存方式。Expires字段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Thu, 15 Mar 2018 09:09:09 GMT</span><br></pre></td></tr></table></figure></p><p>在HTTP/1.1中，增加了一个字段Cache-Control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求，主要是利用该字段的<strong>max-age</strong>值来进行判断，它是一个相对值，资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则资源失效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=9590000</span><br></pre></td></tr></table></figure></p><p>Cache-Control除了max-age字段外，还有几个比较常用的字段设置值：</p><blockquote><strong>no-cache</strong>：不用本地缓存，使用协商缓存，先发送请求到服务器根据响应确认资源是否被更改，如果之前的响应中存在ETag或者Last-Modified，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。<br><br><strong>no-store</strong>：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。<br><br><strong>public</strong>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。<br><br><strong>private</strong>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</blockquote><p><strong>注意</strong>：如果cache-control与expires同时存在的话，cache-control的优先级高于expires</p><h3 id="2-协商缓存"><a href="#2-协商缓存" class="headerlink" title="2. 协商缓存"></a>2. 协商缓存</h3><p>协商缓存（Last-Modified或者Etag）的过程是先从缓存中获取对应的数据标识，然后向服务器发送请求，确认数据是否更新，如果更新，则返回新数据和新缓存。反之，则返回304状态码，告知客户端缓存未更新，可继续使用，这正好弥补了一些强缓存的缺陷，协商缓存主要应用于一些时常需要动态更新的资源文件。协商缓存在协议里的字段是Last-Modified或者Etag，这两个字段都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。</p><p>Last-Modified/If-Modified-Since具体过程：</p><blockquote>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间<br><br>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值<br><br>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header<br><br>浏览器收到304的响应后，就会从缓存中加载资源<br><br>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值</blockquote><p>Etag/If-None-Match</p><p>Etag字段值是由服务器生成的每个资源的唯一标识字符串（一般都是hash生成的），只要资源内容有变化这个值就会改变,其判断过程与Last-Modified类似，与它不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，响应头还会把这个ETag返回，即使这个ETag跟之前的没有变化。</p><p>Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，之所以在HTTP1.1中新增Etag主要为了解决几个Last-Modified的问题：</p><blockquote>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；<br><br>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；<br><br>某些服务器不能精确的得到文件的最后修改时间。<br><br>这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。</blockquote><p><strong>注意</strong>：Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p><h4 id="用户浏览器行为对缓存的影响"><a href="#用户浏览器行为对缓存的影响" class="headerlink" title="用户浏览器行为对缓存的影响"></a>用户浏览器行为对缓存的影响</h4><p>刷新网页 =&gt; 如果缓存没有失效，浏览器会直接使用缓存；反之，则向服务器请求数据<br>手动刷新（F5） =&gt; 浏览器会认为缓存失效，在请求服务器时加上Cache-Control: max-age=0字段，然后询问服务器数据是否更新。<br>强制刷新（Ctrl + F5） =&gt; 浏览器会直接忽略缓存，在请求服务器时加上Cache-Control: no-cache字段，然后重新向服务器拉取文件。<br>更多用户行为可以用如下表格进行表示：</p><table><thead><tr><th>用户行为</th><th style="text-align:center">Expires / Cache-Control</th><th style="text-align:center">Last-Modified / Etag</th></tr></thead><tbody><tr><td>地址栏回车</td><td style="text-align:center">有效</td><td style="text-align:center">有效 </td></tr><tr><td>页面链接跳转</td><td style="text-align:center">有效</td><td style="text-align:center">有效 </td></tr><tr><td>新窗口</td><td style="text-align:center">有效</td><td style="text-align:center">有效</td></tr><tr><td>前进后退</td><td style="text-align:center">有效</td><td style="text-align:center">有效 </td></tr><tr><td>F5刷新</td><td style="text-align:center">无效</td><td style="text-align:center">有效  </td></tr><tr><td>Ctrl+F5刷新</td><td style="text-align:center">无效</td><td style="text-align:center">无效</td></tr></tbody></table><h4 id="移动端的缓存处理"><a href="#移动端的缓存处理" class="headerlink" title="移动端的缓存处理"></a>移动端的缓存处理</h4><p>Cache-Control和Last-Modified一般用在静态资源文件上，如JS、CSS和一些图像文件。通过设置资源文件缓存属性，对提高资源文件加载速度，节省流量很有意义，特别是移动网络环境。但问题是：缓存有效时长应该如何设置，如果太短，就起不到缓存的使用，设置的太长，在服务端资源文件有更新时，浏览器有缓存，则不能及时取到最新的文件。</p><p>对于移动端的缓存，任何一个网络请求的增加，加载消耗时间都是比较大的（尤其弱网环境下）。对于强缓存只要缓存不到期，是不会向服务器发送请求，但是如果是协商缓存的情况下，304的问题就比较大，它会造成无用的服务器请求，导致网络的延时。Last-Modified需要向服务器发起查询请求，才能知道资源文件有没有更新，虽然服务器可能返回304告诉没有更新，但也还有一个请求的过程。对于移动网络，这个请求可能是比较耗时的，有一种说法叫“消灭304”，指的就是优化掉304的请求。</p><p>通过抓包可以发现，带if-Modified-Since字段的请求，如果服务器回包304，回包会带有Cache-Control:max-age或Expires字段，文件的强缓存有效时间会更新，就是文件强缓存会重新有效。304回包后如果再请求，则又可以直接使用本地缓存文件了，不用再向服务器发送请求查询文件是否更新了，除非新的强缓存资源文件时间再次过期。</p><p>另外，Cache-Control与Last-Modified是浏览器内核的机制，一般都是标准的实现，不能更改或设置。以QQ浏览器的X5为例，Cache-Control与Last-Modified缓存不能禁用，缓存容量是12MB，不分Host，过期的缓存会最先被清除。如果都没过期，应该优先清最早的缓存或最快到期的或文件大小最大的，过期缓存也有可能还是有效的，清除缓存会导致资源文件的重新拉取。还有，浏览器，如X5，在使用缓存文件时，是没有对缓存文件内容进行校验的，这样缓存文件内容被修改的可能。</p><p>分析发现，浏览器的缓存机制还不是非常完美的缓存机制。完美的缓存机制应该是这样的：</p><blockquote>缓存文件没更新，尽可能使用缓存，不用和服务器交互；<br>缓存文件有更新时，第一时间能使用到新的文件；<br>缓存的文件要保持完整性，不使用被修改过的缓存文件；<br>缓存的容量大小要能设置或控制，缓存文件不能因为存储空间限制或过期被清除。 以X5为例，第1、2条不能同时满足，第3、4条都不能满足。</blockquote><p>在实际应用中，为了解决Cache-Control缓存时长不好设置的问题，以及为了“消灭304”，采用的方式是：</p><blockquote>1. 在要缓存的资源文件名中加上版本号或文件MD5值字串，如common.d5d02a02.js、common.v1.js，同时设置Cache-Control:max-age=31536000，也就是一年。在一年时间内，资源文件如果本地有缓存，就会使用缓存,这样就可以避免协商缓存的304的回包现象。<br>2. 如果资源文件有修改，则更新文件内容，同时修改资源文件名，如common.v2.js，html页面也会引用新的资源文件名，实现静态资源非覆盖式更新。<br><br>通过这种方式，实现了：缓存文件没有更新，则使用缓存；缓存文件有更新，则第一时间使用最新文件的目的。即上面说的第1、2条。第3、4条由于浏览器内部机制，目前还无法满足。</blockquote><h4 id="浏览器缓存回忆"><a href="#浏览器缓存回忆" class="headerlink" title="浏览器缓存回忆"></a>浏览器缓存回忆</h4><p>浏览器端强缓存优于协商缓存进行，先判断强缓存资源是否过期，若强缓存（Expires和<strong>Cache-Control</strong>）生效则直接使用本地浏览器缓存，若失效则进行协商缓存（Last-Modified / If-Modified-Since和 <strong>Etag</strong> / If-None-Match）发送请求到服务端，协商缓存由服务器响应和本地进行对比验证决定资源是否有效，若协商缓存失效，那么代表该请求的缓存失效，择重新发送请求获取响应结果下载资源，再存入浏览器缓存中，生效则返回304状态码，继续使用缓存，整个浏览器缓存主要过程如下图：</p><p><img src="http://jingchao.xyz/blog/images/all.jpg" alt=""></p><p><strong>@转载请注明出处</strong></p>]]></content>
      
      <categories>
          
          <category> cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo迁移</title>
      <link href="/blog/2018/03/21/hexo%E8%BF%81%E7%A7%BB/"/>
      <url>/blog/2018/03/21/hexo%E8%BF%81%E7%A7%BB/</url>
      <content type="html"><![CDATA[<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="一、安装必要软件"><a href="#一、安装必要软件" class="headerlink" title="一、安装必要软件"></a>一、安装必要软件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装 Git 客户端</span><br><span class="line">安装 node JS</span><br></pre></td></tr></table></figure><h3 id="二、在-github-官网添加新电脑产生的密钥"><a href="#二、在-github-官网添加新电脑产生的密钥" class="headerlink" title="二、在 github 官网添加新电脑产生的密钥"></a>二、在 github 官网添加新电脑产生的密钥</h3><h3 id="三、源文件拷贝"><a href="#三、源文件拷贝" class="headerlink" title="三、源文件拷贝"></a>三、源文件拷贝</h3><p>将原来电脑上个人博客目录下必要文件拷贝到新电脑上（比如D:/Blog目录下），注意无需拷贝全部，只拷如下几个文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">package.json</span><br><span class="line">scaffolds/</span><br><span class="line"><span class="built_in">source</span>/</span><br><span class="line">themes/</span><br></pre></td></tr></table></figure></p><h3 id="四、安装-hexo"><a href="#四、安装-hexo" class="headerlink" title="四、安装 hexo"></a>四、安装 hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 cmd 下输入指令安装 hexo：npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="五、进入-D-Blog-目录（拷贝到新电脑的目录），安装相关模块"><a href="#五、进入-D-Blog-目录（拷贝到新电脑的目录），安装相关模块" class="headerlink" title="五、进入 D:/Blog 目录（拷贝到新电脑的目录），安装相关模块"></a>五、进入 D:/Blog 目录（拷贝到新电脑的目录），安装相关模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save  // 文章部署到 git 的模块</span><br><span class="line">npm install hexo-generator-feed --save  // 建立 RSS 订阅（选择安装）</span><br><span class="line">npm install hexo-generator-sitemap --save // 建立站点地图（选择安装）</span><br></pre></td></tr></table></figure><h3 id="六、部署发布文章"><a href="#六、部署发布文章" class="headerlink" title="六、部署发布文章"></a>六、部署发布文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   // 清除缓存 网页正常情况下可以忽略此条命令</span><br><span class="line">hexo g       // 生成静态网页</span><br><span class="line">hexo d       // 开始部署</span><br></pre></td></tr></table></figure><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>具体的思路是：在生成的已经推到github上的hexo静态代码出建立一个分支，利用这个分支来管理自己hexo的源文件。如果能在刚刚配置hexo的时候就想好以后的迁移的问题就太好了，可以省掉很多麻烦。</p><p>具体的操作：<br>克隆gitHub上面生成的静态文件到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/yourname/hexo-test.github.io.git</span><br></pre></td></tr></table></figure></p><p>把克隆到本地的文件除了git的文件都删掉，找不到git的文件的话就到删了吧。不要用hexo init初始化。</p><p>将之前使用hexo写博客时候的整个目录（所有文件）搬过来。把该忽略的文件忽略了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure></p><p>创建一个叫hexo的分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hexo</span><br></pre></td></tr></table></figure></p><p>提交复制过来的文件到暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br></pre></td></tr></table></figure></p><p>提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;新建分支源文件&quot;</span><br></pre></td></tr></table></figure></p><p>推送分支到github<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin hexo</span><br></pre></td></tr></table></figure></p><p>到这里基本上就搞定了，以后再推就可以直接git push了，hexo的操作跟以前一样。</p><p>今后无论什么时候想要在其他电脑上面用hexo写博客，就直接把创建的分支克隆下来，npm install安装依赖之后就可以用了。</p><p>克隆分支的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b hexo https://github.com/yourname/hexo-test.github.io.git</span><br></pre></td></tr></table></figure></p><p>因为上面创建的是一个名字叫hexo的分支，所以这里-b后面的是hexo，再把后面的gitHub的地址换成你自己的hexo博客的地址就可以了。</p><p>这样完了以后，每次写完博客发布之后不要忘了还要git push把源文件推到分支上。</p><p>原文链接：<a href="https://blog.csdn.net/lvonve/article/details/79587321" target="_blank" rel="noopener">https://blog.csdn.net/lvonve/article/details/79587321</a><br>原文链接：<a href="https://www.jianshu.com/p/beb8d611340a" target="_blank" rel="noopener">https://www.jianshu.com/p/beb8d611340a</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hexo</title>
      <link href="/blog/2018/01/13/hexo/"/>
      <url>/blog/2018/01/13/hexo/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
