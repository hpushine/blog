<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>git命令大全</title>
      <link href="/blog/2018/06/06/Git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/blog/2018/06/06/Git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><!-- TOC --><ul><li><a href="#配置">配置</a></li><li><a href="#修改项目中的个人信息">修改项目中的个人信息</a><ul><li><a href="#配置自动换行">配置自动换行</a></li></ul></li><li><a href="#常见使用场景">常见使用场景</a><ul><li><a href="#创建ssh密钥">创建SSH密钥</a></li><li><a href="#多账号ssh配置">多账号ssh配置</a></li><li><a href="#免密码登录远程服务器">免密码登录远程服务器</a></li><li><a href="#https协议下提交代码免密码">https协议下提交代码免密码</a></li><li><a href="#文件推向3个git库">文件推向3个git库</a></li><li><a href="#修改远程仓库地址">修改远程仓库地址</a></li><li><a href="#撤销远程记录">撤销远程记录</a></li><li><a href="#放弃本地的文件修改">放弃本地的文件修改</a></li><li><a href="#最简单放弃本地修改内容">最简单放弃本地修改内容</a></li><li><a href="#回滚到某个commit提交">回滚到某个commit提交</a></li><li><a href="#回退到某一个版本">回退到某一个版本</a></li><li><a href="#去掉某个commit">去掉某个commit</a></li><li><a href="#新建一个空分支">新建一个空分支</a></li><li><a href="#合并多个commit">合并多个commit</a></li><li><a href="#修改远程commit记录">修改远程Commit记录</a></li><li><a href="#添加忽略文件">添加忽略文件</a></li><li><a href="#利用commit关闭一个issue">利用commit关闭一个issue</a></li><li><a href="#同步fork的上游仓库">同步fork的上游仓库</a></li><li><a href="#批量修改历史commit中的名字和邮箱">批量修改历史commit中的名字和邮箱</a></li><li><a href="#查看某个文件历史">查看某个文件历史</a></li><li><a href="#查看git仓库中最近修改的分支">查看git仓库中最近修改的分支</a></li><li><a href="#打造自己的git命令">打造自己的git命令</a></li><li><a href="#中文乱码的解决方案">中文乱码的解决方案</a></li></ul></li><li><a href="#新建仓库">新建仓库</a><ul><li><a href="#init">init</a></li><li><a href="#status">status</a></li><li><a href="#add">add</a></li><li><a href="#commit">commit</a></li><li><a href="#remote">remote</a></li><li><a href="#push">push</a></li></ul></li><li><a href="#clone">clone</a></li><li><a href="#本地">本地</a><ul><li><a href="#help">help</a></li><li><a href="#add-1">add</a></li><li><a href="#rm">rm</a></li><li><a href="#commit-1">commit</a></li><li><a href="#reset">reset</a></li><li><a href="#revert">revert</a></li><li><a href="#checkout">checkout</a></li><li><a href="#diff">diff</a></li><li><a href="#stash">stash</a></li><li><a href="#merge">merge</a></li><li><a href="#cherry-pick">cherry-pick</a></li><li><a href="#rebase">rebase</a></li></ul></li><li><a href="#分支branch">分支branch</a><ul><li><a href="#删除">删除</a></li><li><a href="#提交">提交</a></li><li><a href="#拉取">拉取</a></li><li><a href="#分支合并">分支合并</a></li><li><a href="#重命名">重命名</a></li><li><a href="#查看">查看</a></li><li><a href="#新建">新建</a></li><li><a href="#连接">连接</a></li><li><a href="#分支切换">分支切换</a></li></ul></li><li><a href="#远端">远端</a></li><li><a href="#submodule">submodule</a></li><li><a href="#删除文件">删除文件</a></li><li><a href="#remote-1">remote</a></li><li><a href="#标签tag">标签tag</a></li><li><a href="#日志log">日志log</a></li><li><a href="#重写历史">重写历史</a><ul><li><a href="#删除仓库">删除仓库</a></li></ul></li><li><a href="#其它">其它</a></li><li><a href="#报错问题解决">报错问题解决</a></li><li><a href="#参考资料">参考资料</a></li></ul><!-- /TOC --><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先是配置帐号信息 <code>ssh -T git@github.com</code> 测试。</p><h2 id="修改项目中的个人信息"><a href="#修改项目中的个人信息" class="headerlink" title="修改项目中的个人信息"></a>修改项目中的个人信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> config <span class="comment"># 获取帮助信息，查看修改个人信息的参数  </span></span><br><span class="line">git config --global user.name <span class="string">"小弟调调"</span>           <span class="comment"># 修改全局名字</span></span><br><span class="line">git config --global user.email <span class="string">"wowohoo@qq.com"</span>  <span class="comment"># 修改全局邮箱</span></span><br><span class="line">git config --list         <span class="comment"># 查看配置的信息</span></span><br></pre></td></tr></table></figure><h3 id="配置自动换行"><a href="#配置自动换行" class="headerlink" title="配置自动换行"></a>配置自动换行</h3><p>自动转换坑太大，提交到git是自动将换行符转换为lf </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf input</span><br></pre></td></tr></table></figure><h2 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h2><h3 id="创建SSH密钥"><a href="#创建SSH密钥" class="headerlink" title="创建SSH密钥"></a>创建SSH密钥</h3><p>这个密钥用来跟 github 通信，在本地终端里生成然后上传到 github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">'wowohoo@qq.com'</span> <span class="comment"># 生成密钥  </span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"wowohoo@qq.com"</span> -f ~/.ssh/ww_rsa <span class="comment"># 指定生成目录文件名字</span></span><br><span class="line">ssh -T git@github.com <span class="comment"># 测试是否成功</span></span><br></pre></td></tr></table></figure><h3 id="多账号ssh配置"><a href="#多账号ssh配置" class="headerlink" title="多账号ssh配置"></a>多账号ssh配置</h3><p><strong>1.生成指定名字的密钥</strong></p><p><code>ssh-keygen -t rsa -C &quot;邮箱地址&quot; -f ~/.ssh/jslite_rsa</code><br>会生成 <code>jslite_rsa</code> 和 <code>jslite_rsa.pub</code> 这两个文件  </p><p><strong>2.密钥复制到托管平台上</strong></p><p><code>vim ~/.ssh/jslite_rsa.pub</code><br>打开公钥文件 <code>jslite_rsa.pub</code> ，并把内容复制至代码托管平台上   </p><p><strong>3.修改config文件</strong></p><p><code>vim ~/.ssh/config</code> #修改config文件，如果没有创建 <code>config</code>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Host jslite.github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  User git</span><br><span class="line">  IdentityFile ~/.ssh/jslite_rsa</span><br><span class="line"></span><br><span class="line">Host work.github.com</span><br><span class="line">  HostName github.com</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Port 服务器open-ssh端口（默认：22,默认时一般不写此行）</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> PreferredAuthentications 配置登录时用什么权限认证 </span></span><br><span class="line"><span class="meta">  #</span><span class="bash">                          publickey|password publickey|keyboard-interactive等</span></span><br><span class="line">  User git</span><br><span class="line">  IdentityFile ~/.ssh/work_rsa</span><br></pre></td></tr></table></figure><ul><li><code>Host</code> 这里是个别名可以随便命名</li><li><code>HostName</code> 一般是网站如：<a href="mailto:`git@ss.github.com" target="_blank" rel="noopener">`git@ss.github.com</a>:username/repo.git<code>填写</code>github.com`</li><li><code>User</code> 通常填写<code>git</code></li><li><code>IdentityFile</code> 使用的公钥文件地址</li></ul><p><strong>4.测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@jslite.github.com  <span class="comment"># `@`后面跟上定义的Host  </span></span><br><span class="line">ssh -T work.github.com        <span class="comment"># 通过别名测试</span></span><br><span class="line">ssh -i ~/公钥文件地址 Host别名  <span class="comment"># 如 ssh -i ~/.ssh/work_rsa work.github.com</span></span><br></pre></td></tr></table></figure><p><strong>5.使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原来的写法</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:&lt;jslite的用户名&gt;/learngit.git</span><br><span class="line"><span class="comment"># 现在的写法</span></span><br><span class="line">git <span class="built_in">clone</span> git@jslite.github.com:&lt;jslite的用户名&gt;/learngit.git</span><br><span class="line">git <span class="built_in">clone</span> git@work.github.com:&lt;work的用户名&gt;/learngit.git</span><br></pre></td></tr></table></figure><p><strong>5.注意</strong></p><p>如果你修改了id_rsa的名字，你需要将ssh key添加到SSH agent中，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/jslite_rsa</span><br><span class="line">ssh-add -l  <span class="comment"># 查看所有的key</span></span><br><span class="line">ssh-add -D  <span class="comment"># 删除所有的key</span></span><br><span class="line">ssh-add -d  ~/.ssh/jslite_rsa <span class="comment"># 删除指定的key</span></span><br></pre></td></tr></table></figure><h3 id="免密码登录远程服务器"><a href="#免密码登录远程服务器" class="headerlink" title="免密码登录远程服务器"></a>免密码登录远程服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -P <span class="string">''</span> -f ~/.ssh/aliyunserver.key</span><br><span class="line">$ ssh-copy-id -i ~/.ssh/aliyunserver.key.pub root@192.168.182.112 <span class="comment"># 这里需要输入密码一次</span></span><br></pre></td></tr></table></figure><p>编辑 <code>~/.ssh/config</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host aliyun1</span><br><span class="line">  HostName 192.168.182.112</span><br><span class="line">  User root</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/aliyunserver.key</span><br></pre></td></tr></table></figure><p>上面配置完了，可以通过命令登录，不需要输入IP地址和密码 <code>ssh aliyun1</code></p><h3 id="https协议下提交代码免密码"><a href="#https协议下提交代码免密码" class="headerlink" title="https协议下提交代码免密码"></a>https协议下提交代码免密码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/username/rep.git</span><br></pre></td></tr></table></figure><p>通过上面方式克隆可能需要密码，解决办法：进入当前克隆的项目 <code>vi rep/.git/config</code> 编辑 <code>config</code>, 按照下面方式修改，你就可以提交代码不用输入密码了。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = true</span><br><span class="line">bare = false</span><br><span class="line">logallrefupdates = true</span><br><span class="line">ignorecase = true</span><br><span class="line">precomposeunicode = true</span><br><span class="line">[remote "origin"]</span><br><span class="line"><span class="deletion">-url = https://github.com/username/rep.git</span></span><br><span class="line"><span class="addition">+url = https://用户名:密码@github.com/username/rep.git</span></span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch "master"]</span><br><span class="line">remote = origin</span><br><span class="line">merge = refs/heads/master</span><br></pre></td></tr></table></figure><h3 id="文件推向3个git库"><a href="#文件推向3个git库" class="headerlink" title="文件推向3个git库"></a>文件推向3个git库</h3><p><strong>1. 增加3个远程库地址</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/JSLite/JSLite.git  </span><br><span class="line">git remote set-url --add origin https://gitlab.com/wang/JSLite.js.git  </span><br><span class="line">git remote set-url --add origin https://oschina.net/wang/JSLite.js.git</span><br></pre></td></tr></table></figure><p><strong>2. 删除其中一个 set-url 地址</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usage: git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]</span><br><span class="line">   or: git remote set-url --add &lt;name&gt; &lt;newurl&gt;</span><br><span class="line">   or: git remote set-url --delete &lt;name&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure><p><code>git remote set-url --delete origin https://oschina.net/wang/JSLite.js.git</code></p><p><strong>3.推送代码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br><span class="line">git push -f origin master  <span class="comment"># 强制推送</span></span><br></pre></td></tr></table></figure><p><strong>4.拉代码</strong></p><p>只能拉取 <code>origin</code> 里的一个url地址，这个fetch-url<br>默认为你添加的到 <code>origin</code>的第一个地址  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master   </span><br><span class="line">git pull --all # 获取远程所有内容包括tag  </span><br><span class="line">git pull origin next:master # 取回origin主机的next分支，与本地的master分支合并  </span><br><span class="line">git pull origin next # 远程分支是与当前分支合并  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面一条命令等同于下面两条命令   </span></span><br><span class="line">git fetch origin  </span><br><span class="line">git merge origin/next</span><br></pre></td></tr></table></figure><p>如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。<br>但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull -p</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于下面的命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch --prune origin </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch -p</span></span><br></pre></td></tr></table></figure><p><strong>5.更改pull</strong></p><p>只需要更改config文件里，那三个url的顺序即可，fetch-url会直接对应排行第一的那个utl连接。    </p><h3 id="修改远程仓库地址"><a href="#修改远程仓库地址" class="headerlink" title="修改远程仓库地址"></a>修改远程仓库地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin  <span class="comment"># 删除该远程路径  </span></span><br><span class="line">git remote add origin git@jslite.github.com:JSLite/JSLite.git  <span class="comment"># 添加远程路径</span></span><br></pre></td></tr></table></figure><h3 id="撤销远程记录"><a href="#撤销远程记录" class="headerlink" title="撤销远程记录"></a>撤销远程记录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~1 # 撤销一条记录   </span><br><span class="line">git push -f origin HEAD:master # 同步到远程仓库</span><br></pre></td></tr></table></figure><h3 id="放弃本地的文件修改"><a href="#放弃本地的文件修改" class="headerlink" title="放弃本地的文件修改"></a>放弃本地的文件修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard FETCH_HEAD # FETCH_HEAD表示上一次成功git pull之后形成的commit点。然后git pull</span><br></pre></td></tr></table></figure><p><code>git reset --hard FETCH_HEAD</code> 出现错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">You are not currently on a branch, so I cannot use any</span><br><span class="line"><span class="string">'branch.&lt;branchname&gt;.merge'</span> <span class="keyword">in</span> your configuration file.</span><br><span class="line">Please specify <span class="built_in">which</span> remote branch you want to use on the <span class="built_in">command</span></span><br><span class="line">line and try again (e.g. <span class="string">'git pull &lt;repository&gt; &lt;refspec&gt;'</span>).</span><br><span class="line">See git-pull(1) FOR details.</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b temp <span class="comment"># 新建+切换到temp分支 </span></span><br><span class="line">git checkout master</span><br></pre></td></tr></table></figure><h3 id="最简单放弃本地修改内容"><a href="#最简单放弃本地修改内容" class="headerlink" title="最简单放弃本地修改内容"></a>最简单放弃本地修改内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果有的修改以及加入暂存区的话</span></span><br><span class="line">git reset --hard </span><br><span class="line"><span class="comment"># 还原所有修改，不会删除新增的文件</span></span><br><span class="line">git checkout . </span><br><span class="line"><span class="comment"># 下面命令会删除新增的文件</span></span><br><span class="line">git clean -xdf</span><br></pre></td></tr></table></figure><p>通过存储暂存区stash，在删除暂存区的方法放弃本地修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash &amp;&amp; git stash drop</span><br></pre></td></tr></table></figure><h3 id="回滚到某个commit提交"><a href="#回滚到某个commit提交" class="headerlink" title="回滚到某个commit提交"></a>回滚到某个commit提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD~1 # 撤销一条记录 会弹出 commit 编辑</span><br><span class="line">git push # 提交回滚</span><br></pre></td></tr></table></figure><h3 id="回退到某一个版本"><a href="#回退到某一个版本" class="headerlink" title="回退到某一个版本"></a>回退到某一个版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;<span class="built_in">hash</span>&gt;</span><br><span class="line"><span class="comment"># 例如 git reset --hard a3hd73r</span></span><br><span class="line"><span class="comment"># --hard代表丢弃工作区的修改，让工作区与版本代码一模一样，与之对应，</span></span><br><span class="line"><span class="comment"># --soft参数代表保留工作区的修改。</span></span><br></pre></td></tr></table></figure><h3 id="去掉某个commit"><a href="#去掉某个commit" class="headerlink" title="去掉某个commit"></a>去掉某个commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实质是新建了一个与原来完全相反的commit，抵消了原来commit的效果</span></span><br><span class="line">git revert &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure><h3 id="新建一个空分支"><a href="#新建一个空分支" class="headerlink" title="新建一个空分支"></a>新建一个空分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这种方式新建的分支(gh-pages)是没有 commit 记录的</span></span><br><span class="line">git checkout --orphan gh-pages</span><br><span class="line"><span class="comment"># 删除新建的gh-pages分支原本的内容，如果不删除，提交将作为当前分支的第一个commit</span></span><br><span class="line">git rm -rf .</span><br><span class="line"><span class="comment"># 查看一下状态 有可能上面一条命令，没有删除还没有提交的的文件</span></span><br><span class="line">git state</span><br></pre></td></tr></table></figure><h3 id="合并多个commit"><a href="#合并多个commit" class="headerlink" title="合并多个commit"></a>合并多个commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个命令，将最近4个commit合并为1个，HEAD代表当前版本。</span></span><br><span class="line"><span class="comment"># 将进入VIM界面，你可以修改提交信息。</span></span><br><span class="line">git rebase -i HEAD~4 </span><br><span class="line"><span class="comment"># 可以看到其中分为两个部分，上方未注释的部分是填写要执行的指令，</span></span><br><span class="line"><span class="comment"># 而下方注释的部分则是指令的提示说明。指令部分中由前方的命令名称、commit hash 和 commit message 组成</span></span><br><span class="line"><span class="comment"># 当前我们只要知道 pick 和 squash 这两个命令即可。</span></span><br><span class="line"><span class="comment"># --&gt; pick 的意思是要会执行这个 commit</span></span><br><span class="line"><span class="comment"># --&gt; squash 的意思是这个 commit 会被合并到前一个commit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们将 需要保留的 这个 commit 前方的命令改成 squash 或 s，然后输入:wq以保存并退出</span></span><br><span class="line"><span class="comment"># 这是我们会看到 commit message 的编辑界面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中, 非注释部分就是两次的 commit message, 你要做的就是将这两个修改成新的 commit message。</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 输入wq保存并推出, 再次输入git log查看 commit 历史信息，你会发现这两个 commit 已经合并了。</span></span><br><span class="line"><span class="comment"># 将修改强制推送到前端</span></span><br><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure><h3 id="修改远程Commit记录"><a href="#修改远程Commit记录" class="headerlink" title="修改远程Commit记录"></a>修改远程Commit记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br><span class="line"><span class="comment"># amend只能修改没有提交到线上的，最后一次commit记录</span></span><br><span class="line">git rebase -i HEAD~3</span><br><span class="line"><span class="comment"># 表示要修改当前版本的倒数第三次状态</span></span><br><span class="line"><span class="comment"># 将要更改的记录行首单词 pick 改为 edit</span></span><br><span class="line">pick 96dc3f9 doc: Update quick-start.md</span><br><span class="line">pick f1cce8a <span class="built_in">test</span>(Transition):Add transition <span class="built_in">test</span> (<span class="comment">#47)</span></span><br><span class="line">pick 6293516 feat(Divider): Add Divider component.</span><br><span class="line"><span class="comment"># Rebase eeb03a4..6293516 onto eeb03a4 (3 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick = use commit</span></span><br><span class="line"><span class="comment"># r, reword = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup = like "squash", but discard this commit's log message</span></span><br><span class="line"><span class="comment"># x, exec = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># d, drop = remove commit</span></span><br></pre></td></tr></table></figure><p>保存并退出，会弹出下面提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You can amend the commit now, with</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#   git commit --amend</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># Once you are satisfied with your changes, run</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#   git rebase --continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过这条命令进入编辑页面更改commit，保存退出</span></span><br><span class="line">git commit --amend</span><br><span class="line"><span class="comment"># 保存退出确认修改，继续执行 rebase, </span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br><span class="line"><span class="comment"># 如果修改多条记录反复执行上面两条命令直到完成所有修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后，确保别人没有提交进行push，最好不要加 -f 强制推送</span></span><br><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure><h3 id="添加忽略文件"><a href="#添加忽略文件" class="headerlink" title="添加忽略文件"></a>添加忽略文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo node_modules/ &gt;&gt; .gitignore</span><br></pre></td></tr></table></figure><h3 id="利用commit关闭一个issue"><a href="#利用commit关闭一个issue" class="headerlink" title="利用commit关闭一个issue"></a>利用commit关闭一个issue</h3><p>这个功能在Github上可以玩儿，Gitlab上特别老的版本不能玩儿哦，那么如何跟随着commit关闭一个issue呢? 在confirm merge的时候可以使用一下命令来关闭相关issue:  </p><p><code>fixes #xxx</code>、 <code>fixed #xxx</code>、 <code>fix #xxx</code>、 <code>closes #xxx</code>、 <code>close #xxx</code>、 <code>closed #xxx</code>、</p><h3 id="同步fork的上游仓库"><a href="#同步fork的上游仓库" class="headerlink" title="同步fork的上游仓库"></a>同步fork的上游仓库</h3><p><a href="https://help.github.com/articles/syncing-a-fork/" target="_blank" rel="noopener">Github教程同步fork教程</a>，<a href="http://www.miss77.net/549.html" target="_blank" rel="noopener">在Github上同步一个分支(fork)</a>  </p><p><strong>设置添加多个远程仓库地址。</strong></p><p>在同步之前，需要创建一个远程点指向上游仓库(repo).如果你已经派生了一个原始仓库，可以按照如下方法做。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> List the current remotes （列出当前远程仓库）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> origin  https://github.com/user/repo.git (fetch)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> origin  https://github.com/user/repo.git (push)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add upstream https://github.com/otheruser/repo.git</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set a new remote (设置一个新的远程仓库)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Verify new remote (验证新的原唱仓库)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> origin    https://github.com/user/repo.git (fetch)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> origin    https://github.com/user/repo.git (push)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> upstream  https://github.com/otheruser/repo.git (fetch)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> upstream  https://github.com/otheruser/repo.git (push)</span></span><br></pre></td></tr></table></figure><p><strong>同步更新仓库内容</strong></p><p>同步上游仓库到你的仓库需要执行两步：首先你需要从远程拉去，之后你需要合并你希望的分支到你的本地副本分支。从上游的存储库中提取分支以及各自的提交内容。 <code>master</code> 将被存储在本地分支机构 <code>upstream/master</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream</span><br><span class="line"><span class="meta">#</span><span class="bash"> remote: Counting objects: 75, <span class="keyword">done</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> remote: Compressing objects: 100% (53/53), <span class="keyword">done</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> remote: Total 62 (delta 27), reused 44 (delta 9)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Unpacking objects: 100% (62/62), <span class="keyword">done</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  * [new branch]      master     -&gt; upstream/master</span></span><br></pre></td></tr></table></figure><p>检查你的 fork’s 本地 <code>master</code> 分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"><span class="meta">#</span><span class="bash"> Switched to branch <span class="string">'master'</span></span></span><br></pre></td></tr></table></figure><p>合并来自 <code>upstream/master</code> 的更改到本地 master  分支上。  这使你的前 fork’s <code>master</code> 分支与上游资源库同步，而不会丢失你本地修改。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git merge upstream/master</span><br><span class="line"><span class="meta">#</span><span class="bash"> Updating a422352..5fdff0f</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Fast-forward</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  README                    |    9 -------</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  README.md                 |    7 ++++++</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  2 files changed, 7 insertions(+), 9 deletions(-)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  delete mode 100644 README</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  create mode 100644 README.md</span></span><br></pre></td></tr></table></figure><h3 id="批量修改历史commit中的名字和邮箱"><a href="#批量修改历史commit中的名字和邮箱" class="headerlink" title="批量修改历史commit中的名字和邮箱"></a>批量修改历史commit中的名字和邮箱</h3><p><strong>1.克隆仓库</strong></p><p>注意参数，这个不是普通的clone，clone下来的仓库并不能参与开发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --bare https://github.com/user/repo.git</span><br><span class="line"><span class="built_in">cd</span> repo.git</span><br></pre></td></tr></table></figure><p><strong>2.命令行中运行代码</strong></p><p>OLD_EMAIL原来的邮箱<br>CORRECT_NAME更正的名字<br>CORRECT_EMAIL更正的邮箱  </p><p>将下面代码复制放到命令行中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --env-filter <span class="string">'</span></span><br><span class="line"><span class="string">OLD_EMAIL="wowohoo@qq.com"</span></span><br><span class="line"><span class="string">CORRECT_NAME="小弟调调"</span></span><br><span class="line"><span class="string">CORRECT_EMAIL="更正的邮箱@qq.com"</span></span><br><span class="line"><span class="string">if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">    export GIT_COMMITTER_NAME="$CORRECT_NAME"</span></span><br><span class="line"><span class="string">    export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">    export GIT_AUTHOR_NAME="$CORRECT_NAME"</span></span><br><span class="line"><span class="string">    export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">'</span> --tag-name-filter cat -- --branches --tags</span><br></pre></td></tr></table></figure><p>执行过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rewrite 160d4df2689ff6df3820563bfd13b5f1fb9ba832 (479/508) (16 seconds passed, remaining 0 predicted)</span><br><span class="line">Ref <span class="string">'refs/heads/dev'</span> was rewritten</span><br><span class="line">Ref <span class="string">'refs/heads/master'</span> was rewritten</span><br></pre></td></tr></table></figure><p><strong>3.同步到远程仓库</strong></p><p>同步到push远程git仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force --tags origin <span class="string">'refs/heads/*'</span></span><br></pre></td></tr></table></figure><p>我还遇到了如下面错误，lab默认给master分支加了保护，不允许强制覆盖。<code>Project(项目)</code>-&gt;<code>Setting</code>-&gt;<code>Repository</code> 菜单下面的<code>Protected branches</code>把master的保护去掉就可以了。修改完之后，建议把master的保护再加回来，毕竟强推不是件好事。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote: GitLab: You are not allowed to force push code to a protected branch on this project.</span><br></pre></td></tr></table></figure><p>当上面的push 不上去的时候，先 <code>git pull</code> 确保最新代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull  --allow-unrelated-histories</span><br><span class="line"><span class="comment"># 或者指定分枝</span></span><br><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><h3 id="查看某个文件历史"><a href="#查看某个文件历史" class="headerlink" title="查看某个文件历史"></a>查看某个文件历史</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline 文件名  # 列出文件的所有改动历史  </span><br><span class="line">git show c178bf49   # 某次的改动的修改记录  </span><br><span class="line">git log -p c178bf49 # 某次的改动的修改记录  </span><br><span class="line">git blame 文件名     # 显示文件的每一行是在那个版本最后修改。  </span><br><span class="line">git whatchanged 文件名  # 显示某个文件的每个版本提交信息：提交日期，提交人员，版本号，提交备注（没有修改细节）</span><br></pre></td></tr></table></figure><h3 id="查看git仓库中最近修改的分支"><a href="#查看git仓库中最近修改的分支" class="headerlink" title="查看git仓库中最近修改的分支"></a>查看git仓库中最近修改的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">for</span>-each-ref --count=30 --sort=-committerdate refs/heads/ --format=<span class="string">'%(refname:short)'</span></span><br></pre></td></tr></table></figure><h3 id="打造自己的git命令"><a href="#打造自己的git命令" class="headerlink" title="打造自己的git命令"></a>打造自己的git命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br></pre></td></tr></table></figure><p>配置好后再输入git命令的时候就不用再输入一大段了，例如我们要查看状态，只需：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git st</span><br></pre></td></tr></table></figure><h3 id="中文乱码的解决方案"><a href="#中文乱码的解决方案" class="headerlink" title="中文乱码的解决方案"></a>中文乱码的解决方案</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p><code>git init</code> #初始化  </p><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p><code>git status</code> #获取状态  </p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p><code>git add file</code> # .或*代表全部添加<br><code>git rm --cached &lt;added_file_to_undo&gt;</code> # 在commit之前撤销git add操作<br><code>git reset head</code> # 好像比上面<code>git rm --cached</code>更方便  </p><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p><code>git commit -m &quot;message&quot;</code> #此处注意乱码  </p><h3 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h3><p><code>git remote add origin git@github.com:JSLite/test.git</code> #添加源  </p><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master <span class="comment"># push同事设置默认跟踪分支  </span></span><br><span class="line">git push origin master  </span><br><span class="line">git push -f origin master <span class="comment"># 强制推送文件，缩写 -f（全写--force）</span></span><br></pre></td></tr></table></figure><h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><p><code>git clone git://github.com/JSLite/JSLite.js.git</code><br><code>git clone git://github.com/JSLite/JSLite.js.git mypro</code> #克隆到自定义文件夹<br><code>git clone [user@]example.com:path/to/repo.git/</code> #SSH协议还有另一种写法。  </p><p>git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。<code>git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</code>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> http[s]://example.com/path/to/repo.git/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> ssh://example.com/path/to/repo.git/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://example.com/path/to/repo.git/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> /opt/git/project.git </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> file:///opt/git/project.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> ftp[s]://example.com/path/to/repo.git/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> rsync://example.com/path/to/repo.git/</span></span><br></pre></td></tr></table></figure><h2 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h2><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> config <span class="comment"># 获取帮助信息</span></span><br></pre></td></tr></table></figure><h3 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add *   # 跟踪新文件   </span><br><span class="line">git add -u [path]   # 添加[指定路径下]已跟踪文件</span><br></pre></td></tr></table></figure><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm *&amp;git rm *          # 移除文件  </span><br><span class="line">git rm -f *            # 移除文件  </span><br><span class="line">git rm --cached *      # 取消跟踪  </span><br><span class="line">git mv file_from file_to  # 重命名跟踪文件  </span><br><span class="line">git log   # 查看提交记录</span><br></pre></td></tr></table></figure><h3 id="commit-1"><a href="#commit-1" class="headerlink" title="commit"></a>commit</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git commit #提交更新   </span><br><span class="line">git commit -m 'message' #提交说明   </span><br><span class="line">git commit -a #跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交   </span><br><span class="line">git commit --amend #修改最后一次提交   </span><br><span class="line">git commit log #查看所有提交，包括没有push的commit    </span><br><span class="line">git commit -m "#133" #关联issue 任意位置带上# 符号加上issue号码  </span><br><span class="line">git commit -m "fix #133" commit关闭issue  </span><br><span class="line">git commit -m '概要描述'$'\n\n''1.详细描述'$'\n''2.详细描述' #提交简要描述和详细描述</span><br></pre></td></tr></table></figure><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD *  # 取消已经暂存的文件   </span><br><span class="line">git reset --mixed HEAD * # 同上   </span><br><span class="line">git reset --soft HEAD *  # 重置到指定状态，不会修改索引区和工作树   </span><br><span class="line">git reset --hard HEAD *  # 重置到指定状态，会修改索引区和工作树   </span><br><span class="line">git reset -- files *     # 重置index区文件</span><br></pre></td></tr></table></figure><h3 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD   # 撤销前一次操作   </span><br><span class="line">git revert HEAD~  # 撤销前前一次操作   </span><br><span class="line">git revert commit # 撤销指定操作</span><br></pre></td></tr></table></figure><h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file  # 取消对文件的修改（从暂存区——覆盖worktree file）  </span><br><span class="line">git checkout branch|tag|commit -- file_name  # 从仓库取出file覆盖当前分支   </span><br><span class="line">git checkout HEAD~1 [文件]  # 将会更新 working directory 去匹配某次 commit   </span><br><span class="line">git checkout -- .          # 从暂存区取出文件覆盖工作区   </span><br><span class="line">git checkout -b gh-pages  0c304c9  # 这个表示 从当前分支 commit 哈希值为 0c304c9 的节点，分一个新的分支gh-pages出来，并切换到 gh-pages</span><br></pre></td></tr></table></figure><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git diff file     # 查看指定文件的差异   </span><br><span class="line">git diff --stat   # 查看简单的diff结果   </span><br><span class="line">git diff  # 比较Worktree和Index之间的差异   </span><br><span class="line">git diff --cached   # 比较Index和HEAD之间的差异   </span><br><span class="line">git diff HEAD       # 比较Worktree和HEAD之间的差异   </span><br><span class="line">git diff branch     # 比较Worktree和branch之间的差异   </span><br><span class="line">git diff branch1 branch2  # 比较两次分支之间的差异   </span><br><span class="line">git diff commit commit    # 比较两次提交之间的差异   </span><br><span class="line">git diff master..test   # 上面这条命令只显示两个分支间的差异  </span><br><span class="line">git diff master...test    # 你想找出‘master’,‘test’的共有 父分支和'test'分支之间的差异，你用3个‘.'来取代前面的两个'.'</span><br></pre></td></tr></table></figure><h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git stash # 将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。   </span><br><span class="line">git stash list  # 查看保存的工作现场   </span><br><span class="line">git stash apply # 恢复工作现场   </span><br><span class="line">git stash drop  # 删除stash内容   </span><br><span class="line">git stash pop   # 恢复的同时直接删除stash内容   </span><br><span class="line">git stash apply stash@&#123;0&#125; # 恢复指定的工作现场，当你保存了不只一份工作现场时。</span><br></pre></td></tr></table></figure><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --squash <span class="built_in">test</span> <span class="comment"># 合并压缩，将test上的commit压缩为一条</span></span><br></pre></td></tr></table></figure><h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick commit    # 拣选合并，将commit合并到当前分支   </span><br><span class="line">git cherry-pick -n commit # 拣选多个提交，合并完后可以继续拣选下一个提交</span><br></pre></td></tr></table></figure><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git rebase master   # 将master分之上超前的提交，变基到当前分支  </span><br><span class="line">git rebase --onto master 169a6  # 限制回滚范围，rebase当前分支从169a6以后的提交  </span><br><span class="line">git rebase --interactive # 交互模式，修改commit   </span><br><span class="line">git rebase --continue    # 处理完冲突继续合并   </span><br><span class="line">git rebase --skip        # 跳过   </span><br><span class="line">git rebase --abort       # 取消合并</span><br></pre></td></tr></table></figure><h2 id="分支branch"><a href="#分支branch" class="headerlink" title="分支branch"></a>分支branch</h2><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git push origin :branchName  # 删除远程分支  </span><br><span class="line">git push origin --delete new # 删除远程分支new   </span><br><span class="line">git branch -d branchName     # 删除本地分支，强制删除用-D  </span><br><span class="line">git branch -d test      # 删除本地test分支   </span><br><span class="line">git branch -D test      # 强制删除本地test分支   </span><br><span class="line">git remote prune origin # 远程删除了，本地还能看到远程存在，这条命令删除远程不存在的分支</span><br></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin branchName <span class="comment"># 提交分支到远程origin主机中</span></span><br></pre></td></tr></table></figure><h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p><code>git fetch -p</code> #拉取远程分支时，自动清理 远程分支已删除，本地还存在的对应同名分支。  </p><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git merge branchName      # 合并分支 - 将分支branchName和当前所在分支合并   </span><br><span class="line">git merge origin/master   # 在本地分支上合并远程分支。   </span><br><span class="line">git rebase origin/master  # 在本地分支上合并远程分支。   </span><br><span class="line">git merge test            # 将test分支合并到当前分支</span><br></pre></td></tr></table></figure><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><p><code>git branch -m old new</code> #重命名分支  </p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git branch      # 列出本地分支   </span><br><span class="line">git branch -r   # 列出远端分支   </span><br><span class="line">git branch -a   # 列出所有分支   </span><br><span class="line">git branch -v   # 查看各个分支最后一个提交对象的信息   </span><br><span class="line">git branch --merge      # 查看已经合并到当前分支的分支   </span><br><span class="line">git branch --no-merge   # 查看为合并到当前分支的分支   </span><br><span class="line">git remote show origin  # 可以查看remote地址，远程分支</span><br></pre></td></tr></table></figure><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch test # 新建test分支  </span><br><span class="line">git branch newBrach 3defc69 # 指定哈希3defc69，新建分支名字为newBrach</span><br><span class="line">git checkout -b newBrach origin/master # 取回远程主机的更新以后，在它的基础上创建一个新的分支  </span><br><span class="line">git checkout -b newBrach 3defc69 # 以哈希值3defc69，新建 newBrach 分支，并切换到该分支</span><br></pre></td></tr></table></figure><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream dev origin/dev     # 将本地dev分支与远程dev分支之间建立链接  </span><br><span class="line">git branch --set-upstream master origin/next # 手动建立追踪关系</span><br></pre></td></tr></table></figure><h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout test     # 切换到test分支   </span><br><span class="line">git checkout -b test  # 新建+切换到test分支   </span><br><span class="line">git checkout -b test dev # 基于dev新建test分支，并切换</span><br></pre></td></tr></table></figure><h2 id="远端"><a href="#远端" class="headerlink" title="远端"></a>远端</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; &lt;分支名&gt;   # fetch取回所有分支（branch）的更新  </span><br><span class="line">git fetch origin remotebranch[:localbranch]   #  从远端拉去分支[到本地指定分支]   </span><br><span class="line">git merge origin/branch   # 合并远端上指定分支   </span><br><span class="line">git pull origin remotebranch:localbranch  #  拉去远端分支到本地分支   </span><br><span class="line">git push origin branch    # 将当前分支，推送到远端上指定分支   </span><br><span class="line">git push origin localbranch:remotebranch  # 推送本地指定分支，到远端上指定分支   </span><br><span class="line">git push origin :remotebranch   # 删除远端指定分支   </span><br><span class="line">git checkout -b [--track] test origin/dev # 基于远端dev分支，新建本地test分支[同时设置跟踪]</span><br></pre></td></tr></table></figure><h2 id="submodule"><a href="#submodule" class="headerlink" title="submodule"></a>submodule</h2><p>克隆项目同时克隆submodule</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/jaywcjlove/handbook.git --depth=1 --recurse-submodules</span><br></pre></td></tr></table></figure><p>克隆项目，之后再手动克隆 submodule 子项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git submodule add --force <span class="string">'仓库地址'</span> <span class="string">'路径'</span></span><br><span class="line"><span class="comment"># 其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。</span></span><br><span class="line"><span class="comment"># 注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone）</span></span><br><span class="line">git submodule init <span class="comment"># 初始化submodule</span></span><br><span class="line">git submodule update <span class="comment"># 更新submodule(必须在根目录执行命令)</span></span><br><span class="line">git submodule update --init --recursive  <span class="comment"># 下载的工程带有submodule</span></span><br></pre></td></tr></table></figure><p>当使用<code>git clone</code>下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git submodule foreach git pull  <span class="comment"># submodule 里有其他的 submodule 一次更新</span></span><br><span class="line">git submodule foreach git pull origin master <span class="comment"># submodule更新</span></span><br><span class="line"></span><br><span class="line">git submodule foreach --recursive git submodule init</span><br><span class="line">git submodule foreach --recursive git submodule update</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -rf node_modules/</span><br></pre></td></tr></table></figure><h2 id="remote-1"><a href="#remote-1" class="headerlink" title="remote"></a>remote</h2><p>git是一个分布式代码管理工具，所以可以支持多个仓库，在git里，服务器上的仓库在本地称之为remote。个人开发时，多源用的可能不多，但多源其实非常有用。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin1 git@github.com:yanhaijing/data.js.git  </span><br><span class="line">git remote    # 显示全部源  </span><br><span class="line">git remote -v # 显示全部源+详细信息  </span><br><span class="line">git remote rename origin1 origin2 # 重命名  </span><br><span class="line">git remote rm origin    # 删除  </span><br><span class="line">git remote show origin  # 查看指定源的全部信息</span><br></pre></td></tr></table></figure><h2 id="标签tag"><a href="#标签tag" class="headerlink" title="标签tag"></a>标签tag</h2><p>当开发到一定阶段时，给程序打标签是非常棒的功能。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v0.1 -m <span class="string">'my version 1.4'</span> <span class="comment"># 新建带注释标签   </span></span><br><span class="line">git push origin --tags              <span class="comment"># 一次性推送所有分支 </span></span><br><span class="line">git push origin v1.5                <span class="comment"># 推送单个tag到orgin源上 </span></span><br><span class="line">git tag -v v1.4.2.1                 <span class="comment"># 验证标签，验证已经签署的标签</span></span><br><span class="line">git show v1.5                       <span class="comment"># 看到对应的 GPG 签</span></span><br><span class="line"></span><br><span class="line">git tag        <span class="comment"># 列出现有标签   </span></span><br><span class="line">git tag v0gi.1 <span class="comment"># 新建标签   </span></span><br><span class="line">git checkout tagname   <span class="comment"># 切换到标签       </span></span><br><span class="line">git tag -d v0.1 <span class="comment"># 删除标签   </span></span><br><span class="line">git push origin :refs/tags/v0.1 <span class="comment"># 删除远程标签   </span></span><br><span class="line">git pull --all <span class="comment"># 获取远程所有内容包括tag  </span></span><br><span class="line">git --git-dir=<span class="string">'&lt;绝对地址&gt;/.git'</span> describe --tags HEAD <span class="comment"># 查看本地版本信息</span></span><br></pre></td></tr></table></figure><h2 id="日志log"><a href="#日志log" class="headerlink" title="日志log"></a>日志log</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git config format.pretty oneline  <span class="comment">#显示历史记录时，每个提交的信息只显示一行   </span></span><br><span class="line">git config color.ui <span class="literal">true</span> <span class="comment">#彩色的 git 输出   </span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">#查看最近的提交日志   </span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline <span class="comment">#单行显示提交日志   </span></span><br><span class="line">git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit   </span><br><span class="line">git <span class="built_in">log</span> -num <span class="comment">#显示第几条log（倒数）   </span></span><br><span class="line">git reflog <span class="comment">#查看所有分支的所有操作记录   </span></span><br><span class="line">git <span class="built_in">log</span> --since=1.day <span class="comment">#一天内的提交；你可以给出各种时间格式</span></span><br><span class="line"><span class="comment"># 比如说具体的某一天（“2008-01-15”），或者是多久以前（“2 years 1 day 3 minutes ago”） </span></span><br><span class="line">git <span class="built_in">log</span> --pretty=<span class="string">"%h - %s"</span> --author=自己的名字 <span class="comment">#查看自己的日志   </span></span><br><span class="line">git <span class="built_in">log</span> -p -2 <span class="comment">#展开两次更新显示每次提交的内容差异   </span></span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span> <span class="comment">#要快速浏览其他协作者提交的更新都作了哪些改动   </span></span><br><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">"%h - %an, %ar : %s"</span><span class="comment">#定制要显示的记录格式   </span></span><br><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">'%h : %s'</span> --date-order --graph <span class="comment"># 拓扑顺序展示   </span></span><br><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">'%h : %s - %ad'</span> --date=short <span class="comment">#日期YYYY-MM-DD显示   </span></span><br><span class="line">git <span class="built_in">log</span> &lt;last tag&gt; HEAD --pretty=format:%s <span class="comment"># 只显示commit   </span></span><br><span class="line">git config --global format.pretty <span class="string">'%h : %s - %ad'</span> --date=short </span><br><span class="line"><span class="comment">#日期YYYY-MM-DD显示 写入全局配置</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>%H</td><td>提交对象（commit）的完整哈希字串</td><td>%ad</td><td>作者修订日期（可以用 -date= 选项定制格式）</td></tr><tr><td>%h</td><td>提交对象的简短哈希字串</td><td>%ar</td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td>%T</td><td>树对象（tree）的完整哈希字串</td><td>%cn</td><td>提交者(committer)的名字</td></tr><tr><td>%t</td><td>树对象的简短哈希字串</td><td>%ce</td><td>提交者的电子邮件地址</td></tr><tr><td>%P</td><td>父对象（parent）的完整哈希字串</td><td>%cd</td><td>提交日期</td></tr><tr><td>%p</td><td>父对象的简短哈希字串</td><td>%cr</td><td>提交日期，按多久以前的方式显示</td></tr><tr><td>%an</td><td>作者（author）的名字</td><td>%s</td><td>提交说明</td></tr><tr><td>%ae</td><td>作者的电子邮件地址</td><td>-</td><td>-</td></tr></tbody></table><p><a href="https://git-scm.com/docs/git-log#_pretty_formats" target="_blank" rel="noopener">Pretty Formats</a></p><h2 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend    <span class="comment"># 改变最近一次提交  </span></span><br><span class="line">git rebase -i HEAD~3  <span class="comment"># 修改最近三次的提交说明，或者其中任意一次  </span></span><br><span class="line">git commit --amend    <span class="comment"># 保存好了，这些指示很明确地告诉了你该干什么  </span></span><br><span class="line">git rebase --<span class="built_in">continue</span> <span class="comment"># 修改提交说明，退出编辑器。</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick f7f3f6d changed my name a bit</span><br></pre></td></tr></table></figure><h3 id="删除仓库"><a href="#删除仓库" class="headerlink" title="删除仓库"></a>删除仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">rm -rf repo.git</span><br></pre></td></tr></table></figure><p><a href="https://help.github.com/articles/changing-author-info/" target="_blank" rel="noopener">Github官方教程</a></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> *  <span class="comment"># 获取命令的帮助信息  </span></span><br><span class="line">git status  <span class="comment"># 获取当前的状态，非常有用，因为git会提示接下来的能做的操作</span></span><br></pre></td></tr></table></figure><h2 id="报错问题解决"><a href="#报错问题解决" class="headerlink" title="报错问题解决"></a>报错问题解决</h2><p><strong>1. <code>git fatal: protocol error: bad line length character: No s</code></strong></p><p>解决办法：更换remote地址为 <code>http/https</code> 的  </p><p><strong>2. <code>The requested URL returned error: 403 Forbidden while accessing</code></strong></p><p>解决github push错误的办法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">vim 编辑器打开 当前项目中的config文件</span></span><br><span class="line">vim .git/config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改</span></span><br><span class="line">[remote "origin"]  </span><br><span class="line">    url = https://github.com/jaywcjlove/example.git  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">为下面代码</span></span><br><span class="line">[remote "origin"]  </span><br><span class="line">    url = https://jaywcjlove@github.com/jaywcjlove/example.git</span><br></pre></td></tr></table></figure><p><strong>3. git status 显示中文问题</strong></p><p>在查看状态的时候 git status 如果是中文就显示下面的情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\344\272\247\345\223\201\351\234\200\346\261\202</span><br></pre></td></tr></table></figure><p>解决这个问题方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git官网</a></li><li><a href="https://try.github.io" target="_blank" rel="noopener">Github 15分钟学习Git</a></li><li><a href="http://gitref.org/zh/index.html" target="_blank" rel="noopener">Git参考手册</a></li><li><a href="http://www.mceiba.com/tool/git-cheat-sheet.html" target="_blank" rel="noopener">Git简明手册</a></li><li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/" target="_blank" rel="noopener">Git Magic</a></li><li><a href="http://gitbook.liuhui998.com/index.html" target="_blank" rel="noopener">Git Community Book 中文版</a></li><li><a href="http://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git</a></li><li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">图解Git</a></li><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">git-简明指南</a></li><li><a href="http://pcottle.github.io/learnGitBranching/" target="_blank" rel="noopener">learnGitBranching 在线学习工具</a></li><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">初级教程</a> </li><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的Git教程</a></li><li><a href="http://www.worldhello.net/gotgithub/" target="_blank" rel="noopener">蒋鑫老师将带你入github的大门</a></li><li><a href="http://www.open-open.com/lib/view/open1328069609436.html" target="_blank" rel="noopener">git详解</a></li><li><a href="http://git.oschina.net/progit/" target="_blank" rel="noopener">oschina教程</a></li><li><a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="noopener">Git撤销一切，汇总各种回滚撤销的场景</a></li><li><a href="http://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">Git 教程 | 菜鸟教程runoob.com</a></li><li><a href="https://gold.xitu.io/post/5842f9b861ff4b005889ade6" target="_blank" rel="noopener">Git 本地仓库和裸仓库</a></li><li><a href="http://www.kancloud.cn/kancloud/igit/46710" target="_blank" rel="noopener">沉浸式学 Git</a></li><li><a href="http://way.oschina.io/2016/12/15/notes/GitAdvance/?utm_source=gank.io&amp;utm_medium=email" target="_blank" rel="noopener">Git进阶用法，主要是rebase高级用法</a></li></ul>]]></content>
      
      <categories>
          
          <category> 实践教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS字符串和Array方法</title>
      <link href="/blog/2018/05/30/JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8CArray%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/blog/2018/05/30/JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8CArray%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="String对象属性"><a href="#String对象属性" class="headerlink" title="String对象属性"></a>String对象属性</h2><p><strong>length属性</strong><br>length属性是字符串中的一个基本属性了，可以获取字符串长度，要注意的是js的中文每个汉字也只代表一个字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &apos;abc&apos;;</span><br><span class="line">var str2 = &apos;中国&apos;;</span><br><span class="line">console.log(str1.length); //3</span><br><span class="line">console.log(str2.length); //2</span><br></pre></td></tr></table></figure></p><p><strong>prototype属性</strong><br>prototype属性用来给对象添加属性或方法，并且添加的方法或属性在所有的实例上共享。可以用来扩展js内置对象，如给字符串添加了一个去除两边空格的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.trim = function()&#123;</span><br><span class="line">    return this.replace(/^\s*|\s*$/g, &apos;&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">封装成函数   </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> trim(str,<span class="built_in">type</span>) &#123;  // [<span class="built_in">type</span>]类型</span><br><span class="line">    var <span class="built_in">type</span>=<span class="built_in">type</span>||<span class="string">"b"</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>==<span class="string">"b"</span>)&#123;</span><br><span class="line">        <span class="built_in">return</span> str.replace(/^\s*|\s*$/g,<span class="string">""</span>); // 去除两边的空白</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">type</span>==<span class="string">"l"</span>)&#123;</span><br><span class="line">        <span class="built_in">return</span> str.replace(/^\s*/g,<span class="string">""</span>);      // 去除左边空白</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">type</span>==<span class="string">"r"</span>)&#123;</span><br><span class="line">        <span class="built_in">return</span> str.replace(/\s*$/g,<span class="string">""</span>);      // 去除右边空白</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">type</span>==<span class="string">"a"</span>)&#123;</span><br><span class="line">        <span class="built_in">return</span> str.replace(/\s*/g,<span class="string">""</span>);       // 去除所有空白</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String对象方法"><a href="#String对象方法" class="headerlink" title="String对象方法"></a>String对象方法</h2><h3 id="1-获取类方法"><a href="#1-获取类方法" class="headerlink" title="1. 获取类方法"></a>1. 获取类方法</h3><h4 id="1-charAt"><a href="#1-charAt" class="headerlink" title="(1) charAt()"></a>(1) charAt()</h4><p>charAt()方法可用来获取指定位置的字符串，参数为字符串索引值，从0开始到string.length - 1，若不在这个范围将返回一个空字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abcde&apos;;</span><br><span class="line">console.log(str.charAt(2));        //返回c</span><br><span class="line">console.log(str.charAt(8));        //返回空字符串</span><br></pre></td></tr></table></figure></p><h4 id="2-charCodeAt"><a href="#2-charCodeAt" class="headerlink" title="(2) charCodeAt()"></a>(2) charCodeAt()</h4><p>charCodeAt()方法可返回指定位置的字符的Unicode编码。charCodeAt()方法与charAt()方法类似，都需要传入一个索引值作为参数，区别是前者返回指定位置的字符的编码，而后者返回的是字符子串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abcde&apos;;</span><br><span class="line">console.log(str.charCodeAt(0));      //返回97</span><br></pre></td></tr></table></figure></p><h3 id="2-查找类方法"><a href="#2-查找类方法" class="headerlink" title="2. 查找类方法"></a>2. 查找类方法</h3><h4 id="1-indexOf-数组中也有该方法"><a href="#1-indexOf-数组中也有该方法" class="headerlink" title="(1) indexOf()(数组中也有该方法)"></a>(1) indexOf()(数组中也有该方法)</h4><blockquote>stringObject.indexOf(searchvalue,fromindex)</blockquote><p>indexOf()用来检索指定的字符串值在字符串中首次出现的位置。它可以接收两个参数，searchvalue表示要查找的子字符串，fromindex表示查找的开始位置，省略的话则从开始位置进行检索。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abcdeabcde&apos;;</span><br><span class="line">console.log(str.indexOf(&apos;a&apos;));       // 返回0</span><br><span class="line">console.log(str.indexOf(&apos;a&apos;, 3));    // 返回5</span><br><span class="line">console.log(str.indexOf(&apos;bc&apos;));      // 返回1</span><br></pre></td></tr></table></figure></p><h4 id="2-lastIndexOf-数组中也有该方法"><a href="#2-lastIndexOf-数组中也有该方法" class="headerlink" title="(2) lastIndexOf()(数组中也有该方法)"></a>(2) lastIndexOf()(数组中也有该方法)</h4><blockquote>stringObject.lastIndexOf(searchvalue,fromindex)</blockquote><p>lastIndexOf返回的是一个指定的子字符串值最后出现的位置，其检索顺序是从后向前。与indexOf()类似，这两个方法在搜索到第一个匹配的子字符串后就停止运行，所以如果想找到字符串中所有的子字符串出现的位置，可以循环调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abcdeabcde&apos;;</span><br><span class="line">console.log(str.lastIndexOf(&apos;a&apos;));       // 返回5</span><br><span class="line">console.log(str.lastIndexOf(&apos;a&apos;, 3));    // 返回0 从第索引3的位置往前检索</span><br><span class="line">console.log(str.lastIndexOf(&apos;bc&apos;));      // 返回6</span><br></pre></td></tr></table></figure></p><h4 id="3-search"><a href="#3-search" class="headerlink" title="(3) search()"></a>(3) search()</h4><blockquote>stringObject.search(substr)<br>stringObject.search(regexp)</blockquote><p>search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。它会返回第一个匹配的子字符串的起始位置，如果没有匹配的，则返回-1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abcDEF&apos;;</span><br><span class="line">console.log(str.search(&apos;c&apos;));     //返回2</span><br><span class="line">console.log(str.search(&apos;d&apos;));     //返回-1</span><br><span class="line">console.log(str.search(/d/i));    //返回3</span><br></pre></td></tr></table></figure></p><h4 id="4-match"><a href="#4-match" class="headerlink" title="(4) match()"></a>(4) match()</h4><blockquote>stringObject.match(substr)<br>stringObject.match(regexp)</blockquote><p>match()方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</p><p>如果参数中传入的是子字符串或是没有进行全局匹配的正则表达式，那么match()方法会从开始位置执行一次匹配，如果没有匹配到结果，则返回null。否则则会返回一个数组，该数组的第0个元素存放的是匹配文本，除此之外，返回的数组还含有两个对象属性index和input，分别表示匹配文本的起始字符索引和stringObject 的引用(即原字符串)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;1a2b3c4d5e&apos;;</span><br><span class="line">console.log(str.match(&apos;h&apos;));    //返回null</span><br><span class="line">console.log(str.match(&apos;b&apos;));    //返回[&quot;b&quot;, index: 3, input: &quot;1a2b3c4d5e&quot;]</span><br><span class="line">console.log(str.match(/b/));    //返回[&quot;b&quot;, index: 3, input: &quot;1a2b3c4d5e&quot;]</span><br></pre></td></tr></table></figure></p><p>如果参数传入的是具有全局匹配的正则表达式，那么match()从开始位置进行多次匹配，直到最后。如果没有匹配到结果，则返回null。否则则会返回一个数组，数组中存放所有符合要求的子字符串，并且没有index和input属性。在字符串上调用这个方法本质上与调用RegExp的exec()方法相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;1a2b3c4d5e&apos;;</span><br><span class="line">console.log(str.match(/h/g));     //返回null</span><br><span class="line">console.log(str.match(/\d/g));    //返回[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span><br></pre></td></tr></table></figure></p><h4 id="ES6新增includes-、startsWith-、endsWith"><a href="#ES6新增includes-、startsWith-、endsWith" class="headerlink" title="ES6新增includes()、startsWith()、endsWith()"></a>ES6新增includes()、startsWith()、endsWith()</h4><p>includes()：返回布尔值，表示是否找到了参数字符串<br>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部<br>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部<br>这三个方法的参数与indexOf()，lastIndexOf()一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;Hello world&apos;;</span><br><span class="line">s.startsWith(&apos;world&apos;,6);    // true</span><br><span class="line">s.endsWith(&apos;Hello&apos;,5);      // true</span><br><span class="line">s.includes(&apos;Hello&apos;,6);      //false</span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong>使用第2个参数n时，endsWith的行为与其他两个方法有所不同。它针对前面n个字符，而其他两个方法针对从第n个位置开始直到字符串结束的字符。</p><h3 id="3-截取类方法"><a href="#3-截取类方法" class="headerlink" title="3. 截取类方法"></a>3. 截取类方法</h3><h4 id="1-substring"><a href="#1-substring" class="headerlink" title="(1)substring()"></a>(1)substring()</h4><blockquote>stringObject.substring(start,end)</blockquote><p>substring()是最常用到的字符串截取方法，它可以接收两个参数(参数不能为负值)，分别是要截取的开始位置和结束位置，它将返回一个新的字符串，其内容是从start处到end-1处的所有字符。若结束参数(end)省略，则表示从start位置一直截取到最后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abcdefg&apos;;</span><br><span class="line">console.log(str.substring(1, 4));    //返回bcd</span><br><span class="line">console.log(str.substring(1));       //返回bcdefg</span><br><span class="line">console.log(str.substring(-1));      //返回abcdefg，传入负值时会视为0</span><br></pre></td></tr></table></figure></p><h4 id="2-slice-数组也有"><a href="#2-slice-数组也有" class="headerlink" title="(2) slice()(数组也有)"></a>(2) slice()(数组也有)</h4><blockquote>stringObject.slice(start,end)</blockquote><p>slice()方法与substring()方法非常类似，它传入的两个参数也分别对应着开始位置和结束位置。而区别在于，slice()中的参数可以为负值，如果参数是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abcdefg&apos;;</span><br><span class="line">console.log(str.slice(1, 4));      //返回bcd</span><br><span class="line">console.log(str.slice(-3, -1));    //返回ef</span><br><span class="line">console.log(str.slice(1, -1));     //返回bcdef</span><br><span class="line">console.log(str.slice(-1, -3));    //返回空字符串，若传入的参数有问题，则返回空</span><br></pre></td></tr></table></figure></p><h4 id="3-substr"><a href="#3-substr" class="headerlink" title="(3) substr()"></a>(3) substr()</h4><blockquote>stringObject.substr(start,length)</blockquote><p>substr()方法可在字符串中抽取从start下标开始的指定数目的字符。其返回值为一个字符串，包含从 stringObject的start（包括start所指的字符）处开始的length个字符。如果没有指定 length，那么返回的字符串包含从start到stringObject的结尾的字符。另外如果start为负数，则表示从字符串尾部开始算起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abcdefg&apos;;</span><br><span class="line">console.log(str.substr(1, 3))    //返回bcd</span><br><span class="line">console.log(str.substr(2))       //返回cdefg</span><br><span class="line">console.log(str.substr(-2, 4))   //返回fg，目标长度较大的话，以实际截取的长度为准</span><br></pre></td></tr></table></figure></p><h3 id="4-其他方法"><a href="#4-其他方法" class="headerlink" title="4. 其他方法"></a>4. 其他方法</h3><h4 id="1-replace-方法"><a href="#1-replace-方法" class="headerlink" title="(1) replace()方法"></a>(1) replace()方法</h4><blockquote><p>stringObject.replace(regexp/substr,replacement)</p></blockquote><p>replace()方法用来进行字符串替换操作，它可以接收两个参数，前者为被替换的子字符串（可以是正则），后者为用来替换的文本。</p><p>如果第一个参数传入的是子字符串或是没有进行全局匹配的正则表达式，那么replace()方法将只进行一次替换（即替换最前面的），返回经过一次替换后的结果字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abcdeabcde&apos;;</span><br><span class="line">console.log(str.replace(&apos;a&apos;, &apos;A&apos;));</span><br><span class="line">console.log(str.replace(/a/, &apos;A&apos;));</span><br></pre></td></tr></table></figure></p><p>如果第一个参数传入的全局匹配的正则表达式，那么replace()将会对符合条件的子字符串进行多次替换，最后返回经过多次替换的结果字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abcdeabcdeABCDE&apos;;</span><br><span class="line">console.log(str.replace(/a/g, &apos;A&apos;));    //返回AbcdeAbcdeABCDE</span><br><span class="line">console.log(str.replace(/a/gi, &apos;$&apos;));    //返回$bcde$bcde$BCDE</span><br></pre></td></tr></table></figure></p><h4 id="2-split-方法"><a href="#2-split-方法" class="headerlink" title="(2) split()方法"></a>(2) split()方法</h4><blockquote><p>stringObject.split(separator,howmany)</p></blockquote><p>split()方法用于把一个字符串分割成字符串数组。第一个参数separator表示分割位置(参考符)，第二个参数howmany表示返回数组的允许最大长度(一般情况下不设置)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;a|b|c|d|e&apos;;</span><br><span class="line">console.log(str.split(&apos;|&apos;));    //返回[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br><span class="line">console.log(str.split(&apos;|&apos;, 3));    //返回[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">console.log(str.split(&apos;&apos;));    //返回[&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;, &quot;|&quot;, &quot;d&quot;, &quot;|&quot;, &quot;e&quot;]</span><br><span class="line">也可以用正则来进行分割</span><br><span class="line"></span><br><span class="line">var str = &apos;a1b2c3d4e&apos;;</span><br><span class="line">console.log(str.split(/\d/)); //返回[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br></pre></td></tr></table></figure></p><h4 id="3-toLowerCase-和toUpperCase"><a href="#3-toLowerCase-和toUpperCase" class="headerlink" title="(3) toLowerCase()和toUpperCase()"></a>(3) toLowerCase()和toUpperCase()</h4><p>toLowerCase()方法可以把字符串中的大写字母转换为小写，toUpperCase()方法可以把字符串中的小写字母转换为大写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;JavaScript&apos;;</span><br><span class="line">console.log(str.toLowerCase());    //返回javascript</span><br><span class="line">console.log(str.toUpperCase());    //返回JAVASCRIPT</span><br></pre></td></tr></table></figure></p><h2 id="Array常用方法（主要是遍历方法）"><a href="#Array常用方法（主要是遍历方法）" class="headerlink" title="Array常用方法（主要是遍历方法）"></a>Array常用方法（主要是遍历方法）</h2><p><strong>forEach</strong><br>forEach() 方法指定数组的每项元素都执行一次传入的函数，返回值为undefined。<br>语法：arr.forEach(fn, thisArg)<br>fn 表示在数组每一项上执行的函数，接受三个参数：</p><p>value 当前正在被处理的元素的值<br>index 当前元素的数组索引<br>array 数组本身</p><p>thisArg 可选，用来当做fn函数内的this对象。<br>forEach 将为数组中每一项执行一次fn函数，那些已删除，新增或者从未赋值的项将被跳过（但不包括值为 undefined 的项）。遍历过程中，fn会被传入上述三个参数。</p><p><strong>every</strong><br>every() 方法使用传入的函数测试所有元素，只要其中有一个函数返回值为 false，那么该方法的结果为 false；如果全部返回 true，那么该方法的结果才为 true。因此 every 方法存在如下规律：</p><p>若需检测数组中存在元素大于100 （即 one &gt; 100），那么我们需要在传入的函数中构造 “false” 返回值 （即返回 item &lt;= 100），同时整个方法结果为 false 才表示数组存在元素满足条件；（简单理解为：若是单项判断，可用 one false ===&gt; false）</p><p>若需检测数组中是否所有元素都大于100 （即all &gt; 100）那么我们需要在传入的函数中构造 “true” 返回值 （即返回 item &gt; 100），同时整个方法结果为 true 才表示数组所有元素均满足条件。(简单理解为：若是全部判断，可用 all true ===&gt; true）</p><p>以下是鸭式辨型的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;0:10, 1:8, 2:25, length:3&#125;;</span><br><span class="line">var bool = Array.prototype.every.call(o,function(value, index, obj)&#123;</span><br><span class="line">  return value &gt;= 8;</span><br><span class="line">&#125;,o);</span><br><span class="line">console.log(bool);</span><br></pre></td></tr></table></figure></p><p><strong>some</strong><br>some() 方法刚好同 every() 方法相反，some测试数组元素时，只要有一个函数返回值为 true，则该方法返回true，若全部返回 false，则该方法返回false。some方法存在如下规律：</p><p>若需检测数组中存在元素大于100 (即 one &gt; 100)，那么我们需要在传入的函数中构造 “true” 返回值 (即返回 item &gt; 100)，同时整个方法结果为 true 才表示数组存在元素满足条件；（简单理解为：若是单项判断，可用 one true ===&gt; true）</p><p>若需检测数组中是否所有元素都大于100（即 all &gt; 100），那么我们需要在传入的函数中构造 “false” 返回值 （即返回 item &lt;= 100），同时整个方法结果为 false 才表示数组所有元素均满足条件。（简单理解为：若是全部判断，可用 all false ===&gt; false）</p><p>你注意到没有，some方法与includes方法有着异曲同工之妙，他们都是探测数组中是否拥有满足条件的元素，一旦找到，便返回true。多观察和总结这种微妙的关联关系，能够帮助我们深入理解它们的原理。</p><p><strong>filter</strong><br>filter() 方法使用传入的函数测试所有元素，并返回所有通过测试的元素组成的新数组。它就好比一个过滤器，筛掉不符合条件的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：arr.filter(fn, thisArg)</span><br><span class="line">var array = [18, 9, 10, 35, 80];</span><br><span class="line">var array2 = array.filter(function(value, index, array)&#123;</span><br><span class="line">  return value &gt; 20;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(array2); // [35, 80]</span><br></pre></td></tr></table></figure></p><p><strong>map</strong><br>map() 方法遍历数组，使用传入函数处理每个元素，并返回函数的返回值组成的新数组。<br>语法：arr.map(fn, thisArg)<br>参数介绍同 forEach 方法的参数介绍。</p><p><strong>reduce</strong><br>reduce() 方法接收一个方法作为累加器，数组中的每个值(从左至右) 开始合并，最终为一个值。<br>语法：arr.reduce(fn, initialValue)<br>fn 表示在数组每一项上执行的函数，接受四个参数：</p><p>previousValue 上一次调用回调返回的值，或者是提供的初始值<br>value 数组中当前被处理元素的值<br>index 当前元素在数组中的索引<br>array 数组自身</p><p>initialValue 指定第一次调用 fn 的第一个参数。<br>当 fn 第一次执行时：</p><p>如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 将等于 initialValue，此时 item 等于数组中的第一个值；<br>如果 initialValue 未被提供，那么 previousVaule 等于数组中的第一个值，item 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。<br>如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么fn不会被执行，数组的唯一值将被返回。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>pop,push,reverse,shift,sort,splice,unshift,fill(ES6),copyWithin(ES6) 会改变原数组<br>join,concat,indexOf,lastIndexOf,slice,toString,includes(ES7) 不会改变原数组<br>map,filter,some,every,reduce,forEach<br>和ES6新增的方法entries、find、findIndex、keys、values这些迭代方法不会改变原数组</strong></p><p>数组的这些方法之间存在很多共性，比如：<br><strong>所有插入元素的方法, 比如 push、unshift，一律返回数组新的长度；<br>所有删除元素的方法,比如 pop、shift、splice 一律返回删除的元素,者返回删除的多个元素组成的数组；<br>部分遍历方法,比如forEach、every、some、filter、map、find、findIndex，它们都包含function(value,index,array){} 和thisArg这样两个形参。</strong><br>Array.prototype的所有方法均具有鸭式辨型这种神奇的特性。它们不止可以用来处理数组对象，还可以处理类数组对象。例如javascript中一个纯天然的类数组对象字符串（String），像join方法（不改变当前对象自身）就完全适用，可惜的是Array.prototype中很多方法均会去试图修改当前对象的length属性，比如说pop、push、shift, unshift方法，操作String对象时，由于String对象的长度本身不可更改，这将导致抛出TypeError错误，Array.prototype本身就是一个数组，并且它的长度为0。</p><p><strong>几个注意点：</strong><br>shift,pop会返回那个被删除的元素<br>splice 会返回被删除元素组成的数组，或者为空数组<br>push 会返回新数组长度<br>some 在有true的时候停止<br>every 在有false的时候停止<br>上述的迭代方法可以在最后追加一个参数thisArg，它是执行 callback 时的 this 值</p><p>参考链接：<a href="http://riny.net/2012/the-summary-of-javascript-string" target="_blank" rel="noopener">http://riny.net/2012/the-summary-of-javascript-string</a></p>]]></content>
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Javascript难点</title>
      <link href="/blog/2018/05/15/JavaScript%E9%9A%BE%E7%82%B9/"/>
      <url>/blog/2018/05/15/JavaScript%E9%9A%BE%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>JavaScript引擎是单线程运行的，浏览器无论在什么时候都有且只有一个线程在运行JavaScript程序，浏览器内核实现允许多个线程异步执行，这些线程在内核制控下相互配合以保持同步。浏览器内核的实现至少有三个常驻线程：javascript引擎线程，界面渲染线程，浏览器事件触发线程，也有一些执行完就终止的线程，如Http请求线程，这些异步线程都会产生不同的异步事件，单线程的JavaScript引擎与另外那些线程进行互动通信，虽然每个浏览器内核实现细节不同，但这其中的调用原理都是大同小异。</p><h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><p>说到原型，就得提一下构造函数，首先看下面一个简单的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Dog(name,age)&#123;   </span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> dog1 = new Dog(<span class="string">"哈士奇"</span>,3);</span><br><span class="line"><span class="built_in">let</span> dog2 = new Dog(<span class="string">"泰迪"</span>,2);</span><br></pre></td></tr></table></figure></p><p>首先创造空的对象，再让this指向这个对象，通过this.name进行赋值，最终返回this，这其实也是new 一个对象的过程。</p><p>其实： let obj = {} 是 let obj = new Object()的语法糖； let arr = [] 是 let arr = new Array()的语法糖； function Dog(){} 是 let Dog = new Fucntion()的语法糖。</p><p>在js中，所有对象都是Object的实例，并继承Object.prototype的属性和方法，但是有一些是隐性的。</p><p><strong>看一下原型的规则：</strong></p><p>1.所有的引用类型（包括数组，对象，函数）都具有对象特性；可自由扩展属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.attribute = <span class="string">"原型"</span>;</span><br><span class="line">var arr = [];</span><br><span class="line">arr.attribute = <span class="string">"作用域"</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn1</span></span> () &#123;&#125;</span><br><span class="line">fn1.attribute = <span class="string">"闭包"</span>;</span><br></pre></td></tr></table></figure></p><p>2.所有的引用类型（包括数组，对象，函数）都有隐性原型属性（<strong>proto</strong>）,值也是一个普通的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(obj.__proto__);</span><br></pre></td></tr></table></figure></p><p>3.所有的函数，都有一个prototype属性，值也是一个普通的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(obj.prototype);</span><br></pre></td></tr></table></figure></p><p>4.所有的引用类型的<strong>proto</strong>属性值都指向构造函数的prototype属性值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(obj.__proto__ === Object.prototype); // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>5.当试图获取对象属性时，如果对象本身没有这个属性，那就会去他的<strong>proto</strong>（prototype）中去寻找。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Dog(name)&#123; </span><br><span class="line">   this.name = name; </span><br><span class="line">&#125; </span><br><span class="line">Dog.prototype.callName = <span class="function"><span class="title">function</span></span> ()&#123; </span><br><span class="line">   console.log(this.name,<span class="string">"wang wang"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> dog1 = new Dog(<span class="string">"Three Mountain"</span>); </span><br><span class="line">dog1.printName = <span class="function"><span class="title">function</span></span> ()&#123; </span><br><span class="line">   console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">dog1.callName();  // Three Mountain wang wang</span><br><span class="line">dog1.printName(); // Three Mountain</span><br></pre></td></tr></table></figure><p>原型链如下图：<br>找一个属性，首先会在f.<strong>proto</strong>中去找，因为属性值为一个对象，那么就会去f.<strong>proto</strong>.<strong>proto</strong>去找，同理如果还没找到，就会一直向上去查找，直到结果为null为止，这个串起来的链即为原型链。<br><img src="http://jingchao.xyz/blog/images/proto.jpg" alt=""></p><h3 id="作用域及闭包"><a href="#作用域及闭包" class="headerlink" title="作用域及闭包"></a>作用域及闭包</h3><p>说到作用域，肯定会想到是执行上下文。每个函数都有自己的excution context，和variable object。这些环境用于储存上下文中的变量，函数声明，参数等。只有函数才能制造作用域。<br><strong>PS：for  if  else 不能创造作用域</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(a) ; // undefined</span><br><span class="line">var a = 1;</span><br><span class="line"></span><br><span class="line">//可理解为</span><br><span class="line">var a;</span><br><span class="line">console.log(a);  // undefined</span><br><span class="line">a = 1;</span><br></pre></td></tr></table></figure></p><p>执行console.log时，a只是被声明出来，并没有赋值；所以结果当然是undefined。</p><p><strong>this</strong></p><p>本质上来说，在js里this是一个指向函数执行环境的指针，this永远指向最后调用它的对象，并且在执行时才能获取值，定义是无法确认它的值。箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123; </span><br><span class="line">    name : <span class="string">"A"</span>, </span><br><span class="line">    fn : <span class="keyword">function</span> （）&#123;</span><br><span class="line">        console.log (this.name) </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">a.fn() // this === a </span><br><span class="line">a 调用了fn() 所以此时this为a</span><br><span class="line"></span><br><span class="line">a.fn.call (&#123;name : <span class="string">"B"</span>&#125;) // this === &#123;name : <span class="string">"B"</span>&#125; </span><br><span class="line">使用call(),将this的值指定为&#123;name:<span class="string">"B"</span>&#125;</span><br><span class="line"></span><br><span class="line">var fn1 = a.fn </span><br><span class="line">fn1() // this === window</span><br></pre></td></tr></table></figure></p><p>虽然指定fn1 = a.fn，但是调用是有window调用，所以 this 为window</p><p>this有多种使用场景，下面会主要介绍4个使用场景：</p><p><strong>1.作为构造函数执行</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>  Student(name,age) &#123;</span><br><span class="line">    this.name = name           // this === s</span><br><span class="line">    this.age = age             // this === s</span><br><span class="line">    //<span class="built_in">return</span>  this</span><br><span class="line">&#125;</span><br><span class="line">var s = new Student(<span class="string">"hpu"</span>,22)</span><br></pre></td></tr></table></figure></p><p>首先new 字段会创建一个空的对象，然后调用apply()函数，将this指向这个空对象。这样的话，函数内部的this就会被空对象代替。</p><p><strong>2.作为普通函数执行</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>  <span class="function"><span class="title">fn</span></span> () &#123;</span><br><span class="line">    console.log (this)       // this === window</span><br><span class="line">&#125;</span><br><span class="line">fn ()</span><br></pre></td></tr></table></figure></p><p><strong>3.作为对象属性执行</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name : <span class="string">"A"</span>,</span><br><span class="line">    printName : <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log (this.name)  // this === obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.printName ()</span><br></pre></td></tr></table></figure></p><p><strong>4.call()，apply()，bind()</strong></p><p>三个函数可以修改this的指向，具体往下看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = <span class="string">"小明"</span> , age = <span class="string">"17"</span></span><br><span class="line">var obj = &#123; </span><br><span class="line">    name : <span class="string">"安妮"</span>, </span><br><span class="line">    objAge : this.age, </span><br><span class="line">    fun : <span class="function"><span class="title">function</span></span> () &#123; </span><br><span class="line">            console.log ( this.name + <span class="string">"今年"</span> + this.age ) </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line">console.log(obj.objAge) // 17 </span><br><span class="line">obj.fun() // 安妮今年undefined</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;小明&quot; , age = &quot;17&quot; </span><br><span class="line">var obj = &#123; </span><br><span class="line">    name : &quot;安妮&quot;, </span><br><span class="line">    objAge ：this.age, </span><br><span class="line">    fun : function (like,dislike) &#123; </span><br><span class="line">              console.log (this.name + &quot;今年&quot; + this.age ，&quot;喜欢吃&quot; </span><br><span class="line">              + like + &quot;不喜欢吃&quot; + dislike) </span><br><span class="line">           &#125; </span><br><span class="line">    &#125; </span><br><span class="line">var a = &#123; name : &quot;Jay&quot;, age : 23 &#125; </span><br><span class="line">obj.fun.call(a,&quot;苹果&quot;,&quot;香蕉&quot;) // Jay今年23 喜欢吃苹果不喜欢吃香蕉 </span><br><span class="line">obj.fun.apply(a,[&quot;苹果&quot;,&quot;香蕉&quot;]) // Jay今年23 喜欢吃苹果不喜欢吃香蕉 </span><br><span class="line">obj.fun.bind(a,&quot;苹果&quot;,&quot;香蕉&quot;)() // Jay今年23 喜欢吃苹果不喜欢吃香蕉</span><br></pre></td></tr></table></figure><p>首先call，apply，bind第一个参数都是this指向的对象，call和apply如果第一个参数指向null或undefined时，那么this会指向windows对象。</p><p>call，apply，bind的执行方式如上例所示。call，apply都是改变上下文中的this，并且是立即执行的。bind方法可以让对应的函数想什么时候调用就什么时候调用。</p><p><strong>闭包</strong></p><p>闭包的概念很抽象，看下面的例子理解什么叫闭包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">a</span></span>()&#123;</span><br><span class="line">  var n = 0;</span><br><span class="line">  this.fun = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    n++; </span><br><span class="line">    console.log(n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var c = new a();</span><br><span class="line">c.fun();  //1</span><br><span class="line">c.fun();  //2</span><br></pre></td></tr></table></figure></p><p>闭包就是能够读取其他函数内部变量的函数。在js中只有函数内部的子函数才能读取局部变量。所以可以简单的理解为：定义在内部函数的函数。</p><p>用途主要有两个：</p><p>1）前面提到的，读取函数内部的变量。</p><p>2）让变量值始终保持在内存中。</p><h3 id="异步和单线程"><a href="#异步和单线程" class="headerlink" title="异步和单线程"></a>异步和单线程</h3><p>先感受下异步<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">"start"</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">"medium"</span>);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">console.log(<span class="string">"end"</span>);</span><br></pre></td></tr></table></figure></p><p>使用异步后，打印的顺序为 start-&gt; end-&gt;medium，因为没有阻塞。</p><p><strong>异步产生原因</strong></p><p>首先因为js为单线程，也就是说CPU同一时间只能处理一个事务。得按顺序，一个一个处理。</p><p>如上例所示，第一步：执行第一行打印 “start”；第二步：执行setTimeout，将其中的函数分存起来，等待时间结束后执行；第三步：执行最后一行，打印“end”；第四步：处于空闲状态，查看暂存中，是否有可执行的函数；第五步：执行分存函数。</p><p><strong>js引擎单线程</strong></p><p>js的主要用途是与用户互动，以及操作DOM，这决定它只能是单线程。例：一个线程要添加DOM节点，一个线程要删减DOM节点，容易造成分歧。</p><p>为了更好使用多CPU，H5提供了web Worker 标准，允许js创建多线程，但是子线程受到主线程控制，而且不得操作DOM。</p><p>任务列队</p><p>单线程就意味着，所有的任务都要排队，前一个结束，才会执行后面的任务。如果列队是因为计算量大，CPU忙不过来，倒也算了。但是更多的时候，CPU是闲置的，因为IO设备处理得很慢，例如 ajax读取网络数据。js设计者便想到，主线程完全可以不管IO设备，将其挂起，然后执行后面的任务。等后面的任务结束掉，在反过头来处理挂起的任务。</p><p>梳理一下：</p><p>1）所有的同步任务都在主线程上执行，形成一个执行栈</p><p>2）除了主线程之外，还存在一个任务列队，只要一步任务有了运行结果，就在任务列队中植入一个时间</p><p>3）主线程完成所有任务，就会读取列队任务，并将其执行</p><p>4）重复上面三步</p><p>只要主线程空了，就会读取任务列队，这就是js的运行机制，也被称为 event loop（事件循环）。</p>]]></content>
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grammer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>集群和负载均衡</title>
      <link href="/blog/2018/05/06/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/blog/2018/05/06/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      <content type="html"><![CDATA[<p>一个庞大的高访问量的业务系统，需要高性能、可靠的服务器框架支撑。高性能要求服务器在巨大压力下仍然高速运行，读写返回正确的业务信息，前端用户体验良好。可靠性要求服务器出现宕机、罢工等情况，可以及时恢复服务器正常工作状态，支持业务系统24小时健康运行。使用<strong>缓存、读写分离技术</strong>提高服务器访问资源速度，解决大访问量资源拥堵问题；使用<strong>负载均衡与高可用技术</strong>提高服务器响应速度以及服务器稳定性，解决服务器处理大用户量请求问题以及服务器宕机的及时恢复能力。同时，需要部署运维监控平台，监控服务器上服务程序与资源使用情况。</p><p>这样一个业务系统基础架构可以划分下面几个模块：<strong>负载均衡与代理、Web主站服务、APP接口服务、图片服务器、数据库与缓存服务。</strong>这里负载均衡和代理主要是两个作用：实现多台机器按照算法轮流工作，分担服务压力，当一台机器宕机或者罢工，其他机器也可以继续运行；代理隐藏服务内部真实结构，多台对外提供统一地址，运行相同业务系统，后文会详细介绍负载均衡。</p><p>主站框架是一个Web服务器（apache、tomcat、nginx等）集群，集群中全部机器运行相同业务系统。通过负载均衡代理与客户端通讯，每一次通讯只有一台机器为当前客户端服务。需要解决session共享问题，否则将会丢失用户的登录状态，在用户体验方面有逻辑错误。常见的共享session方法有数据库共享、cookie共享、内存共享。使用最多的是memcache共享方式，memcache把多个服务器的共享内存拼接成一块大的内存使用，保存用户的session信息。Tomcat服务集群可以简单配置memcache共享内存，PHP中也可以直接配置设置memcache共享内存。</p><p>Nginx负载解决session的方式：ip_hash、sticky。ip_hash根据IP保存响应服务器，在一张存储表单中，IP对应上次访问的服务器，以后来自于该IP的访问都使用这个这台服务器，解决session问题，存在局限性影响负载均衡的功能。Sticky使用cookie的方式解决session共享问题，其实是避开session共享。Sticky把cookie与服务器绑定，存储于客户端缓存当中，客户端再次访问时直接进入到cookie绑定的服务器，关闭客户端session也随之消失。</p><p><strong>缓存服务</strong>可以提高服务的响应速度，处理及时性要求高的数据时，数据首先进入缓存，然后通过消息队列写入到数据库。从数据库查询出来的实时数据也可以保存在缓存中，在缓存中直接提供用户访问，执行用户操作数据请求，再把数据返回数据库。</p><p>Redis是一款出色的缓存服务器，内存级别的键值对数据库，支持丰富数据结构，数据库操作命令也是很齐全。最重要是Redis操作速度非常快，满足缓存服务器需求。Redis提供单机的分片集群，单机硬件性能要求比较高。Redis也可以进行分布式部署，搭建分布式缓存服务。</p><p>安全配置：隐藏常见系统服务信息、配置用户权限、开启防火墙、关闭无用系统服务、定期更新系统<br>风险评估：进行渗透测试、漏洞扫描<br>安全防御：配置IDS\IPS、进行源代码审计、DDOS防御、恶意代码检测</p><p>配置运维监控平台，实时监控服务器的健康状况。CPU、内存、磁盘、输入输出、网络性能等参数，配置报警规则，触发报警是立即调用API接口或者第三方回调，发送报警信息到邮箱、微信等。同时，自定监控数据项，检测Web服务、数据库服务、后台程序等运行状态，连续出现拒绝服务行为立刻报警，通知管理员。</p><h3 id="负载均衡介绍"><a href="#负载均衡介绍" class="headerlink" title="负载均衡介绍"></a>负载均衡介绍</h3><p>负载均衡（Load Balance）是建立在现有网络结构之上，提供一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。就是分摊任务到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p><p>负载均衡，核心就是网络流量分发，服务器负载均衡根据LB设备处理到的报文层次，分为四层服务器负载均衡（TCP，UDP）和七层负载均衡（HTTP，HTTPS等），四层处理到IP包的IP头，不解析报文四层以上载荷（L4 SLB），基本就是根据连接信息（TCP）或者本身的特征（源IP，目标IP）等做；七层处理到报文载荷部分，比如HTTP，RTSP，SIP报文头，有时也包括报文内容部分，可以用域名（HTTP头里的Host），URL，Cookie，Header这些信息来做。四层LB可以说是作为路由进行流量转发，七层LB常称作代理。</p><p>负载均衡根据所采用的设备对象（软硬件负载均衡），应用的OSI网络层次（网络层次上的负载均衡），及应用的地理结构（本地/全局负载均衡）等来分类。负载均衡现在比较新的做法是用dpdk这种内核bypass方案做的负载均衡，绕过了linux内核比较复杂的网络协议栈，因此性能会有明显的提升（轻松跑满万兆网卡）。 </p><p>根据负载均衡所作用在 OSI 模型的位置不同，负载均衡可以大概分为以下几类：</p><p><strong>二层负载均衡（mac）</strong></p><p>根据OSI模型分的二层负载，一般是用虚拟mac地址方式，外部对虚拟MAC地址请求，负载均衡接收后分配后端实际的MAC地址响应。</p><p><strong>三层负载均衡（ip）</strong></p><p>一般采用虚拟IP地址方式，外部对虚拟的ip地址请求，负载均衡接收后分配后端实际的IP地址响应。</p><p><strong>四层负载均衡（tcp）</strong></p><p>在三层负载均衡的基础上，用ip+port接收请求，再转发到对应的机器。</p><p><strong>七层负载均衡（http）</strong></p><p>根据虚拟的url或IP，主机名接收请求，再转向相应的处理服务器。反向代理，就是通过代理来做（Nginx）。由于流量都会过LB，因此可以做到比较精细的流量分发（比如各种权重，七层的各种转发规则）。坏处就是代理本身可能成为瓶颈，以及过了一层代理造成网络延时的增加，而代理本身也会有一定成本，因此实现成本较高。</p><p>在实际应用中，比较常见的就是四层负载及七层负载。这里也重点说下这两种负载。</p><h3 id="一、四层负载均衡（基于IP-端口的负载均衡）"><a href="#一、四层负载均衡（基于IP-端口的负载均衡）" class="headerlink" title="一、四层负载均衡（基于IP+端口的负载均衡）"></a>一、四层负载均衡（基于IP+端口的负载均衡）</h3><p>所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><ol><li><p>在三层负载均衡的基础上，通过发布三层的IP地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。</p></li><li><p>以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。</p></li><li><p>对应的负载均衡器称为四层交换机（L4 switch），主要分析IP层及TCP/UDP层，实现四层负载均衡。此种负载均衡器不理解应用协议（如HTTP/FTP/MySQL等等）<br>要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。</p></li><li><p>实现四层负载均衡的软件有：<br>F5：硬件负载均衡器，功能很好，但是成本很高。<br>lvs：重量级的四层负载软件<br>nginx：轻量级的四层负载软件，带缓存功能，正则表达式较灵活<br>haproxy：模拟四层转发，较灵活</p></li></ol><h3 id="二、七层负载均衡（基于虚拟的URL或主机IP的负载均衡）"><a href="#二、七层负载均衡（基于虚拟的URL或主机IP的负载均衡）" class="headerlink" title="二、七层负载均衡（基于虚拟的URL或主机IP的负载均衡）"></a>二、七层负载均衡（基于虚拟的URL或主机IP的负载均衡）</h3><p>所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><ol><li><p>在四层负载均衡的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。</p></li><li><p>以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。</p></li><li><p>对应的负载均衡器称为七层交换机（L7 switch），除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息，实现七层负载均衡。此种负载均衡器能理解应用协议。</p></li><li><p>实现七层负载均衡的软件有：<br>haproxy：天生负载均衡技能，全面支持七层代理，会话保持，标记，路径转移；<br>nginx：只在http协议和mail协议上功能比较好，性能与haproxy差不多；<br>apache：功能较差<br>Mysql proxy：功能尚可</p></li></ol><p>四层和七层负载均衡的区别，举个例子形象的说明：四层负载均衡就像银行的自助排号机，每一个达到银行的客户根据排号机的顺序，选择对应的窗口接受服务；而七层负载均衡像银行大堂经理，先确认客户需要办理的业务，再安排排号。这样办理理财、存取款等业务的客户，会根据银行内部资源得到统一协调处理，加快客户业务办理流程。</p><table><thead><tr><th>特征</th><th style="text-align:center">四层负载均衡</th><th style="text-align:center">七层负载均衡</th></tr></thead><tbody><tr><td>基于</td><td style="text-align:center">基于IP+Port的</td><td style="text-align:center">基于虚拟的URL或主机IP等</td></tr><tr><td>类似</td><td style="text-align:center">路由器</td><td style="text-align:center">代理服务器 </td></tr><tr><td>握手次数</td><td style="text-align:center">1次</td><td style="text-align:center">2次</td></tr><tr><td>复杂度</td><td style="text-align:center">低</td><td style="text-align:center">高 </td></tr><tr><td>性能</td><td style="text-align:center">高，无需解析内容</td><td style="text-align:center">中，需要算法识别 URL，Cookie 和 HTTP head 等信息  </td></tr><tr><td>安全性</td><td style="text-align:center">低，无法识别 DDoS等攻击</td><td style="text-align:center">高， 可以防御SYN cookie以SYN flood等</td></tr><tr><td>额外</td><td style="text-align:center">无</td><td style="text-align:center">会话保持，图片压缩，防盗链等</td></tr></tbody></table><p>总结：从上面的对比看来四层负载与七层负载最大的区别就是效率与功能的区别。四层负载架构设计比较简单，无需解析具体的消息内容，在网络吞吐量及处理能力上会相对比较高，而七层负载均衡的优势则体现在功能多，控制灵活强大。在具体业务架构设计时，使用七层负载或者四层负载还得根据具体的情况综合考虑。</p><p>以下介绍下四层七层负载均衡实现方式</p><h4 id="一、http重定向"><a href="#一、http重定向" class="headerlink" title="一、http重定向"></a>一、http重定向</h4><p>当http代理（比如浏览器）向web服务器请求某个URL后，web服务器可以通过http响应头信息中的Location标记来返回一个新的URL。这意味着HTTP代理需要继续请求这个新的URL，完成自动跳转。</p><p>性能缺陷：<br>1、吞吐率限制<br>主站点服务器的吞吐率平均分配到了被转移的服务器。现假设使用RR（Round Robin）调度策略，子服务器的最大吞吐率为1000reqs/s，那么主服务器的吞吐率要达到3000reqs/s才能完全发挥三台子服务器的作用，那么如果有100台子服务器，那么主服务器的吞吐率可想而知得有大？相反，如果主服务的最大吞吐率为6000reqs/s，那么平均分配到子服务器的吞吐率为2000reqs/s，而现子服务器的最大吞吐率为1000reqs/s，因此就得增加子服务器的数量，增加到6个才能满足。</p><p>2、重定向访问深度不同<br>有的重定向一个静态页面，有的重定向相比复杂的动态页面，那么实际服务器的负载差异是不可预料的，而主站服务器却一无所知。因此整站使用重定向方法做负载均衡不太好。</p><p>我们需要权衡转移请求的开销和处理实际请求的开销，前者相对于后者越小，那么重定向的意义就越大，例如下载。你可以去很多镜像下载网站试下，会发现基本下载都使用了Location做了重定向。</p><h4 id="二、DNS负载均衡"><a href="#二、DNS负载均衡" class="headerlink" title="二、DNS负载均衡"></a>二、DNS负载均衡</h4><p>DNS负责提供域名解析服务，当访问某个站点时，实际上首先需要通过该站点域名的DNS服务器来获取域名指向的IP地址，在这一过程中，DNS服务器完成了域名到IP地址的映射，同样，这样映射也可以是一对多的，这时候，DNS服务器便充当了负载均衡调度器，它就像http重定向转换策略一样，将用户的请求分散到多台服务器上，但是它的实现机制完全不同。</p><p>相比http重定向，基于DNS的负载均衡完全节省了所谓的主站点，或者说DNS服务器已经充当了主站点的职能。但不同的是，作为调度器，DNS服务器本身的性能几乎不用担心。因为DNS记录可以被用户浏览器或者互联网接入服务商的各级DNS服务器缓存，只有当缓存过期后才会重新向域名的DNS服务器请求解析。也说是DNS不存在http的吞吐率限制，理论上可以无限增加实际服务器的数量。</p><p>特性:<br>1、可以根据用户IP来进行智能解析。DNS服务器可以在所有可用的A记录中寻找离用记最近的一台服务器。</p><p>2、动态DNS：在每次IP地址变更时，及时更新DNS服务器。当然，因为缓存，一定的延迟不可避免。</p><p>不足：<br>1、没有用户能直接看到DNS解析到了哪一台实际服务器，加服务器运维人员的调试带来了不便。</p><p>2、策略的局限性。例如你无法将HTTP请求的上下文引入到调度策略中，而在前面介绍的基于HTTP重定向的负载均衡系统中，调度器工作在HTTP层面，它可以充分理解HTTP请求后根据站点的应用逻辑来设计调度策略，比如根据请求不同的URL来进行合理的过滤和转移。</p><p>3、如果要根据实际服务器的实时负载差异来调整调度策略，这需要DNS服务器在每次解析操作时分析各服务器的健康状态，对于DNS服务器来说，这种自定义开发存在较高的门槛，更何况大多数站点只是使用第三方DNS服务。</p><p>4、DNS记录缓存，各级节点的DNS服务器不同程序的缓存会让你晕头转向。</p><p>5、基于以上几点，DNS服务器并不能很好地完成工作量均衡分配，最后，是否选择基于DNS的负载均衡方式完全取决于你的需要。</p><h4 id="三、反向代理负载均衡"><a href="#三、反向代理负载均衡" class="headerlink" title="三、反向代理负载均衡"></a>三、反向代理负载均衡</h4><p>这个肯定大家都有所接触，因为几乎所有主流的Web服务器都热衷于支持基于反向代理的负载均衡。它的核心工作就是转发HTTP请求。</p><p>相比前面的HTTP重定向和DNS解析，反向代理的调度器扮演的是用户和实际服务器中间人的角色：</p><p>1、任何对于实际服务器的HTTP请求都必须经过调度器</p><p>2、调度器必须等待实际服务器的HTTP响应，并将它反馈给用户（前两种方式不需要经过调度反馈，是实际服务器直接发送给用户）</p><p>特性：<br>1、调度策略丰富。例如可以为不同的实际服务器设置不同的权重，以达到能者多劳的效果。</p><p>2、对反向代理服务器的并发处理能力要求高，因为它工作在HTTP层面。</p><p>3、反向代理服务器进行转发操作本身是需要一定开销的，比如创建线程、与后端服务器建立TCP连接、接收后端服务器返回的处理结果、分析HTTP头部信息、用户空间和内核空间的频繁切换等，虽然这部分时间并不长，但是当后端服务器处理请求的时间非常短时，转发的开销就显得尤为突出。例如请求静态文件，更适合使用前面介绍的基于DNS的负载均衡方式。</p><p>4、反向代理服务器可以监控后端服务器，比如系统负载、响应时间、是否可用、TCP连接数、流量等，从而根据这些数据调整负载均衡的策略。</p><p>5、反射代理服务器可以让用户在一次会话周期内的所有请求始终转发到一台特定的后端服务器（粘滞会话），这样的好处一是保持session的本地访问，二是防止后端服务器的动态内存缓存的资源浪费。</p><h4 id="四、IP负载均衡-LVS-NAT"><a href="#四、IP负载均衡-LVS-NAT" class="headerlink" title="四、IP负载均衡(LVS-NAT)"></a>四、IP负载均衡(LVS-NAT)</h4><p>NAT服务器:它工作在传输层，它可以修改发送来的IP数据包，将数据包的目标地址修改为实际服务器地址。</p><p>数据的流向：</p><p>客户端 –&gt; Load Balancer –&gt; RS –&gt; Load Balancer –&gt; 客户端</p><p><img src="http://jingchao.xyz/blog/images/nat.webp" alt=""></p><p>从Linux2.4内核开始，其内置的Neftilter模块在内核中维护着一些数据包过滤表，这些表包含了用于控制数据包过滤的规则。可喜的是，Linux提供了iptables来对过滤表进行插入、修改和删除等操作。更加令人振奋的是，Linux2.6.x内核中内置了IPVS模块，它的工作性质类型于Netfilter模块，不过它更专注于实现IP负载均衡。</p><p>IPVS的管理工具是ipvsadm，它为提供了基于命令行的配置界面，可以通过它快速实现负载均衡系统。这就是大名鼎鼎的LVS(Linux Virtual Server，Linux虚拟服务器)。</p><p>1、打开调度器的数据包转发选项</p><p>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</p><p>2、检查实际服务器是否已经将NAT服务器作为自己的默认网关，如果不是，如添加</p><p>route add default gw xx.xx.xx.xx</p><p>3、使用ipvsadm配置</p><p>ipvsadm -A -t 111.11.11.11:80 -s rr</p><p>添加一台虚拟服务器，-t 后面是服务器的外网ip和端口，-s rr是指采用简单轮询的RR调度策略（这属于静态调度策略，除此之外，LVS还提供了系列的动态调度策略，比如最小连接（LC）、带权重的最小连接（WLC），最短期望时间延迟（SED）等）</p><p>ipvsadm -a -t 111.11.11.11:80 -r 10.10.120.210:8000 -m</p><p>ipvsadm -a -t 111.11.11.11:80 -r 10.10.120.211:8000 -m</p><p>添加两台实际服务器（不需要有外网ip），-r后面是实际服务器的内网ip和端口，-m表示采用NAT方式来转发数据包</p><p>运行ipvsadm -L -n可以查看实际服务器的状态。这样就大功告成了。</p><p>实验证明使用基于NAT的负载均衡系统。作为调度器的NAT服务器可以将吞吐率提升到一个新的高度，几乎是反向代理服务器的两倍以上，这大多归功于在内核中进行请求转发的较低开销。但是一旦请求的内容过大时，不论是基于反向代理还是NAT，负载均衡的整体吞吐量都差距不大，这说明对于一开销较大的内容，使用简单的反向代理来搭建负载均衡系统是值考虑的。</p><p>这么强大的系统还是有它的瓶颈，那就是NAT服务器的网络带宽，包括内部网络和外部网络。当然可以配备千兆交换机或万兆交换机，甚至负载均衡硬件设备，除了这另一个简单有效的办法就是将基于NAT的集群和前面的DNS混合使用，比如５个100Mbps出口宽带的集群，然后通过DNS来将用户请求均衡地指向这些集群，同时，你还可以利用DNS智能解析实现地域就近访问。这样的配置对于大多数业务是足够了，但是对于提供下载或视频等服务的大规模站点，NAT服务器还是不够出色。</p><h4 id="五、直接路由-LVS-DR"><a href="#五、直接路由-LVS-DR" class="headerlink" title="五、直接路由(LVS-DR)"></a>五、直接路由(LVS-DR)</h4><p>NAT是工作在网络分层模型的传输层（第四层），而直接路由是工作在数据链路层（第二层），貌似更屌些。它通过修改数据包的目标MAC地址（没有修改目标IP），将数据包转发到实际服务器上，不同的是，实际服务器的响应数据包将直接发送给客户羰，而不经过调度器。</p><p>数据的流向：</p><p>客户端 –&gt; Load Balancer –&gt; RS –&gt; 客户端</p><p><img src="http://jingchao.xyz/blog/images/dr.webp" alt=""></p><p>1、网络设置</p><p>这里假设一台负载均衡调度器，两台实际服务器，购买三个外网ip，一台机一个，三台机的默认网关需要相同，最后再设置同样的ip别名，这里假设别名为10.10.120.193。这样一来，将通过10.10.120.193这个IP别名来访问调度器，你可以将站点的域名指向这个IP别名。</p><p>2、将ip别名添加到回环接口lo上</p><p>这是为了让实际服务器不要去寻找其他拥有这个IP别名的服务器，在实际服务器中运行：</p><p>另外还要防止实际服务器响应来自网络中针对IP别名的ARP广播，为此还要执行：</p><p>echo “1” &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore</p><p>echo “2” &gt; /proc/sys/net/ipv4/conf/lo/arp_announce</p><p>echo “1” &gt; /proc/sys/net/ipv4/conf/all/arp_ignore</p><p>echo “1” &gt; /proc/sys/net/ipv4/conf/all/arp_announce</p><p>配置完了就可以使用ipvsadm配置LVS-DR集群了</p><p>ipvsadm -A -t 10.10.120.193:80 -s rr</p><p>ipvsadm -a -t 10.10.120.193:80 -r 10.10.120.210:8000 -g</p><p>ipvsadm -a -t 10.10.120.193:80 -r 10.10.120.211:8000 -g</p><p>-g 就意味着使用直接路由的方式转发数据包</p><p>LVS-DR 相较于LVS-NAT的最大优势在于LVS-DR不受调度器宽带的限制，例如假设三台服务器在WAN交换机出口宽带都限制为10Mbps，只要对于连接调度器和两台实际服务器的LAN交换机没有限速，那么，使用LVS-DR理论上可以达到20Mbps的最大出口宽带，因为它的实际服务器的响应数据包可以不经过调度器而直接发往用户端啊，所以它与调度器的出口宽带没有关系，只能自身的有关系。而如果使用LVS-NAT，集群只能最大使用10Mbps的宽带。所以，越是响应数据包远远超过请求数据包的服务，就越应该降低调度器转移请求的开销，也就越能提高整体的扩展能力，最终也就越依赖于WAN出口宽带。</p><p>总的来说，LVS-DR适合搭建可扩展的负载均衡系统，不论是Web服务器还是文件服务器，以及视频服务器，它都拥有出色的性能。前提是你必须为实际器购买一系列的合法IP地址。</p><h4 id="六、IP隧道-LVS-TUN"><a href="#六、IP隧道-LVS-TUN" class="headerlink" title="六、IP隧道(LVS-TUN)"></a>六、IP隧道(LVS-TUN)</h4><p>基于IP隧道的请求转发机制：将调度器收到的IP数据包封装在一个新的IP数据包中，转交给实际服务器，然后实际服务器的响应数据包可以直接到达用户端。目前Linux大多支持，可以用LVS来实现，称为LVS-TUN，与LVS-DR不同的是，实际服务器可以和调度器不在同一个WANt网段，调度器通过IP隧道技术来转发请求到实际服务器，所以实际服务器也必须拥有合法的IP地址。</p><p>总体来说，LVS-DR和LVS-TUN都适合响应和请求不对称的Web服务器，如何从它们中做出选择，取决于你的网络部署需要，因为LVS-TUN可以将实际服务器根据需要部署在不同的地域，并且根据就近访问的原则来转移请求，所以有类似这种需求的，就应该选择LVS-TUN。</p>]]></content>
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>git简要教程</title>
      <link href="/blog/2018/04/26/git%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B/"/>
      <url>/blog/2018/04/26/git%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h3><p>Git的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure></p><h3 id="一、-创建与合并分支"><a href="#一、-创建与合并分支" class="headerlink" title="一、 创建与合并分支"></a>一、 创建与合并分支</h3><p>1、 从master分支创建dev分支并切换到dev分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure></p><p>其中，git checkout -b dev 等价于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br><span class="line"></span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure></p><p>查看本地当前的分支，分支前面带“*”表示当前分支，剩下的分支表示本地有的分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><p>查看远程全部的分支，白色的表示本地有的，红色的表示本地没有，仅在远程存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure></p><p>2、修改代码、提交代码（当前的操作是在dev分支上进行）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add a.html</span><br><span class="line"></span><br><span class="line">git commit -m &quot;提交文件a.html&quot;</span><br></pre></td></tr></table></figure></p><p>3、分支合并(将dev合并到master)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line"></span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure></p><p>4、合并完成后，删除dev分支.(删除dev分支时，注意我们当前所在的分支不能是dev分支)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure></p><p>5、删除后，查看分支(此时看不到dev分支了)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><p>6、总结 ：工作中经常从master创建新的分支，具体操作如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">master创建新分支：</span><br><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">git checkout -b  issues1234</span><br><span class="line"></span><br><span class="line">git push origin issues1234</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m &quot;***&quot;</span><br><span class="line"></span><br><span class="line">git push origin issues1234</span><br></pre></td></tr></table></figure></p><p>注意：将本地分支branch1推到远端的branch2操作步骤：git push origin branch1:branch2</p><p>7、删除分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -D   issues1234  //本地强制删除分支issues1234</span><br><span class="line"></span><br><span class="line">git push origin  :issues1234  //推到远程</span><br></pre></td></tr></table></figure></p><h3 id="二、-解决冲突"><a href="#二、-解决冲突" class="headerlink" title="二、 解决冲突"></a>二、 解决冲突</h3><p>1、发生冲突的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure></p><p>其中，git使用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记文件中自己和别人产生冲突的部分。</p><p>在&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======之间为自己的代码；<br>=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间为别人的代码。</p><p>如果保留自己的代码，将别人的代码删掉即可。</p><p>2、冲突解决后提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add ***</span><br><span class="line"></span><br><span class="line">git commit -m &quot;fix conflict&quot;</span><br><span class="line"></span><br><span class="line">git push origin 分支名</span><br></pre></td></tr></table></figure></p><h3 id="三、Bug分支"><a href="#三、Bug分支" class="headerlink" title="三、Bug分支"></a>三、Bug分支</h3><p>1、储藏更改:将当前更改的代码储藏起来，等以后恢复使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></p><p>2、恢复储藏的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git stash pop //恢复的同时把stash内容删掉</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">git stash apply  //恢复stash，但是stash内容并不删除</span><br><span class="line"></span><br><span class="line">git stash drop //在上面操作的基础上，以此来删除stash</span><br><span class="line"></span><br><span class="line">注： git stash list //查看全部的stash列表</span><br></pre></td></tr></table></figure></p><p>3、将stash空间清空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure></p><p>4、git stash pop 和 git stash apply 区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原来git stash pop stash@&#123;id&#125;命令会在执行后将对应的stash id 从stash list里删除</span><br><span class="line"></span><br><span class="line">而 git stash apply stash@&#123;id&#125; 命令则会继续保存stash id。</span><br></pre></td></tr></table></figure></p><h3 id="四、版本回退"><a href="#四、版本回退" class="headerlink" title="四、版本回退"></a>四、版本回退</h3><p>1、回退至上一个版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure></p><p>2、回退至指定版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard  版本号</span><br></pre></td></tr></table></figure></p><p>3、查看以往版本号(本地的commit)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></p><p>4、查看各版本号及信息(所有的commit：本地commit + 其他同事的commit)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></p><h3 id="五、撤销修改"><a href="#五、撤销修改" class="headerlink" title="五、撤销修改"></a>五、撤销修改</h3><p>1、撤销修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  checkout -- a.html</span><br></pre></td></tr></table></figure></p><p>分两种情况分析：<br>①： 还没有执行 git add 操作，执行上面的操作后，会恢复到和版本库中一模一样的版本状态。</p><p>②： 执行了git add ，还没执行 git commit ,再执行上面的操作后，会恢复到git add 结束后的状态</p><p>注：一旦执行了git commit -m “*”，就不能再使用上面的命令回退。</p><p>2、撤销新建文件</p><p>比如新建一个aa.html页面，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -f ../aa.html</span><br></pre></td></tr></table></figure></p><p>3、撤销新建文件夹</p><p>比如新建一个文件夹”demo”，并未执行git add ,即没有被git追踪，此时如果你想撤销新建动作，可执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -df ./demo</span><br></pre></td></tr></table></figure></p><h3 id="六、对于已经push的版本，进行回退"><a href="#六、对于已经push的版本，进行回退" class="headerlink" title="六、对于已经push的版本，进行回退"></a>六、对于已经push的版本，进行回退</h3><p>1、第一步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号 //本地回退到指定的版本</span><br></pre></td></tr></table></figure></p><p>2、第二步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push  -f origin dev    //将远程的也回退到指定版本</span><br></pre></td></tr></table></figure></p><h3 id="七、本地同步远程删除的分支"><a href="#七、本地同步远程删除的分支" class="headerlink" title="七、本地同步远程删除的分支"></a>七、本地同步远程删除的分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin -p  //用来清除已经没有远程信息的分支</span><br><span class="line"></span><br><span class="line">这样git branch -a 就不会拉取远程已经删除的分支了</span><br></pre></td></tr></table></figure><h3 id="八、删除掉没有与远程分支对应的本地分支"><a href="#八、删除掉没有与远程分支对应的本地分支" class="headerlink" title="八、删除掉没有与远程分支对应的本地分支"></a>八、删除掉没有与远程分支对应的本地分支</h3><p>从gitlab上看不到的分支在本地可以通过git branch -a 查到，删掉没有与远程分支对应的本地分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch -p</span><br></pre></td></tr></table></figure></p><h3 id="九、查看远程库的一些信息，及与本地分支的信息"><a href="#九、查看远程库的一些信息，及与本地分支的信息" class="headerlink" title="九、查看远程库的一些信息，及与本地分支的信息"></a>九、查看远程库的一些信息，及与本地分支的信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin</span><br></pre></td></tr></table></figure><h3 id="Git命令清单"><a href="#Git命令清单" class="headerlink" title="Git命令清单"></a>Git命令清单</h3><h3 id="增加删除文件"><a href="#增加删除文件" class="headerlink" title="增加删除文件"></a>增加删除文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h3 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h3 id="标签命令"><a href="#标签命令" class="headerlink" title="标签命令"></a>标签命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><p> 参考链接：<a href="https://segmentfault.com/a/1190000014461898" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014461898</a><br> 参考链接：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p>]]></content>
      
      <categories>
          
          <category> 实践教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>移动端H5缓存</title>
      <link href="/blog/2018/04/20/%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E7%BC%93%E5%AD%98/"/>
      <url>/blog/2018/04/20/%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<p>HTML5是新一代的HTML标准，加入很多新的特性。离线存储（亦称为缓存机制）是其中一个非常重要的特性。HTML5引入了离线存储，这意味着移动Web应用可进行缓存，并可在没有Internet连接时离线进行访问。<br>HTML5应用程序缓存为应用带来三个优势：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">离线浏览：用户可在应用离线时使用它们；</span><br><span class="line">速度：已缓存资源加载得更快；</span><br><span class="line">减少服务器负载：浏览器将只从服务器下载更新过或更改过的资源。</span><br></pre></td></tr></table></figure></p><p>根据标准，到目前为止，H5共有6种缓存机制，有些是之前已有，有些是H5才新加入的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">浏览器缓存机制</span><br><span class="line">Dom Storgage（Web Storage）存储机制</span><br><span class="line">Web SQL Database存储机制（不推荐）</span><br><span class="line">Application Cache（AppCache）机制</span><br><span class="line">Indexed Database （IndexedDB）</span><br><span class="line">File System API</span><br></pre></td></tr></table></figure></p><p>下面分析各种缓存机制的原理、用法及特点；然后针对Android移动端Web性能加载优化的需求，看如何适当利用缓存机制来提高Web的加载性能。</p><h3 id="1-浏览器缓存机制"><a href="#1-浏览器缓存机制" class="headerlink" title="1. 浏览器缓存机制"></a>1. 浏览器缓存机制</h3><p>浏览器缓存机制是指通过HTTP协议头里的Cache-Control（或Expires）和Last-Modified（或Etag）等字段来控制文件缓存的机制。这应该是Web中最早的缓存机制了，是在HTTP协议中实现的，有点不同于Dom Storage、AppCache等缓存机制，但本质上是一样的，可以理解为一个是协议层实现的，一个是应用层实现的。</p><p>Cache-Control和Last-Modified一般用在静态资源文件上，如JS、CSS和一些图像文件。通过设置资源文件缓存属性，对提高资源文件加载速度，节省流量很有意义，特别是移动网络环境。但问题是：缓存有效时长应该如何设置，如果太短，就起不到缓存的使用，设置的太长，在服务端资源文件有更新时，浏览器有缓存，则不能及时取到最新的文件。</p><p>对于移动端的缓存，任何一个网络请求的增加，加载消耗时间都是比较大的（尤其弱网环境下）。对于强缓存只要缓存不到期，是不会向服务器发送请求，但是如果是协商缓存的情况下，304的问题就比较大，它会造成无用的服务器请求，导致网络的延时。Last-Modified需要向服务器发起查询请求，才能知道资源文件有没有更新，虽然服务器可能返回304告诉没有更新，但也还有一个请求的过程。对于移动网络，这个请求可能是比较耗时的，有一种说法叫“消灭304”，指的就是优化掉304的请求。</p><p>通过抓包可以发现，带if-Modified-Since字段的请求，如果服务器回包304，回包会带有Cache-Control:max-age或Expires字段，文件的强缓存有效时间会更新，就是文件强缓存会重新有效。304回包后如果再请求，则又可以直接使用本地缓存文件了，不用再向服务器发送请求查询文件是否更新了，除非新的强缓存资源文件时间再次过期。</p><p>另外，Cache-Control与Last-Modified是浏览器内核的机制，一般都是标准的实现，不能更改或设置。以QQ浏览器的X5为例，Cache-Control与Last-Modified缓存不能禁用，缓存容量是12MB，不分Host，过期的缓存会最先被清除。如果都没过期，应该优先清最早的缓存或最快到期的或文件大小最大的，过期缓存也有可能还是有效的，清除缓存会导致资源文件的重新拉取。还有，浏览器，如X5，在使用缓存文件时，是没有对缓存文件内容进行校验的，这样缓存文件内容被修改的可能。</p><p>分析发现，浏览器的缓存机制还不是非常完美的缓存机制。完美的缓存机制应该是这样的：</p><blockquote>缓存文件没更新，尽可能使用缓存，不用和服务器交互；<br>缓存文件有更新时，第一时间能使用到新的文件；<br>缓存的文件要保持完整性，不使用被修改过的缓存文件；<br>缓存的容量大小要能设置或控制，缓存文件不能因为存储空间限制或过期被清除。 以X5为例，第1、2条不能同时满足，第3、4条都不能满足。</blockquote><p>在实际应用中，为了解决Cache-Control缓存时长不好设置的问题，以及为了“消灭304”，采用的方式是：</p><blockquote>1. 在要缓存的资源文件名中加上版本号或文件MD5值字串，如common.d5d02a02.js、common.v1.js，同时设置Cache-Control:max-age=31536000，也就是一年。在一年时间内，资源文件如果本地有缓存，就会使用缓存,这样就可以避免协商缓存的304的回包现象。<br>2. 如果资源文件有修改，则更新文件内容，同时修改资源文件名，如common.v2.js，html页面也会引用新的资源文件名，实现静态资源非覆盖式更新。<br><br>通过这种方式，实现了：缓存文件没有更新，则使用缓存；缓存文件有更新，则第一时间使用最新文件的目的。即上面说的第1、2条。第3、4条由于浏览器内部机制，目前还无法满足。</blockquote><h3 id="2-Dom-Storage（Web-Storage）存储机制"><a href="#2-Dom-Storage（Web-Storage）存储机制" class="headerlink" title="2. Dom Storage（Web Storage）存储机制"></a>2. Dom Storage（Web Storage）存储机制</h3><p>DOM存储是一套在Web Applications 1.0规范中首次引入的与存储相关的特性的总称，现在已经分离出来，单独发展成为独立的W3C Web存储规范。DOM存储被设计为用来提供一个更大存储量、更安全、更便捷的存储方法，从而可以代替掉将一些不需要让服务器知道的信息存储到Cookies里的这种传统方法。这是对Dom Storage存储机制的官方表述。</p><p>Dom Storage是通过存储字符串的Key/Value对来提供的，并提供5MB（不同浏览器可能不同，分Host）的存储空间（Cookies才4KB)。另外Dom Storage存储的数据在本地，不像 Cookies，每次请求一次页面，Cookies 都会发送给服务器。</p><p>DOM Storage分为sessionStorage和localStorage。localStorage对象和sessionStorage对象使用方法基本相同，它们的区别在于作用的范围不同。sessionStorage用来存储与页面相关的数据，它在页面关闭后无法使用。而localStorage则持久存在，在页面关闭后也可以使用。</p><p>sessionStorage是个全局对象，它维护着在页面会话（page session）期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入（reload）或者被恢复（restores）时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。</p><p>当浏览器被意外刷新的时候，一些临时数据应当被保存和恢复。sessionStorage对象在处理这种情况的时候是最有用的，比如恢复我们在表单中已经填写的数据。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"> // 当页面刷新时，从sessionStorage恢复之前输入的内容</span><br><span class="line"> window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> (window.sessionStorage) &#123;</span><br><span class="line">        var name = window.sessionStorage.getItem(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="string">""</span> || name != null)&#123;</span><br><span class="line">            document.getElementById(<span class="string">"name"</span>).value = name;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> // 将数据保存到sessionStorage对象中</span><br><span class="line"> <span class="keyword">function</span> <span class="function"><span class="title">saveToStorage</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (window.sessionStorage) &#123;</span><br><span class="line">        var name = document.getElementById(<span class="string">"name"</span>).value;</span><br><span class="line">        window.sessionStorage.setItem(<span class="string">"name"</span>, name);</span><br><span class="line">        window.location.href=<span class="string">"session_storage.html"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">&lt;form action=<span class="string">"./session_storage.html"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span> id=<span class="string">"name"</span>/&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"Save"</span> onclick=<span class="string">"saveToStorage()"</span>/&gt;</span><br><span class="line">&lt;/form&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure></p><p>把上面的代码复制到session_storage.html（也可以从附件中直接下载）页面中，用Google Chrome浏览器的不同Page或Window打开，在输入框中分别输入不同的文字，再点击“Save”，然后分别刷新。每个Page或Window显示都是当前Page输入的内容，互不影响。关闭Page，再重新打开，上一次输入保存的内容已经没有了。</p><p>Local Storage的接口、用法与Session Storage一样，唯一不同的是：Local Storage保存的数据是持久性的。当前Page关闭（Page Session结束后），保存的数据依然存在。重新打开Page，上次保存的数据可以获取到。另外，Local Storage是全局性的，同时打开两个Page会共享一份存数据，在一个Page中修改数据，另一个Page中是可以感知到的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 通过localStorage直接引用key, 另一种写法，等价于：</span><br><span class="line">  // localStorage.getItem(&quot;pageLoadCount&quot;);</span><br><span class="line">  // localStorage.setItem(&quot;pageLoadCount&quot;, value);</span><br><span class="line">  if (!localStorage.pageLoadCount) &#123;</span><br><span class="line">     localStorage.pageLoadCount = 0;</span><br><span class="line">     localStorage.pageLoadCount = parseInt(localStorage.pageLoadCount) + 1;</span><br><span class="line">     document.getElementById(&apos;count&apos;).textContent = localStorage.pageLoadCount;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    You have viewed this page</span><br><span class="line">    &lt;span id=&quot;count&quot;&gt;an untold number of&lt;/span&gt;</span><br><span class="line">    time(s)</span><br><span class="line">&lt;/p&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure></p><p>将上面代码复制到local_storage.html的页面中，用浏览器打开，pageLoadCount的值是1；关闭Page重新打开，pageLoadCount的值是2。这是因为第一次的值已经保存了。用两个Page同时打开local_storage.html，并分别交替刷新，发现两个Page是共享一个pageLoadCount的。</p><p>分析：Dom Storage给Web提供了一种更录活的数据存储方式，存储空间更大（相对Cookies），用法也比较简单，方便存储服务器或本地的一些临时数据。</p><p>从Dom Storage提供的接口来看，Dom Storage适合存储比较简单的数据，如果要存储结构化的数据，可能要借助JSON了，将要存储的对象转为JSON字串。不太适合存储比较复杂或存储空间要求比较大的数据，也不适合存储静态的文件等。</p><p>在Android内嵌Webview中，需要通过Webview设置接口启用Dom Storage。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">WebSettings webSettings = myWebView.getSettings();</span><br><span class="line">webSettings.setDomStorageEnabled(true);&lt;br&gt;</span><br></pre></td></tr></table></figure></p><p>拿Android类比的话，Web的Dom Storage机制类似于Android的SharedPreference机制。</p><h3 id="3-Web-SQL-Database存储机制"><a href="#3-Web-SQL-Database存储机制" class="headerlink" title="3. Web SQL Database存储机制"></a>3. Web SQL Database存储机制</h3><p>HTML5也提供基于SQL的数据库存储机制，用于存储适合数据库的结构化数据。但根据官方的标准文档，这种存储机制不再推荐使用，将来也不再维护，而是推荐使用AppCache和IndexedDB，所以这里就不多做阐述了。</p><h3 id="4-Application-Cache机制"><a href="#4-Application-Cache机制" class="headerlink" title="4. Application Cache机制"></a>4. Application Cache机制</h3><p>Application Cache（简称AppCache）似乎是为支持Web App离线使用而开发的缓存机制。它的缓存机制类似于浏览器的缓存（Cache-Control和Last-Modified）机制，都是以文件为单位进行缓存，且文件有一定更新机制。但AppCache是对浏览器缓存机制的补充，不是替代。先拿W3C官方的一个例子，说下AppCache机制的用法与功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html manifest=<span class="string">"demo_html.appcache"</span>&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=<span class="string">"demo_time.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;p id=<span class="string">"timePara"</span>&gt;&lt;button onclick=<span class="string">"getDateTime()"</span>&gt;Get Date and Time&lt;/button&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;img src=<span class="string">"img_logo.gif"</span> width=<span class="string">"336"</span> height=<span class="string">"69"</span>&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        Try opening </span><br><span class="line">        &lt;a href=<span class="string">"tryhtml5_html_manifest.htm"</span> target=<span class="string">"_blank"</span>&gt;</span><br><span class="line">        this page&lt;/a&gt;</span><br><span class="line">        , <span class="keyword">then</span> go offline, and reload the page. </span><br><span class="line">        The script and the image should still work.</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>上面HTML文档，引用外部一个JS文件和一个GIF图片文件，在其HTML头中通过manifest属性引用了一个appcache结尾的文件。</p><p>我们在Google Chrome浏览器中打开这个HTML链接，JS功能正常，图片也显示正常。禁用网络，关闭浏览器重新打开这个链接，发现JS工作正常，图片也显示正常。当然也有可能是浏览缓存起的作用，我们可以在文件的浏览器缓存过期后，禁用网络再试，发现HTML页面也是正常的。</p><p>通过Google Chrome浏览器自带的工具，我们可以查看已经缓存的AppCache（分Host）。<br><img src="http://jingchao.xyz/blog/images/appcache.jpg" alt=""></p><p>上面截图中的缓存，就是我们刚才打开HTML的页面AppCache。从截图中看，HTML页面及HTML引用的JS、GIF图像文件都被缓存了；另外HTML头中manifest属性引用的appcache文件也缓存了。</p><p>AppCache的原理有两个关键点：manifest属性和manifest文件。</p><p>HTML在头中通过manifest属性引用manifest文件。manifest文件，就是上面以appcache结尾的文件，是一个普通文件文件，列出了需要缓存的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">demo.js</span><br><span class="line">img.gif</span><br></pre></td></tr></table></figure></p><p>上面截图中的manifest文件，就HTML代码引用的manifest文件。文件比较简单，第一行是关键字，第二、三行就是要缓存的文件路径（相对路径）。这只是最简单的manifest文件，完整的还包括其他关键字与内容。引用manifest文件的HTML和manifest文件中列出的要缓存的文件最终都会被浏览器缓存。</p><p>完整的manifest文件，包括三个Section，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 2012-02-21 v1.0.0</span><br><span class="line">/theme.css</span><br><span class="line">/logo.gif</span><br><span class="line">/main.js</span><br><span class="line">NETWORK:</span><br><span class="line">login.asp</span><br><span class="line">FALLBACK:</span><br><span class="line">/html/ /offline.html</span><br></pre></td></tr></table></figure></p><p>总的来说，浏览器在首次加载HTML文件时，会解析manifest属性，并读取manifest文件，获取CACHE MANIFEST下要缓存的文件列表，再对文件缓存。</p><p>AppCache的缓存文件，与浏览器的缓存文件分开存储的，还是一份？应该是分开的。因为AppCache在本地也有5MB（分Host）的空间限制。</p><p>AppCache在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新manifest文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查manifest文件有没有修改（byte by byte)，发现有修改，就会重新获取manifest文件，对CACHE MANIFEST下文件列表检查更新。manifest文件与缓存文件的检查更新也遵守浏览器缓存机制。</p><p>如用用户手动清了AppCache缓存，下次加载时，浏览器会重新生成缓存，也可算是一种缓存的更新。另外，Web App也可用代码实现缓存更新。</p><blockquote><br>分析：AppCache看起来是一种比较好的缓存方法，除了缓存静态资源文件外，也适合构建Web离线 App。在实际使用中有些需要注意的地方，有一些可以说是”坑“。<br>    1. 要更新缓存的文件，需要更新包含它的manifest文件，那怕只加一个空格。常用的方法，是修改manifest文件注释中的版本号。如：# 2012-02-21 v1.0.0。<br>    2.被缓存的文件，浏览器是先使用，再通过检查manifest文件是否有更新来更新缓存文件。这样缓存文件可能用的不是最新的版本。<br>    3. 在更新缓存过程中，如果有一个文件更新失败，则整个更新会失败。<br>    4. manifest和引用它的HTML要在相同Host。<br>    5. manifest文件中的文件列表，如果是相对路径，则是相对manifest文件的相对路径。<br>    6. manifest也有可能更新出错，导致缓存文件更新失败。<br>    7. 没有缓存的资源在已经缓存的HTML中不能加载，即使有网络。例如：<a href="http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-network/。" target="_blank" rel="noopener">http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-network/。</a><br>    8. manifest文件本身不能被缓存，且manifest文件的更新使用的是浏览器缓存机制。所以manifest文件的Cache-Control缓存时间不能设置太长。<br>另外，根据官方文档，AppCache已经不推荐使用了，标准也不会再支持。现在主流的浏览器都是还支持AppCache的，以后就不太确定了。</blockquote><p>在Android内嵌Webview中，需要通过Webview设置接口启用AppCache，同时还要设置缓存文件的存储路径，另外还可以设置缓存的空间大小。</p><h3 id="5-Indexed-Database"><a href="#5-Indexed-Database" class="headerlink" title="5. Indexed Database"></a>5. Indexed Database</h3><p>IndexedDB也是一种数据库的存储机制，但不同于已经不再支持的Web SQL Database。IndexedDB不是传统的关系数据库，可归为NoSQL数据库。IndexedDB又类似于Dom Storage的key-value的存储方式，但功能更强大，且存储空间更大。</p><p>IndexedDB存储数据是key-value的形式。Key是必需，且要唯一；Key可以自己定义，也可由系统自动生成。Value也是必需的，但Value非常灵活，可以是任何类型的对象。一般Value都是通过Key来存取的。</p><p>IndexedDB提供了一组API，可以进行数据存、取以及遍历。这些API都是异步的，操作的结果都是在回调中返回。</p><p>IndexedDB有个非常强大的功能，就是index（索引）。它可对Value对象中任何属性生成索引，然后可以基于索引进行Value对象的快速查询。</p><p>要生成索引或支持索引查询数据，需求在首次生成存储对象时，调用接口生成属性的索引。可以同时对对象的多个不同属性创建索引。如下面代码就对name和email两个属性都生成了索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var objectStore = thisDB.createObjectStore(&quot;people&quot;,&#123; autoIncrement:true &#125;)</span><br><span class="line">//first arg is name of index, second is the path (col)</span><br><span class="line">objectStore.createIndex(&quot;name&quot;,&quot;name&quot;, &#123;unique:false&#125;)</span><br><span class="line">objectStore.createIndex(&quot;email&quot;,&quot;email&quot;, &#123;unique:true&#125;)</span><br></pre></td></tr></table></figure></p><p>生成索引后，就可以基于索引进行数据的查询。Android在4.4开始加入对IndexedDB的支持，只需打开允许JS执行的开关就好了。</p><blockquote>分析：IndexedDB是一种灵活且功能强大的数据存储机制，它集合了Dom Storage和Web SQL Database的优点，用于存储大块或复杂结构的数据，提供更大的存储空间，使用起来也比较简单。可以作为Web SQL Database的替代。不太适合静态文件的缓存。<br>以key-value 的方式存取对象，可以是任何类型值或对象，包括二进制。<br>可以对对象任何属性生成索引，方便查询。<br>较大的存储空间，默认推荐250MB（分Host），比Dom Storage的5MB要大得多。<br>通过数据库的事务（tranction）机制进行数据操作，保证数据一致性。<br>异步的 API 调用，避免造成等待而影响体验。</blockquote><h3 id="6-File-System-API"><a href="#6-File-System-API" class="headerlink" title="6. File System API"></a>6. File System API</h3><p>File System API是HTML5新加入的存储机制。它为Web App提供了一个虚拟的文件系统，就像Native App访问本地文件系统一样。由于安全性的考虑，这个虚拟文件系统有一定的限制。Web App在虚拟的文件系统中，可以进行文件（夹）的创建、读、写、删除、遍历等操作。</p><p>File System API也是一种可选的缓存机制，和前面的SQL Database、IndexedDB 和App Cache等一样。File System API有自己的一些特定的优势：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以满足大块的二进制数据（large binary blobs）存储需求。</span><br><span class="line">可以通过预加载资源文件来提高性能。</span><br><span class="line">可以直接编辑文件。</span><br></pre></td></tr></table></figure></p><p>浏览器给虚拟文件系统提供了两种类型的存储空间：临时的和持久性的。临时的存储空间是由浏览器自动分配的，但可能被浏览器回收；持久性的存储空间需要显示的申请，申请时浏览器会给用户一提示，需要用户进行确认。持久性的存储空间是Web App自己管理，浏览器不会回收，也不会清除内容。持久性的存储空间大小是通过配额来管理的，首次申请时会一个初始的配额，配额用完需要再次申请。</p><p>虚拟的文件系统是运行在沙盒中，不同Web App的虚拟文件系统是互相隔离的，虚拟文件系统与本地文件系统也是隔离的。</p><h2 id="移动端Web加载性能（缓存）优化"><a href="#移动端Web加载性能（缓存）优化" class="headerlink" title="移动端Web加载性能（缓存）优化"></a>移动端Web加载性能（缓存）优化</h2><p>分析完HTML5提供的各种缓存机制，回到移动端（针对Android，可能也适用于iOS）的场景。现在Android App（包括手Q和WX）大多嵌入了Webview的组件（系统Webview或QQ浏览器的X5组件），通过内嵌Webview来加载一些HTML5的运营活动页面或资讯页。这样可充分发挥Web前端的优势：快速开发、发布，灵活上下线。但Webview也有一些不可忽视的问题，比较突出的就是加载相对较慢，会相对消耗较多流量。</p><p>通过对一些HTML5页面进行调试及抓包发现，每次加载一个HTML5页面，都会有较多的请求。除了HTML主URL自身的请求外，HTML外部引用的JS、CSS、字体文件、图片都是一个独立的HTTP请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化 Web的加载性能。</p><table><thead><tr><th>缓存机制</th><th style="text-align:center">优势</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td>浏览器</td><td style="text-align:center">HTTP协议层支持</td><td style="text-align:center">静态文件缓存</td></tr><tr><td>Dom Storage</td><td style="text-align:center">较大存储空间，简单</td><td style="text-align:center">临时简单数据存储，Cookie扩展 </td></tr><tr><td>Web SQL Database</td><td style="text-align:center">存储复杂数据结构</td><td style="text-align:center">不推荐，IndexDB替代</td></tr><tr><td>AppCache</td><td style="text-align:center">构建离线App</td><td style="text-align:center">不推荐，离线App，静态文件缓存 </td></tr><tr><td>IndexDB</td><td style="text-align:center">存储任何类型数据，索引</td><td style="text-align:center">结构，关系复杂的数据结构  </td></tr><tr><td>File System API</td><td style="text-align:center">支持文件系统操作</td><td style="text-align:center">数据适合以文件进行管理场景</td></tr></tbody></table><p>结论：综合各种缓存机制比较，对于静态文件，如JS、CSS、字体、图片等，适合通过浏览器缓存机制来进行缓存，通过缓存文件可大幅提升Web的加载速度，且节省流量。但也有一些不足：缓存文件需要首次加载后才会产生；浏览器缓存的存储空间有限，缓存有被清除的可能；缓存的文件没有校验。要解决这些不足，可以参考手Q的离线包，它有效的解决了这些不足。</p><p>对于Web在本地或服务器获取的数据，可以通过Dom Storage和IndexedDB进行缓存。也在一定程度上减少和Server的交互，提高加载速度，同时节省流量。</p><p><strong>@转载请注明出处</strong><br>原文链接：<a href="https://www.csdn.net/article/2015-12-16/2826489/1" target="_blank" rel="noopener">https://www.csdn.net/article/2015-12-16/2826489/1</a></p>]]></content>
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web缓存机制</title>
      <link href="/blog/2018/04/03/Web%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/blog/2018/04/03/Web%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。</p><p><strong>web缓存的作用</strong><br>减少网络带宽消耗（当Web缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本）<br>降低服务器压力（给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，减小服务器压力）<br>减少网络延迟，加开页面打开速度</p><p>缓存机制是web开发的重要知识点，也是系统优化的重要方向。在前端开发中，缓存有利于加快网页的加载速度，同时缓存能够被反复利用，所以可以减少流量和带宽的开销。这里将系统的介绍在Web开发中的缓存方式，还会涉及到部分操作系统缓存知识。本文会重点介绍浏览器端的缓存机制也就是HTTP缓存，其机制是根据HTTP报文的缓存标识进行的。在分析缓存机制之前，先介绍下浏览器的HTTP报文。HTTP报文分为两种：</p><ul><li><strong>HTTP请求(Request)报文</strong>，报文格式为：<strong>请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)</strong>，如下图</li></ul><p><img src="http://jingchao.xyz/blog/images/Request.jpg" alt=""><br><img src="http://jingchao.xyz/blog/images/Request-header.jpg" alt=""></p><ul><li><strong>HTTP响应(Response)报文</strong>，报文格式为：<strong>状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体</strong>，如下图</li></ul><p><img src="http://jingchao.xyz/blog/images/Response-header.jpg" alt=""></p><p>注：<strong>通用信息头</strong>指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；<strong>实体头</strong>则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。</p><h3 id="Web开发中的不同缓存"><a href="#Web开发中的不同缓存" class="headerlink" title="Web开发中的不同缓存"></a>Web开发中的不同缓存</h3><h4 id="1-数据库缓存"><a href="#1-数据库缓存" class="headerlink" title="1. 数据库缓存"></a>1. 数据库缓存</h4><p>   我们可能听说过memcached，它就是一种数据库层面的缓存方案。类似的还有Redis缓存，也是一种基于内存的数据库，它的功能更加强大，并且支持备份和数据持久化。数据库缓存是指，当web应用的关系比较复杂，数据库中的表很多的时候，如果频繁进行 数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。</p><h4 id="2-CDN缓存（服务端缓存）"><a href="#2-CDN缓存（服务端缓存）" class="headerlink" title="2. CDN缓存（服务端缓存）"></a>2. CDN缓存（服务端缓存）</h4><p>  CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能，可以归属为全局负载均衡或者说是四层<a href="http://jingchao.xyz/blog/2018/05/06/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%80%E8%BF%B0">负载均衡</a>。通常情况下，浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，浏览器和服务器之间的缓存机制，在这种架构下同样适用。一般对于网站上的静态资源文件可以采用CDN分发，可以加快网站访问速度。</p><h4 id="3-代理服务器缓存（服务端缓存）"><a href="#3-代理服务器缓存（服务端缓存）" class="headerlink" title="3. 代理服务器缓存（服务端缓存）"></a>3. 代理服务器缓存（服务端缓存）</h4><p>   代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大，可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。也可以将其归为七层负载均衡，但需要两次TCP握手连接，然功能更多，如会话保持，图片压缩，防盗链等。   </p><h4 id="4-浏览器缓存"><a href="#4-浏览器缓存" class="headerlink" title="4. 浏览器缓存"></a>4. 浏览器缓存</h4><p>   每个浏览器都实现了 HTTP 缓存，我们通过浏览器使用HTTP协议与服务器交互的时候，浏览器就会根据一套与服务器约定的规则进行缓存工作。最新的HTML5协议新增了离线缓存属性，对缓存机制进一步的优化，可以达到，实现图片存在客户端，跨域共享客户端缓存，做到真正的离线访问WEB应用，实现客户端的数据库。</p><h4 id="5-应用层缓存"><a href="#5-应用层缓存" class="headerlink" title="5. 应用层缓存"></a>5. 应用层缓存</h4><p>   应用层缓存是指我们在代码层面上做的缓存。通过代码逻辑，把曾经请求过的数据或资源等，缓存起来，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率，再次需要数据时通过逻辑上的处理选择可用的缓存的数据。h5新增的storage就可以归属到应用层缓存。</p><h3 id="操作系统缓存"><a href="#操作系统缓存" class="headerlink" title="操作系统缓存"></a>操作系统缓存</h3><p>首先关于存储的概念有以下几种方式：<br><strong>cache</strong>：缓存为了让从DB/磁盘拿出来的东西放到缓存（放于内存）；<br><strong>磁盘文件</strong>：本地存储的视频，图片，计算机里面的文件；<br><strong>数据库</strong>：系统项目中的数据存储；<br><strong>内存</strong>：计算机中所有的程序运行都是在内存中，所以内存对计算机的性能影响很大。<br>在操作系统缓存机制中，有buffer和cache两种方式，它们都是占用内存（buffer记录元数据，权限属性等，cache缓存文件）。I/O过程本身的延迟，以及高速设备与低速设备交互时的等待延迟，Buffer和Cache就是从这两个方向上产生的优化提高系统性能的方式。</p><p><strong>buffer缓存</strong>是块设备的读写缓冲区，buffer是I/O缓存，用于内存和硬盘（或其他 I/O设备）之间的数据交换的速度而设计的。通常在写一个非常大的文件，文件会被分成一个个的小block块，往内存上写，然后再写入磁盘,这样的效率会很慢。这种情况下，内存就会攒足一次大的block块再写入磁盘，这样就不会有第一种情况里的延迟，这就是buffer。buffer的主要目的是进行流量整形，把突发的大数量较小规模读写整理成平稳的较大规模的I/O，以<strong>减少响应次数</strong>（比如从网上下载视频，不能下一点点数据就写入硬盘，而是达到一定量的数据一整块写，不然硬盘负荷太大）。</p><p><strong>Cache缓存</strong>是高速缓存，用于cpu与内存之间的缓冲，是系统两端处理速度不匹配时的一种折衷策略。主要原因是cpu与memory，由于cpu快，memory跟不上，且有些值使用次数多，所以放入cache中，主要目的是使用内存来缓存可能被再次访问的数据，可以保持冗余的、被重复计算的、计算后的数据（buffer不行）。Cache是经常被使用在I/O请求上，来提高系统性能。如果cache的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO必会非常小。</p><h3 id="Web中浏览器缓存"><a href="#Web中浏览器缓存" class="headerlink" title="Web中浏览器缓存"></a>Web中浏览器缓存</h3><p>浏览器端的缓存分为强缓存（Expires和<strong>Cache-Control</strong>—优先级高，直接使用本地缓存资源）和协商缓存（Last-Modified / If-Modified-Since和 <strong>Etag / If-None-Match</strong>—优先级高，先发送请求到服务器端确认资源更改来确认是否使用缓存）。</p><h3 id="1-强缓存"><a href="#1-强缓存" class="headerlink" title="1. 强缓存"></a>1. 强缓存</h3><p>在HTTP/1.0使用的是Expires字段，该字段表示缓存到期时间，即有效时间+当时服务器的时间，然后将这个时间设置在header中返回给服务器。如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。该时间是一个绝对时间，由于服务端和浏览器端时间不一致，或者用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，因此更推荐另一种强缓存方式。Expires字段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Thu, 15 Mar 2018 09:09:09 GMT</span><br></pre></td></tr></table></figure></p><p>在HTTP/1.1中，增加了一个字段Cache-Control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求，主要是利用该字段的<strong>max-age</strong>值来进行判断，它是一个相对值，资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则资源失效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=9590000</span><br></pre></td></tr></table></figure></p><p>Cache-Control除了max-age字段外，还有几个比较常用的字段设置值：</p><blockquote><strong>no-cache</strong>：不用本地缓存，使用协商缓存，先发送请求到服务器根据响应确认资源是否被更改，如果之前的响应中存在ETag或者Last-Modified，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。<br><br><strong>no-store</strong>：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。<br><br><strong>public</strong>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。<br><br><strong>private</strong>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</blockquote><p><strong>注意</strong>：如果cache-control与expires同时存在的话，cache-control的优先级高于expires</p><h3 id="2-协商缓存"><a href="#2-协商缓存" class="headerlink" title="2. 协商缓存"></a>2. 协商缓存</h3><p>协商缓存（Last-Modified或者Etag）的过程是先从缓存中获取对应的数据标识，然后向服务器发送请求，确认数据是否更新，如果更新，则返回新数据和新缓存。反之，则返回304状态码，告知客户端缓存未更新，可继续使用，这正好弥补了一些强缓存的缺陷，协商缓存主要应用于一些时常需要动态更新的资源文件。协商缓存在协议里的字段是Last-Modified或者Etag，这两个字段都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。</p><p>Last-Modified/If-Modified-Since具体过程：</p><blockquote>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间<br><br>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值<br><br>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header<br><br>浏览器收到304的响应后，就会从缓存中加载资源<br><br>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值</blockquote><p>Etag/If-None-Match</p><p>Etag字段值是由服务器生成的每个资源的唯一标识字符串（一般都是hash生成的），只要资源内容有变化这个值就会改变,其判断过程与Last-Modified类似，与它不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，响应头还会把这个ETag返回，即使这个ETag跟之前的没有变化。</p><p>Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，之所以在HTTP1.1中新增Etag主要为了解决几个Last-Modified的问题：</p><blockquote>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；<br><br>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；<br><br>某些服务器不能精确的得到文件的最后修改时间。<br><br>这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。</blockquote><p><strong>注意</strong>：Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p><h4 id="用户浏览器行为对缓存的影响"><a href="#用户浏览器行为对缓存的影响" class="headerlink" title="用户浏览器行为对缓存的影响"></a>用户浏览器行为对缓存的影响</h4><p>刷新网页 =&gt; 如果缓存没有失效，浏览器会直接使用缓存；反之，则向服务器请求数据<br>手动刷新（F5） =&gt; 浏览器会认为缓存失效，在请求服务器时加上Cache-Control: max-age=0字段，然后询问服务器数据是否更新。<br>强制刷新（Ctrl + F5） =&gt; 浏览器会直接忽略缓存，在请求服务器时加上Cache-Control: no-cache字段，然后重新向服务器拉取文件。<br>更多用户行为可以用如下表格进行表示：</p><table><thead><tr><th>用户行为</th><th style="text-align:center">Expires / Cache-Control</th><th style="text-align:center">Last-Modified / Etag</th></tr></thead><tbody><tr><td>地址栏回车</td><td style="text-align:center">有效</td><td style="text-align:center">有效 </td></tr><tr><td>页面链接跳转</td><td style="text-align:center">有效</td><td style="text-align:center">有效 </td></tr><tr><td>新窗口</td><td style="text-align:center">有效</td><td style="text-align:center">有效</td></tr><tr><td>前进后退</td><td style="text-align:center">有效</td><td style="text-align:center">有效 </td></tr><tr><td>F5刷新</td><td style="text-align:center">无效</td><td style="text-align:center">有效  </td></tr><tr><td>Ctrl+F5刷新</td><td style="text-align:center">无效</td><td style="text-align:center">无效</td></tr></tbody></table><h4 id="移动端的缓存处理"><a href="#移动端的缓存处理" class="headerlink" title="移动端的缓存处理"></a>移动端的缓存处理</h4><p>Cache-Control和Last-Modified一般用在静态资源文件上，如JS、CSS和一些图像文件。通过设置资源文件缓存属性，对提高资源文件加载速度，节省流量很有意义，特别是移动网络环境。但问题是：缓存有效时长应该如何设置，如果太短，就起不到缓存的使用，设置的太长，在服务端资源文件有更新时，浏览器有缓存，则不能及时取到最新的文件。</p><p>对于移动端的缓存，任何一个网络请求的增加，加载消耗时间都是比较大的（尤其弱网环境下）。对于强缓存只要缓存不到期，是不会向服务器发送请求，但是如果是协商缓存的情况下，304的问题就比较大，它会造成无用的服务器请求，导致网络的延时。Last-Modified需要向服务器发起查询请求，才能知道资源文件有没有更新，虽然服务器可能返回304告诉没有更新，但也还有一个请求的过程。对于移动网络，这个请求可能是比较耗时的，有一种说法叫“消灭304”，指的就是优化掉304的请求。</p><p>通过抓包可以发现，带if-Modified-Since字段的请求，如果服务器回包304，回包会带有Cache-Control:max-age或Expires字段，文件的强缓存有效时间会更新，就是文件强缓存会重新有效。304回包后如果再请求，则又可以直接使用本地缓存文件了，不用再向服务器发送请求查询文件是否更新了，除非新的强缓存资源文件时间再次过期。</p><p>另外，Cache-Control与Last-Modified是浏览器内核的机制，一般都是标准的实现，不能更改或设置。以QQ浏览器的X5为例，Cache-Control与Last-Modified缓存不能禁用，缓存容量是12MB，不分Host，过期的缓存会最先被清除。如果都没过期，应该优先清最早的缓存或最快到期的或文件大小最大的，过期缓存也有可能还是有效的，清除缓存会导致资源文件的重新拉取。还有，浏览器，如X5，在使用缓存文件时，是没有对缓存文件内容进行校验的，这样缓存文件内容被修改的可能。</p><p>分析发现，浏览器的缓存机制还不是非常完美的缓存机制。完美的缓存机制应该是这样的：</p><blockquote>缓存文件没更新，尽可能使用缓存，不用和服务器交互；<br>缓存文件有更新时，第一时间能使用到新的文件；<br>缓存的文件要保持完整性，不使用被修改过的缓存文件；<br>缓存的容量大小要能设置或控制，缓存文件不能因为存储空间限制或过期被清除。 以X5为例，第1、2条不能同时满足，第3、4条都不能满足。</blockquote><p>在实际应用中，为了解决Cache-Control缓存时长不好设置的问题，以及为了“消灭304”，采用的方式是：</p><blockquote>1. 在要缓存的资源文件名中加上版本号或文件MD5值字串，如common.d5d02a02.js、common.v1.js，同时设置Cache-Control:max-age=31536000，也就是一年。在一年时间内，资源文件如果本地有缓存，就会使用缓存,这样就可以避免协商缓存的304的回包现象。<br>2. 如果资源文件有修改，则更新文件内容，同时修改资源文件名，如common.v2.js，html页面也会引用新的资源文件名，实现静态资源非覆盖式更新。<br><br>通过这种方式，实现了：缓存文件没有更新，则使用缓存；缓存文件有更新，则第一时间使用最新文件的目的。即上面说的第1、2条。第3、4条由于浏览器内部机制，目前还无法满足。</blockquote><h4 id="浏览器缓存回忆"><a href="#浏览器缓存回忆" class="headerlink" title="浏览器缓存回忆"></a>浏览器缓存回忆</h4><p>浏览器端强缓存优于协商缓存进行，先判断强缓存资源是否过期，若强缓存（Expires和<strong>Cache-Control</strong>）生效则直接使用本地浏览器缓存，若失效则进行协商缓存（Last-Modified / If-Modified-Since和 <strong>Etag</strong> / If-None-Match）发送请求到服务端，协商缓存由服务器响应和本地进行对比验证决定资源是否有效，若协商缓存失效，那么代表该请求的缓存失效，择重新发送请求获取响应结果下载资源，再存入浏览器缓存中，生效则返回304状态码，继续使用缓存，整个浏览器缓存主要过程如下图：</p><p><img src="http://jingchao.xyz/blog/images/all.jpg" alt=""></p><p><strong>@转载请注明出处</strong></p>]]></content>
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo迁移</title>
      <link href="/blog/2018/03/21/hexo%E8%BF%81%E7%A7%BB/"/>
      <url>/blog/2018/03/21/hexo%E8%BF%81%E7%A7%BB/</url>
      <content type="html"><![CDATA[<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="一、安装必要软件"><a href="#一、安装必要软件" class="headerlink" title="一、安装必要软件"></a>一、安装必要软件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装 Git 客户端</span><br><span class="line">安装 node JS</span><br></pre></td></tr></table></figure><h3 id="二、在-github-官网添加新电脑产生的密钥"><a href="#二、在-github-官网添加新电脑产生的密钥" class="headerlink" title="二、在 github 官网添加新电脑产生的密钥"></a>二、在 github 官网添加新电脑产生的密钥</h3><h3 id="三、源文件拷贝"><a href="#三、源文件拷贝" class="headerlink" title="三、源文件拷贝"></a>三、源文件拷贝</h3><p>将原来电脑上个人博客目录下必要文件拷贝到新电脑上（比如D:/Blog目录下），注意无需拷贝全部，只拷如下几个文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">package.json</span><br><span class="line">scaffolds/</span><br><span class="line"><span class="built_in">source</span>/</span><br><span class="line">themes/</span><br></pre></td></tr></table></figure></p><h3 id="四、安装-hexo"><a href="#四、安装-hexo" class="headerlink" title="四、安装 hexo"></a>四、安装 hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 cmd 下输入指令安装 hexo：npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="五、进入-D-Blog-目录（拷贝到新电脑的目录），安装相关模块"><a href="#五、进入-D-Blog-目录（拷贝到新电脑的目录），安装相关模块" class="headerlink" title="五、进入 D:/Blog 目录（拷贝到新电脑的目录），安装相关模块"></a>五、进入 D:/Blog 目录（拷贝到新电脑的目录），安装相关模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save  // 文章部署到 git 的模块</span><br><span class="line">npm install hexo-generator-feed --save  // 建立 RSS 订阅（选择安装）</span><br><span class="line">npm install hexo-generator-sitemap --save // 建立站点地图（选择安装）</span><br></pre></td></tr></table></figure><h3 id="六、部署发布文章"><a href="#六、部署发布文章" class="headerlink" title="六、部署发布文章"></a>六、部署发布文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   // 清除缓存 网页正常情况下可以忽略此条命令</span><br><span class="line">hexo g       // 生成静态网页</span><br><span class="line">hexo d       // 开始部署</span><br></pre></td></tr></table></figure><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>具体的思路是：在生成的已经推到github上的hexo静态代码出建立一个分支，利用这个分支来管理自己hexo的源文件。如果能在刚刚配置hexo的时候就想好以后的迁移的问题就太好了，可以省掉很多麻烦。</p><p>具体的操作：<br>克隆gitHub上面生成的静态文件到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/yourname/hexo-test.github.io.git</span><br></pre></td></tr></table></figure></p><p>把克隆到本地的文件除了git的文件都删掉，找不到git的文件的话就到删了吧。不要用hexo init初始化。</p><p>将之前使用hexo写博客时候的整个目录（所有文件）搬过来。把该忽略的文件忽略了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure></p><p>创建一个叫hexo的分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hexo</span><br></pre></td></tr></table></figure></p><p>提交复制过来的文件到暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br></pre></td></tr></table></figure></p><p>提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;新建分支源文件&quot;</span><br></pre></td></tr></table></figure></p><p>推送分支到github<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin hexo</span><br></pre></td></tr></table></figure></p><p>到这里基本上就搞定了，以后再推就可以直接git push了，hexo的操作跟以前一样。</p><p>今后无论什么时候想要在其他电脑上面用hexo写博客，就直接把创建的分支克隆下来，npm install安装依赖之后就可以用了。</p><p>克隆分支的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b hexo https://github.com/yourname/hexo-test.github.io.git</span><br></pre></td></tr></table></figure></p><p>因为上面创建的是一个名字叫hexo的分支，所以这里-b后面的是hexo，再把后面的gitHub的地址换成你自己的hexo博客的地址就可以了。</p><p>这样完了以后，每次写完博客发布之后不要忘了还要git push把源文件推到分支上。</p><p>原文链接：<a href="https://blog.csdn.net/lvonve/article/details/79587321" target="_blank" rel="noopener">https://blog.csdn.net/lvonve/article/details/79587321</a><br>原文链接：<a href="https://www.jianshu.com/p/beb8d611340a" target="_blank" rel="noopener">https://www.jianshu.com/p/beb8d611340a</a></p>]]></content>
      
      <categories>
          
          <category> 实践教程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo</title>
      <link href="/blog/2018/01/13/hexo/"/>
      <url>/blog/2018/01/13/hexo/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
