<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[移动端H5缓存]]></title>
    <url>%2Fblog%2F2018%2F04%2F20%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[HTML5是新一代的HTML标准，加入很多新的特性。离线存储（亦称为缓存机制）是其中一个非常重要的特性。HTML5引入了离线存储，这意味着移动Web应用可进行缓存，并可在没有Internet连接时离线进行访问。HTML5应用程序缓存为应用带来三个优势：123离线浏览：用户可在应用离线时使用它们；速度：已缓存资源加载得更快；减少服务器负载：浏览器将只从服务器下载更新过或更改过的资源。 根据标准，到目前为止，H5共有6种缓存机制，有些是之前已有，有些是H5才新加入的。123456浏览器缓存机制Dom Storgage（Web Storage）存储机制Web SQL Database存储机制（不推荐）Application Cache（AppCache）机制Indexed Database （IndexedDB）File System API 下面分析各种缓存机制的原理、用法及特点；然后针对Android移动端Web性能加载优化的需求，看如何适当利用缓存机制来提高Web的加载性能。 1. 浏览器缓存机制浏览器缓存机制是指通过HTTP协议头里的Cache-Control（或Expires）和Last-Modified（或Etag）等字段来控制文件缓存的机制。这应该是Web中最早的缓存机制了，是在HTTP协议中实现的，有点不同于Dom Storage、AppCache等缓存机制，但本质上是一样的，可以理解为一个是协议层实现的，一个是应用层实现的。 Cache-Control和Last-Modified一般用在静态资源文件上，如JS、CSS和一些图像文件。通过设置资源文件缓存属性，对提高资源文件加载速度，节省流量很有意义，特别是移动网络环境。但问题是：缓存有效时长应该如何设置，如果太短，就起不到缓存的使用，设置的太长，在服务端资源文件有更新时，浏览器有缓存，则不能及时取到最新的文件。 对于移动端的缓存，任何一个网络请求的增加，加载消耗时间都是比较大的（尤其弱网环境下）。对于强缓存只要缓存不到期，是不会向服务器发送请求，但是如果是协商缓存的情况下，304的问题就比较大，它会造成无用的服务器请求，导致网络的延时。Last-Modified需要向服务器发起查询请求，才能知道资源文件有没有更新，虽然服务器可能返回304告诉没有更新，但也还有一个请求的过程。对于移动网络，这个请求可能是比较耗时的，有一种说法叫“消灭304”，指的就是优化掉304的请求。 通过抓包可以发现，带if-Modified-Since字段的请求，如果服务器回包304，回包会带有Cache-Control:max-age或Expires字段，文件的强缓存有效时间会更新，就是文件强缓存会重新有效。304回包后如果再请求，则又可以直接使用本地缓存文件了，不用再向服务器发送请求查询文件是否更新了，除非新的强缓存资源文件时间再次过期。 另外，Cache-Control与Last-Modified是浏览器内核的机制，一般都是标准的实现，不能更改或设置。以QQ浏览器的X5为例，Cache-Control与Last-Modified缓存不能禁用，缓存容量是12MB，不分Host，过期的缓存会最先被清除。如果都没过期，应该优先清最早的缓存或最快到期的或文件大小最大的，过期缓存也有可能还是有效的，清除缓存会导致资源文件的重新拉取。还有，浏览器，如X5，在使用缓存文件时，是没有对缓存文件内容进行校验的，这样缓存文件内容被修改的可能。 分析发现，浏览器的缓存机制还不是非常完美的缓存机制。完美的缓存机制应该是这样的： 缓存文件没更新，尽可能使用缓存，不用和服务器交互；缓存文件有更新时，第一时间能使用到新的文件；缓存的文件要保持完整性，不使用被修改过的缓存文件；缓存的容量大小要能设置或控制，缓存文件不能因为存储空间限制或过期被清除。 以X5为例，第1、2条不能同时满足，第3、4条都不能满足。 在实际应用中，为了解决Cache-Control缓存时长不好设置的问题，以及为了“消灭304”，采用的方式是： 1. 在要缓存的资源文件名中加上版本号或文件MD5值字串，如common.d5d02a02.js、common.v1.js，同时设置Cache-Control:max-age=31536000，也就是一年。在一年时间内，资源文件如果本地有缓存，就会使用缓存,这样就可以避免协商缓存的304的回包现象。2. 如果资源文件有修改，则更新文件内容，同时修改资源文件名，如common.v2.js，html页面也会引用新的资源文件名，实现静态资源非覆盖式更新。通过这种方式，实现了：缓存文件没有更新，则使用缓存；缓存文件有更新，则第一时间使用最新文件的目的。即上面说的第1、2条。第3、4条由于浏览器内部机制，目前还无法满足。 2. Dom Storage（Web Storage）存储机制DOM存储是一套在Web Applications 1.0规范中首次引入的与存储相关的特性的总称，现在已经分离出来，单独发展成为独立的W3C Web存储规范。DOM存储被设计为用来提供一个更大存储量、更安全、更便捷的存储方法，从而可以代替掉将一些不需要让服务器知道的信息存储到Cookies里的这种传统方法。这是对Dom Storage存储机制的官方表述。 Dom Storage是通过存储字符串的Key/Value对来提供的，并提供5MB（不同浏览器可能不同，分Host）的存储空间（Cookies才4KB)。另外Dom Storage存储的数据在本地，不像 Cookies，每次请求一次页面，Cookies 都会发送给服务器。 DOM Storage分为sessionStorage和localStorage。localStorage对象和sessionStorage对象使用方法基本相同，它们的区别在于作用的范围不同。sessionStorage用来存储与页面相关的数据，它在页面关闭后无法使用。而localStorage则持久存在，在页面关闭后也可以使用。 sessionStorage是个全局对象，它维护着在页面会话（page session）期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入（reload）或者被恢复（restores）时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。 当浏览器被意外刷新的时候，一些临时数据应当被保存和恢复。sessionStorage对象在处理这种情况的时候是最有用的，比如恢复我们在表单中已经填写的数据。1234567891011121314151617181920212223&lt;script type="text/javascript"&gt; // 当页面刷新时，从sessionStorage恢复之前输入的内容 window.onload = function()&#123; if (window.sessionStorage) &#123; var name = window.sessionStorage.getItem("name"); if (name != "" || name != null)&#123; document.getElementById("name").value = name; &#125; &#125; &#125;; // 将数据保存到sessionStorage对象中 function saveToStorage() &#123; if (window.sessionStorage) &#123; var name = document.getElementById("name").value; window.sessionStorage.setItem("name", name); window.location.href="session_storage.html"; &#125; &#125; &lt;/script&gt;&lt;form action="./session_storage.html"&gt; &lt;input type="text" name="name" id="name"/&gt; &lt;input type="button" value="Save" onclick="saveToStorage()"/&gt;&lt;/form&gt;&lt;br&gt; 把上面的代码复制到session_storage.html（也可以从附件中直接下载）页面中，用Google Chrome浏览器的不同Page或Window打开，在输入框中分别输入不同的文字，再点击“Save”，然后分别刷新。每个Page或Window显示都是当前Page输入的内容，互不影响。关闭Page，再重新打开，上一次输入保存的内容已经没有了。 Local Storage的接口、用法与Session Storage一样，唯一不同的是：Local Storage保存的数据是持久性的。当前Page关闭（Page Session结束后），保存的数据依然存在。重新打开Page，上次保存的数据可以获取到。另外，Local Storage是全局性的，同时打开两个Page会共享一份存数据，在一个Page中修改数据，另一个Page中是可以感知到的。123456789101112131415&lt;script&gt; // 通过localStorage直接引用key, 另一种写法，等价于： // localStorage.getItem(&quot;pageLoadCount&quot;); // localStorage.setItem(&quot;pageLoadCount&quot;, value); if (!localStorage.pageLoadCount) &#123; localStorage.pageLoadCount = 0; localStorage.pageLoadCount = parseInt(localStorage.pageLoadCount) + 1; document.getElementById(&apos;count&apos;).textContent = localStorage.pageLoadCount; &#125;&lt;/script&gt;&lt;p&gt; You have viewed this page &lt;span id=&quot;count&quot;&gt;an untold number of&lt;/span&gt; time(s)&lt;/p&gt;&lt;br&gt; 将上面代码复制到local_storage.html的页面中，用浏览器打开，pageLoadCount的值是1；关闭Page重新打开，pageLoadCount的值是2。这是因为第一次的值已经保存了。用两个Page同时打开local_storage.html，并分别交替刷新，发现两个Page是共享一个pageLoadCount的。 分析：Dom Storage给Web提供了一种更录活的数据存储方式，存储空间更大（相对Cookies），用法也比较简单，方便存储服务器或本地的一些临时数据。 从Dom Storage提供的接口来看，Dom Storage适合存储比较简单的数据，如果要存储结构化的数据，可能要借助JSON了，将要存储的对象转为JSON字串。不太适合存储比较复杂或存储空间要求比较大的数据，也不适合存储静态的文件等。 在Android内嵌Webview中，需要通过Webview设置接口启用Dom Storage。123WebView myWebView = (WebView) findViewById(R.id.webview);WebSettings webSettings = myWebView.getSettings();webSettings.setDomStorageEnabled(true);&lt;br&gt; 拿Android类比的话，Web的Dom Storage机制类似于Android的SharedPreference机制。 3. Web SQL Database存储机制HTML5也提供基于SQL的数据库存储机制，用于存储适合数据库的结构化数据。但根据官方的标准文档，这种存储机制不再推荐使用，将来也不再维护，而是推荐使用AppCache和IndexedDB，所以这里就不多做阐述了。 4. Application Cache机制Application Cache（简称AppCache）似乎是为支持Web App离线使用而开发的缓存机制。它的缓存机制类似于浏览器的缓存（Cache-Control和Last-Modified）机制，都是以文件为单位进行缓存，且文件有一定更新机制。但AppCache是对浏览器缓存机制的补充，不是替代。先拿W3C官方的一个例子，说下AppCache机制的用法与功能：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html manifest="demo_html.appcache"&gt;&lt;body&gt;&lt;script src="demo_time.js"&gt;&lt;/script&gt; &lt;p id="timePara"&gt;&lt;button onclick="getDateTime()"&gt;Get Date and Time&lt;/button&gt;&lt;/p&gt; &lt;p&gt;&lt;img src="img_logo.gif" width="336" height="69"&gt;&lt;/p&gt; &lt;p&gt; Try opening &lt;a href="tryhtml5_html_manifest.htm" target="_blank"&gt; this page&lt;/a&gt; , then go offline, and reload the page. The script and the image should still work. &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 上面HTML文档，引用外部一个JS文件和一个GIF图片文件，在其HTML头中通过manifest属性引用了一个appcache结尾的文件。 我们在Google Chrome浏览器中打开这个HTML链接，JS功能正常，图片也显示正常。禁用网络，关闭浏览器重新打开这个链接，发现JS工作正常，图片也显示正常。当然也有可能是浏览缓存起的作用，我们可以在文件的浏览器缓存过期后，禁用网络再试，发现HTML页面也是正常的。 通过Google Chrome浏览器自带的工具，我们可以查看已经缓存的AppCache（分Host）。 上面截图中的缓存，就是我们刚才打开HTML的页面AppCache。从截图中看，HTML页面及HTML引用的JS、GIF图像文件都被缓存了；另外HTML头中manifest属性引用的appcache文件也缓存了。 AppCache的原理有两个关键点：manifest属性和manifest文件。 HTML在头中通过manifest属性引用manifest文件。manifest文件，就是上面以appcache结尾的文件，是一个普通文件文件，列出了需要缓存的文件。123CACHE MANIFESTdemo.jsimg.gif 上面截图中的manifest文件，就HTML代码引用的manifest文件。文件比较简单，第一行是关键字，第二、三行就是要缓存的文件路径（相对路径）。这只是最简单的manifest文件，完整的还包括其他关键字与内容。引用manifest文件的HTML和manifest文件中列出的要缓存的文件最终都会被浏览器缓存。 完整的manifest文件，包括三个Section，如下：123456789CACHE MANIFEST# 2012-02-21 v1.0.0/theme.css/logo.gif/main.jsNETWORK:login.aspFALLBACK:/html/ /offline.html 总的来说，浏览器在首次加载HTML文件时，会解析manifest属性，并读取manifest文件，获取CACHE MANIFEST下要缓存的文件列表，再对文件缓存。 AppCache的缓存文件，与浏览器的缓存文件分开存储的，还是一份？应该是分开的。因为AppCache在本地也有5MB（分Host）的空间限制。 AppCache在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新manifest文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查manifest文件有没有修改（byte by byte)，发现有修改，就会重新获取manifest文件，对CACHE MANIFEST下文件列表检查更新。manifest文件与缓存文件的检查更新也遵守浏览器缓存机制。 如用用户手动清了AppCache缓存，下次加载时，浏览器会重新生成缓存，也可算是一种缓存的更新。另外，Web App也可用代码实现缓存更新。 分析：AppCache看起来是一种比较好的缓存方法，除了缓存静态资源文件外，也适合构建Web离线 App。在实际使用中有些需要注意的地方，有一些可以说是”坑“。 1. 要更新缓存的文件，需要更新包含它的manifest文件，那怕只加一个空格。常用的方法，是修改manifest文件注释中的版本号。如：# 2012-02-21 v1.0.0。 2.被缓存的文件，浏览器是先使用，再通过检查manifest文件是否有更新来更新缓存文件。这样缓存文件可能用的不是最新的版本。 3. 在更新缓存过程中，如果有一个文件更新失败，则整个更新会失败。 4. manifest和引用它的HTML要在相同Host。 5. manifest文件中的文件列表，如果是相对路径，则是相对manifest文件的相对路径。 6. manifest也有可能更新出错，导致缓存文件更新失败。 7. 没有缓存的资源在已经缓存的HTML中不能加载，即使有网络。例如：http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-network/。 8. manifest文件本身不能被缓存，且manifest文件的更新使用的是浏览器缓存机制。所以manifest文件的Cache-Control缓存时间不能设置太长。另外，根据官方文档，AppCache已经不推荐使用了，标准也不会再支持。现在主流的浏览器都是还支持AppCache的，以后就不太确定了。 在Android内嵌Webview中，需要通过Webview设置接口启用AppCache，同时还要设置缓存文件的存储路径，另外还可以设置缓存的空间大小。 5. Indexed DatabaseIndexedDB也是一种数据库的存储机制，但不同于已经不再支持的Web SQL Database。IndexedDB不是传统的关系数据库，可归为NoSQL数据库。IndexedDB又类似于Dom Storage的key-value的存储方式，但功能更强大，且存储空间更大。 IndexedDB存储数据是key-value的形式。Key是必需，且要唯一；Key可以自己定义，也可由系统自动生成。Value也是必需的，但Value非常灵活，可以是任何类型的对象。一般Value都是通过Key来存取的。 IndexedDB提供了一组API，可以进行数据存、取以及遍历。这些API都是异步的，操作的结果都是在回调中返回。 IndexedDB有个非常强大的功能，就是index（索引）。它可对Value对象中任何属性生成索引，然后可以基于索引进行Value对象的快速查询。 要生成索引或支持索引查询数据，需求在首次生成存储对象时，调用接口生成属性的索引。可以同时对对象的多个不同属性创建索引。如下面代码就对name和email两个属性都生成了索引。1234var objectStore = thisDB.createObjectStore(&quot;people&quot;,&#123; autoIncrement:true &#125;)//first arg is name of index, second is the path (col)objectStore.createIndex(&quot;name&quot;,&quot;name&quot;, &#123;unique:false&#125;)objectStore.createIndex(&quot;email&quot;,&quot;email&quot;, &#123;unique:true&#125;) 生成索引后，就可以基于索引进行数据的查询。Android在4.4开始加入对IndexedDB的支持，只需打开允许JS执行的开关就好了。 分析：IndexedDB是一种灵活且功能强大的数据存储机制，它集合了Dom Storage和Web SQL Database的优点，用于存储大块或复杂结构的数据，提供更大的存储空间，使用起来也比较简单。可以作为Web SQL Database的替代。不太适合静态文件的缓存。以key-value 的方式存取对象，可以是任何类型值或对象，包括二进制。可以对对象任何属性生成索引，方便查询。较大的存储空间，默认推荐250MB（分Host），比Dom Storage的5MB要大得多。通过数据库的事务（tranction）机制进行数据操作，保证数据一致性。异步的 API 调用，避免造成等待而影响体验。 6. File System APIFile System API是HTML5新加入的存储机制。它为Web App提供了一个虚拟的文件系统，就像Native App访问本地文件系统一样。由于安全性的考虑，这个虚拟文件系统有一定的限制。Web App在虚拟的文件系统中，可以进行文件（夹）的创建、读、写、删除、遍历等操作。 File System API也是一种可选的缓存机制，和前面的SQL Database、IndexedDB 和App Cache等一样。File System API有自己的一些特定的优势：123可以满足大块的二进制数据（large binary blobs）存储需求。可以通过预加载资源文件来提高性能。可以直接编辑文件。 浏览器给虚拟文件系统提供了两种类型的存储空间：临时的和持久性的。临时的存储空间是由浏览器自动分配的，但可能被浏览器回收；持久性的存储空间需要显示的申请，申请时浏览器会给用户一提示，需要用户进行确认。持久性的存储空间是Web App自己管理，浏览器不会回收，也不会清除内容。持久性的存储空间大小是通过配额来管理的，首次申请时会一个初始的配额，配额用完需要再次申请。 虚拟的文件系统是运行在沙盒中，不同Web App的虚拟文件系统是互相隔离的，虚拟文件系统与本地文件系统也是隔离的。 移动端Web加载性能（缓存）优化分析完HTML5提供的各种缓存机制，回到移动端（针对Android，可能也适用于iOS）的场景。现在Android App（包括手Q和WX）大多嵌入了Webview的组件（系统Webview或QQ浏览器的X5组件），通过内嵌Webview来加载一些HTML5的运营活动页面或资讯页。这样可充分发挥Web前端的优势：快速开发、发布，灵活上下线。但Webview也有一些不可忽视的问题，比较突出的就是加载相对较慢，会相对消耗较多流量。 通过对一些HTML5页面进行调试及抓包发现，每次加载一个HTML5页面，都会有较多的请求。除了HTML主URL自身的请求外，HTML外部引用的JS、CSS、字体文件、图片都是一个独立的HTTP请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化 Web的加载性能。 缓存机制 优势 适用场景 浏览器 HTTP协议层支持 静态文件缓存 Dom Storage 较大存储空间，简单 临时简单数据存储，Cookie扩展 Web SQL Database 存储复杂数据结构 不推荐，IndexDB替代 AppCache 构建离线App 不推荐，离线App，静态文件缓存 IndexDB 存储任何类型数据，索引 结构，关系复杂的数据结构 File System API 支持文件系统操作 数据适合以文件进行管理场景 结论：综合各种缓存机制比较，对于静态文件，如JS、CSS、字体、图片等，适合通过浏览器缓存机制来进行缓存，通过缓存文件可大幅提升Web的加载速度，且节省流量。但也有一些不足：缓存文件需要首次加载后才会产生；浏览器缓存的存储空间有限，缓存有被清除的可能；缓存的文件没有校验。要解决这些不足，可以参考手Q的离线包，它有效的解决了这些不足。 对于Web在本地或服务器获取的数据，可以通过Dom Storage和IndexedDB进行缓存。也在一定程度上减少和Server的交互，提高加载速度，同时节省流量。 @转载请注明出处原文链接：https://www.csdn.net/article/2015-12-16/2826489/1]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web缓存机制]]></title>
    <url>%2Fblog%2F2018%2F04%2F03%2FWeb%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[缓存机制是web开发的重要知识点，也是系统优化的重要方向。在前端开发中，缓存有利于加快网页的加载速度，同时缓存能够被反复利用，所以可以减少流量和带宽的开销。这里将系统的介绍在Web开发中的缓存方式，还会涉及到部分操作系统缓存知识。本文会重点介绍浏览器端的缓存机制也就是HTTP缓存，其机制是根据HTTP报文的缓存标识进行的。在分析缓存机制之前，先介绍下浏览器的HTTP报文。HTTP报文分为两种： HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)，如下图 HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体，如下图 注：通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。 Web开发中的不同缓存1. 数据库缓存 我们可能听说过memcached，它就是一种数据库层面的缓存方案。类似的还有Redis缓存，也是一种基于内存的数据库，它的功能更加强大，并且支持备份和数据持久化。数据库缓存是指，当web应用的关系比较复杂，数据库中的表很多的时候，如果频繁进行 数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。 2. CDN缓存 CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。通常情况下，浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，浏览器和服务器之间的缓存机制，在这种架构下同样适用。一般对于网站上的静态资源文件可以采用CDN分发，可以加快网站访问速度。 3. 代理服务器缓存 代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。 4. 浏览器缓存 每个浏览器都实现了 HTTP 缓存，我们通过浏览器使用HTTP协议与服务器交互的时候，浏览器就会根据一套与服务器约定的规则进行缓存工作。最新的HTML5协议新增了离线缓存属性，对缓存机制进一步的优化，可以达到，实现图片存在客户端，跨域共享客户端缓存，做到真正的离线访问WEB应用，实现客户端的数据库。 5. 应用层缓存 应用层缓存是指我们在代码层面上做的缓存。通过代码逻辑，把曾经请求过的数据或资源等，缓存起来，再次需要数据时通过逻辑上的处理选择可用的缓存的数据。h5新增的storage和数据库缓存，都可以归属到应用层缓存。 操作系统缓存首先关于存储的概念有以下几种方式：cache：缓存为了让从DB/磁盘拿出来的东西放到缓存（放于内存）；磁盘文件：本地存储的视频，图片，计算机里面的文件；数据库：系统项目中的数据存储；内存：计算机中所有的程序运行都是在内存中，所以内存对计算机的性能影响很大。在操作系统缓存机制中，有buffer和cache两种方式，它们都是占用内存（buffer记录元数据，权限属性等，cache缓存文件）。I/O过程本身的延迟，以及高速设备与低速设备交互时的等待延迟，Buffer和Cache就是从这两个方向上产生的优化提高系统性能的方式。 buffer缓存是块设备的读写缓冲区，buffer是I/O缓存，用于内存和硬盘（或其他 I/O设备）之间的数据交换的速度而设计的。通常在写一个非常大的文件，文件会被分成一个个的小block块，往内存上写，然后再写入磁盘,这样的效率会很慢。这种情况下，内存就会攒足一次大的block块再写入磁盘，这样就不会有第一种情况里的延迟，这就是buffer。buffer的主要目的是进行流量整形，把突发的大数量较小规模读写整理成平稳的较大规模的I/O，以减少响应次数（比如从网上下载视频，不能下一点点数据就写入硬盘，而是达到一定量的数据一整块写，不然硬盘负荷太大）。 Cache缓存是高速缓存，用于cpu与内存之间的缓冲，是系统两端处理速度不匹配时的一种折衷策略。主要原因是cpu与memory，由于cpu快，memory跟不上，且有些值使用次数多，所以放入cache中，主要目的是使用内存来缓存可能被再次访问的数据，可以保持冗余的、被重复计算的、计算后的数据（buffer不行）。Cache是经常被使用在I/O请求上，来提高系统性能。如果cache的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO必会非常小。 Web中浏览器缓存浏览器端的缓存分为强缓存（Expires和Cache-Control—优先级高，直接使用本地缓存资源）和协商缓存（Last-Modified / If-Modified-Since和 Etag / If-None-Match—优先级高，先发送请求到服务器端确认资源更改来确认是否使用缓存）。 1. 强缓存在HTTP/1.0使用的是Expires字段，该字段表示缓存到期时间，即有效时间+当时服务器的时间，然后将这个时间设置在header中返回给服务器。如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。该时间是一个绝对时间，由于服务端和浏览器端时间不一致，或者用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，因此更推荐另一种强缓存方式。Expires字段如下：1Expires: Thu, 15 Mar 2018 09:09:09 GMT 在HTTP/1.1中，增加了一个字段Cache-Control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求，主要是利用该字段的max-age值来进行判断，它是一个相对值，资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则资源失效。1Cache-Control: max-age=9590000 Cache-Control除了max-age字段外，还有几个比较常用的字段设置值： no-cache：不用本地缓存，使用协商缓存，先发送请求到服务器根据响应确认资源是否被更改，如果之前的响应中存在ETag或者Last-Modified，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 注意：如果cache-control与expires同时存在的话，cache-control的优先级高于expires 2. 协商缓存协商缓存（Last-Modified或者Etag）的过程是先从缓存中获取对应的数据标识，然后向服务器发送请求，确认数据是否更新，如果更新，则返回新数据和新缓存。反之，则返回304状态码，告知客户端缓存未更新，可继续使用，这正好弥补了一些强缓存的缺陷，协商缓存主要应用于一些时常需要动态更新的资源文件。协商缓存在协议里的字段是Last-Modified或者Etag，这两个字段都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。 Last-Modified/If-Modified-Since具体过程： 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header浏览器收到304的响应后，就会从缓存中加载资源如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值 Etag/If-None-Match Etag字段值是由服务器生成的每个资源的唯一标识字符串（一般都是hash生成的），只要资源内容有变化这个值就会改变,其判断过程与Last-Modified类似，与它不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，响应头还会把这个ETag返回，即使这个ETag跟之前的没有变化。 Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，之所以在HTTP1.1中新增Etag主要为了解决几个Last-Modified的问题： 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；某些服务器不能精确的得到文件的最后修改时间。这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。 注意：Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。 用户浏览器行为对缓存的影响刷新网页 =&gt; 如果缓存没有失效，浏览器会直接使用缓存；反之，则向服务器请求数据手动刷新（F5） =&gt; 浏览器会认为缓存失效，在请求服务器时加上Cache-Control: max-age=0字段，然后询问服务器数据是否更新。强制刷新（Ctrl + F5） =&gt; 浏览器会直接忽略缓存，在请求服务器时加上Cache-Control: no-cache字段，然后重新向服务器拉取文件。更多用户行为可以用如下表格进行表示： 用户行为 Expires / Cache-Control Last-Modified / Etag 地址栏回车 有效 有效 页面链接跳转 有效 有效 新窗口 有效 有效 前进后退 有效 有效 F5刷新 无效 有效 Ctrl+F5刷新 无效 无效 移动端的缓存处理Cache-Control和Last-Modified一般用在静态资源文件上，如JS、CSS和一些图像文件。通过设置资源文件缓存属性，对提高资源文件加载速度，节省流量很有意义，特别是移动网络环境。但问题是：缓存有效时长应该如何设置，如果太短，就起不到缓存的使用，设置的太长，在服务端资源文件有更新时，浏览器有缓存，则不能及时取到最新的文件。 对于移动端的缓存，任何一个网络请求的增加，加载消耗时间都是比较大的（尤其弱网环境下）。对于强缓存只要缓存不到期，是不会向服务器发送请求，但是如果是协商缓存的情况下，304的问题就比较大，它会造成无用的服务器请求，导致网络的延时。Last-Modified需要向服务器发起查询请求，才能知道资源文件有没有更新，虽然服务器可能返回304告诉没有更新，但也还有一个请求的过程。对于移动网络，这个请求可能是比较耗时的，有一种说法叫“消灭304”，指的就是优化掉304的请求。 通过抓包可以发现，带if-Modified-Since字段的请求，如果服务器回包304，回包会带有Cache-Control:max-age或Expires字段，文件的强缓存有效时间会更新，就是文件强缓存会重新有效。304回包后如果再请求，则又可以直接使用本地缓存文件了，不用再向服务器发送请求查询文件是否更新了，除非新的强缓存资源文件时间再次过期。 另外，Cache-Control与Last-Modified是浏览器内核的机制，一般都是标准的实现，不能更改或设置。以QQ浏览器的X5为例，Cache-Control与Last-Modified缓存不能禁用，缓存容量是12MB，不分Host，过期的缓存会最先被清除。如果都没过期，应该优先清最早的缓存或最快到期的或文件大小最大的，过期缓存也有可能还是有效的，清除缓存会导致资源文件的重新拉取。还有，浏览器，如X5，在使用缓存文件时，是没有对缓存文件内容进行校验的，这样缓存文件内容被修改的可能。 分析发现，浏览器的缓存机制还不是非常完美的缓存机制。完美的缓存机制应该是这样的： 缓存文件没更新，尽可能使用缓存，不用和服务器交互；缓存文件有更新时，第一时间能使用到新的文件；缓存的文件要保持完整性，不使用被修改过的缓存文件；缓存的容量大小要能设置或控制，缓存文件不能因为存储空间限制或过期被清除。 以X5为例，第1、2条不能同时满足，第3、4条都不能满足。 在实际应用中，为了解决Cache-Control缓存时长不好设置的问题，以及为了“消灭304”，采用的方式是： 1. 在要缓存的资源文件名中加上版本号或文件MD5值字串，如common.d5d02a02.js、common.v1.js，同时设置Cache-Control:max-age=31536000，也就是一年。在一年时间内，资源文件如果本地有缓存，就会使用缓存,这样就可以避免协商缓存的304的回包现象。2. 如果资源文件有修改，则更新文件内容，同时修改资源文件名，如common.v2.js，html页面也会引用新的资源文件名，实现静态资源非覆盖式更新。通过这种方式，实现了：缓存文件没有更新，则使用缓存；缓存文件有更新，则第一时间使用最新文件的目的。即上面说的第1、2条。第3、4条由于浏览器内部机制，目前还无法满足。 浏览器缓存回忆浏览器端强缓存优于协商缓存进行，先判断强缓存资源是否过期，若强缓存（Expires和Cache-Control）生效则直接使用本地浏览器缓存，若失效则进行协商缓存（Last-Modified / If-Modified-Since和 Etag / If-None-Match）发送请求到服务端，协商缓存由服务器响应和本地进行对比验证决定资源是否有效，若协商缓存失效，那么代表该请求的缓存失效，择重新发送请求获取响应结果下载资源，再存入浏览器缓存中，生效则返回304状态码，继续使用缓存，整个浏览器缓存主要过程如下图： @转载请注明出处]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo迁移]]></title>
    <url>%2Fblog%2F2018%2F03%2F21%2Fhexo%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[操作步骤一、安装必要软件12安装 Git 客户端安装 node JS 二、在 github 官网添加新电脑产生的密钥三、源文件拷贝将原来电脑上个人博客目录下必要文件拷贝到新电脑上（比如D:/Blog目录下），注意无需拷贝全部，只拷如下几个文件：12345_config.ymlpackage.jsonscaffolds/source/themes/ 四、安装 hexo1在 cmd 下输入指令安装 hexo：npm install hexo-cli -g 五、进入 D:/Blog 目录（拷贝到新电脑的目录），安装相关模块1234npm installnpm install hexo-deployer-git --save // 文章部署到 git 的模块npm install hexo-generator-feed --save // 建立 RSS 订阅（选择安装）npm install hexo-generator-sitemap --save // 建立站点地图（选择安装） 六、部署发布文章123hexo clean // 清除缓存 网页正常情况下可以忽略此条命令hexo g // 生成静态网页hexo d // 开始部署 第二种方法具体的思路是：在生成的已经推到github上的hexo静态代码出建立一个分支，利用这个分支来管理自己hexo的源文件。如果能在刚刚配置hexo的时候就想好以后的迁移的问题就太好了，可以省掉很多麻烦。 具体的操作：克隆gitHub上面生成的静态文件到本地1git clone https://github.com/yourname/hexo-test.github.io.git 把克隆到本地的文件除了git的文件都删掉，找不到git的文件的话就到删了吧。不要用hexo init初始化。 将之前使用hexo写博客时候的整个目录（所有文件）搬过来。把该忽略的文件忽略了1touch .gitignore 创建一个叫hexo的分支1git checkout -b hexo 提交复制过来的文件到暂存区1git add --all 提交1git commit -m &quot;新建分支源文件&quot; 推送分支到github1git push --set-upstream origin hexo 到这里基本上就搞定了，以后再推就可以直接git push了，hexo的操作跟以前一样。 今后无论什么时候想要在其他电脑上面用hexo写博客，就直接把创建的分支克隆下来，npm install安装依赖之后就可以用了。 克隆分支的操作1git clone -b hexo https://github.com/yourname/hexo-test.github.io.git 因为上面创建的是一个名字叫hexo的分支，所以这里-b后面的是hexo，再把后面的gitHub的地址换成你自己的hexo博客的地址就可以了。 这样完了以后，每次写完博客发布之后不要忘了还要git push把源文件推到分支上。 原文链接：https://blog.csdn.net/lvonve/article/details/79587321原文链接：https://www.jianshu.com/p/beb8d611340a]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2Fblog%2F2018%2F03%2F12%2Fhexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
